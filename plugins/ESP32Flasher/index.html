<!--
Technical Limitation:
Web Serial cannot change the baud rate without reopening the port, which may reset the device. Therefore, this tool keeps a single baud rate from start to end.
ESP32 ROM prints its reset messages at 115200 baud. When using a USB-UART adapter with RX/TX wiring:
- Use 115200 to see ROM reset messages (slower link), or
- Use a higher baud (e.g., 921600) for speed but you will not see reset messages.
This does not apply to native USB/JTAG interfaces on ESP32-S series devices.
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Flasher Test Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1117;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #161b22;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 1px solid #30363d;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #0d1117;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            border: 1px solid #30363d;
        }

        .section h2 {
            color: #c9d1d9;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        button.danger {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            box-shadow: 0 4px 15px rgba(250, 112, 154, 0.4);
        }

        .info-panel {
            background: #161b22;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            border: 1px solid #30363d;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #21262d;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            font-weight: 600;
            color: #8b949e;
        }

        .info-value {
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
        }

        .log-container {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 6px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .log-entry {
            margin-bottom: 5px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .log-debug {
            color: #4fc3f7;
        }

        .log-info {
            color: #81c784;
        }

        .log-error {
            color: #e57373;
        }

        .log-warn {
            color: #ffb74d;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #21262d;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
            position: relative;
            border: 1px solid #30363d;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-top: 10px;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.6);
        }

        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 4px;
            font-size: 14px;
            color: #c9d1d9;
            display: none;
        }

        .input-group {
            margin-top: 10px;
        }

        .input-group select {
            width: 100%;
            max-width: 300px;
            padding: 10px;
            border: 2px solid #30363d;
            background: #0d1117;
            color: #c9d1d9;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            cursor: pointer;
        }

        .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group select option {
            background: #0d1117;
            color: #c9d1d9;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #8b949e;
        }

        .input-group input[type="text"],
        .input-group input[type="number"] {
            width: 100%;
            max-width: 300px;
            padding: 10px;
            border: 2px solid #30363d;
            background: #0d1117;
            color: #c9d1d9;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .status-connected {
            background: #2ea043;
            color: #ffffff;
        }

        .status-disconnected {
            background: #da3633;
            color: #ffffff;
        }

        .status-busy {
            background: #d29922;
            color: #ffffff;
        }

        .status-warning {
            background: #f85149;
            color: #ffffff;
        }

        .radio-group {
            display: flex;
            gap: 20px;
            align-items: center;
            padding: 15px;
            background: #0d1117;
            border-radius: 6px;
            margin-bottom: 15px;
            border: 1px solid #30363d;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: #c9d1d9;
            font-weight: 500;
        }

        .radio-group input[type="radio"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }

        .radio-group strong {
            color: #58a6ff;
            margin-right: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(255, 255, 255, .3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-left: 8px;
            vertical-align: middle;
        }

        @keyframes glow {

            0%,
            100% {
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.6),
                    0 0 30px rgba(255, 255, 0, 0.8),
                    0 0 50px rgba(255, 255, 0, 0.6),
                    inset 0 0 20px rgba(255, 255, 0, 0.3);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 4px 25px rgba(102, 126, 234, 0.8),
                    0 0 50px rgba(255, 255, 0, 1),
                    0 0 80px rgba(255, 255, 0, 0.8),
                    inset 0 0 30px rgba(255, 255, 0, 0.5);
                transform: scale(1.02);
            }
        }

        .highlighted {
            animation: glow 1.5s ease-in-out infinite !important;
            border: 2px solid rgba(255, 255, 0, 0.8) !important;
        }

        .device-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            padding: 12px 14px;
            border-radius: 8px;
            color: #f0f6fc;
            font-size: 14px;
            max-width: 420px;
            z-index: 1000;
            display: none;
            line-height: 1.4;
        }

        .device-popup strong {
            color: #79c0ff;
        }

        @keyframes blink-red {

            0%,
            100% {
                box-shadow: 0 0 0 rgba(0, 0, 0, 0);
            }

            50% {
                box-shadow: 0 0 12px rgba(248, 81, 73, 0.8);
            }
        }

        .device-popup.secure-warning {
            border-color: #f85149;
            background: rgba(62, 12, 12, 0.95);
            color: #fff;
            animation: blink-red 1s linear infinite;
        }
    </style>
    <!-- Built: 2026-01-04T12:30:04.959Z -->
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üîß ESP32 Flasher Test Suite</h1>
            <p>Comprehensive testing tool for ESP32/ESP32-S2/ESP32-S3/ESP32-C3/ESP32-C6 devices</p>
            <a href="#debug" onclick="isDebugMode = true; setupAdvancedControls()">Advanced mode</a>
        </div>

        <div class="content">
            <!-- Connection Section -->
            <div class="section">
                <h2>üì° Connection</h2>
                <div class="radio-group">
                    <strong>Connection Type:</strong>
                    <label>
                        <input type="radio" name="connectionType" value="webserial" checked>
                        Web Serial
                    </label>
                    <label>
                        <input type="radio" name="connectionType" value="webusb">
                        WebUSB
                    </label>
                </div>
                <div class="input-group" id="baudSelectGroup" style="display: none;">
                    <label for="baudRateSelect">Baud Rate (advanced):</label>
                    <select id="baudRateSelect">
                        <option value="115200">115200</option>
                        <option value="921600" selected>921600</option>
                        <option value="1000000">1000000</option>
                    </select>
                </div>
                <div class="button-group">
                    <button id="connectBtn" onclick="connectDevice()">Connect Device</button>
                    <button id="disconnectBtn" onclick="disconnectDevice()" disabled>Disconnect</button>
                    <button id="hardResetBtn" onclick="hardReset()" disabled>Reset (Download)</button>
                    <button id="appResetBtn" onclick="appReset()" disabled>Reset (Application)</button>
                    <button id="syncBtn" onclick="syncDevice()" disabled>Sync & Detect</button>
                </div>
                <div class="info-panel">
                    <div class="info-row">
                        <span class="info-label">Status:</span>
                        <span class="info-value" id="connectionStatus">
                            Disconnected
                            <span class="status-badge status-disconnected">OFFLINE</span>
                        </span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Chip Type:</span>
                        <span class="info-value" id="chipType">Not detected</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">MAC Address:</span>
                        <span class="info-value" id="macAddress">--:--:--:--:--:--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Stub Loader:</span>
                        <span class="info-value" id="stubStatus">Not loaded</span>
                    </div>
                </div>
            </div>

            <!-- Stub Loader Section -->
            <div class="section">
                <h2>‚ö° Stub Loader</h2>
                <div class="button-group">
                    <button id="loadStubBtn" onclick="loadStub()" disabled>Load Stub</button>
                </div>
            </div>

            <!-- Memory Operations Section -->
            <div class="section">
                <h2>üíæ Memory Operations</h2>
                <div class="button-group">
                    <button id="readRegBtn" onclick="readRegister()" disabled>Read Register</button>
                </div>
                <div class="input-group">
                    <label for="regPreset">Preset Registers:</label>
                    <select id="regPreset" onchange="loadRegisterPreset()">
                        <option value="">-- Select a register --</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="regAddress">Register Address (hex):</label>
                    <input type="text" id="regAddress" placeholder="0x3FF00054" value="0x3FF00054">
                </div>
                <div class="info-panel" style="margin-top: 10px;">
                    <div class="info-row">
                        <span class="info-label">Register Value:</span>
                        <span class="info-value" id="regValue">--</span>
                    </div>
                    <div class="info-row" id="regDescRow" style="display: none;">
                        <span class="info-label">Description:</span>
                        <span class="info-value" id="regDesc" style="font-family: inherit; font-size: 12px;">--</span>
                    </div>
                </div>
            </div>

            <!-- Flash Operations Section -->
            <div class="section">
                <h2>üíø Flash Operations</h2>
                <div class="button-group">
                    <button id="writeFlashBtn" onclick="writeFlash()" disabled title="Load stub loader first">Write
                        Flash</button>
                    <button id="readFlashBtn" onclick="readFlash()" disabled title="Load stub loader first">Read Flash &
                        Download</button>
                    <button id="md5FlashBtn" onclick="calculateMD5()" disabled title="Load stub loader first">Calculate
                        MD5</button>
                </div>
                <div class="input-group">
                    <label for="flashAddress">Flash Address (hex):</label>
                    <input type="text" id="flashAddress" placeholder="0x00000000" value="0x00000000">
                </div>
                <div class="input-group">
                    <label for="flashSize">Read Size (bytes, hex):</label>
                    <input type="text" id="flashSize" placeholder="0x00800000" value="0x00800000">
                </div>
                <div class="file-input-wrapper">
                    <input type="file" id="flashFile" accept=".bin" onchange="handleFileSelect(event)">
                    <label class="file-input-label" for="flashFile">üìÅ Choose Binary File</label>
                </div>
                <div class="file-info" id="fileInfo"></div>
                <div class="info-panel" style="margin-top: 10px;">
                    <div class="info-row" id="md5Row" style="display: none;">
                        <span class="info-label">MD5 Hash:</span>
                        <span class="info-value" id="md5Value"
                            style="font-family: 'Courier New', monospace; font-size: 13px;">--</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="flashProgress">0%</div>
                </div>
            </div>

            <!-- Testing Section -->
            <div class="section">
                <h2>üß™ Testing & Diagnostics</h2>
                <div class="button-group">
                    <button id="testReliabilityBtn" onclick="testReliability()" disabled>Test Reliability</button>
                    <button id="blankCheckBtn" onclick="blankCheck()" disabled
                        title="Load stub loader first (required for blank check)">Blank Check</button>
                    <button id="writeReadTestBtn" onclick="writeReadTest()" disabled
                        title="Load stub loader first">Write/Read Test</button>
                </div>
                <div class="input-group">
                    <label for="testAddress">Test Address (hex):</label>
                    <input type="text" id="testAddress" placeholder="0x00000000" value="0x00000000">
                </div>
                <div class="input-group">
                    <label for="testSize">Test Size (bytes, hex):</label>
                    <input type="text" id="testSize" placeholder="0x00800000" value="0x00800000">
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="testProgress">0%</div>
                </div>
                <div class="info-panel" style="margin-top: 10px;">
                    <div class="info-row">
                        <span class="info-label">Test Result:</span>
                        <span class="info-value" id="testResult">--</span>
                    </div>
                    <div class="info-row" id="testDetailsRow" style="display: none;">
                        <span class="info-label">Details:</span>
                        <span class="info-value" id="testDetails"
                            style="font-family: inherit; font-size: 12px;">--</span>
                    </div>
                </div>
            </div>

            <!-- Debug Section -->
            <div class="section">
                <h2>üêõ Debug</h2>
                <div class="button-group">
                    <button id="toggleDebugBtn" onclick="toggleDebugMode()">Toggle Debug Mode</button>
                    <button id="clearLogBtn" onclick="clearLog()">Clear Log</button>
                </div>
                <div class="log-container" id="logContainer">
                    <div class="log-entry log-info">Ready. Click 'Connect Device' to start.</div>
                </div>
            </div>
        </div>
    </div>

    <div id="devicePopup" class="device-popup"></div>

    <script>
/* Inlined from chips.js */

class ChipDescriptions {
    constructor() {
        this.chip_descriptions = {
            /*
                These are the flash stub loaders from esptool: 
                https://github.com/espressif/esptool/tree/master/esptool/targets/stub_flasher/1
                
                The binaries in JSON format distributed in this directory are released as Free Software under GNU General Public License Version 2 or later. 
            */
            "esp32": {
                "magic_value": 0x00F01D83,
                "mac_efuse_reg": 0x3FF5A004,
                "stub":
                {
                    "entry": 1074521712,
                    "text": "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",
                    "text_start": 1074520064,
                    "data": "DMD8P3HoC0AH6QtAke0LQKfpC0Aq6QtAp+kLQADqC0AH6wtAfesLQCLrC0Ad6AtAs+oLQPzqC0Ae6gtAnusLQEjqC0Ce6wtA/ugLQGDpC0Cn6QtAAOoLQBDpC0Bs7AtAVu0LQIjtC0By7QtAiO0LQIjtC0CI7QtAiO0LQIjtC0CI7QtAiO0LQIjtC0D/6wtAiO0LQIfsC0BW7QtA",
                    "data_start": 1073605548,
                    "bss_start": 1073528832
                }
            },
            "esp32s2": {
                "mac_efuse_reg": 0x3F41A044,
                "magic_value": 0x000007C6,
                "stub":
                {
                    "entry": 1073907892,
                    "text": "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",
                    "text_start": 1073905664,
                    "data": "WAD9P/KLAkCHjAJAK5ECQCeNAkCqjAJAJ40CQICNAkCDjgJA+Y4CQJ6OAkB9iwJAL44CQHiOAkCejQJAGo8CQMaNAkAajwJAfowCQOCMAkAnjQJAgI0CQJCMAkC+iwJA9I8CQOKQAkAikQJABpECQCKRAkAikQJAIpECQCKRAkAikQJAIpECQCKRAkAikQJAe48CQCKRAkAQkAJA4pACQA==",
                    "data_start": 1073622016,
                    "bss_start": 1073545216
                }
            },
            "esp32s3": {
                "mac_efuse_reg": 0x60007044,
                "magic_value": 0x00000009,
                "stub":
                {
                    "entry": 1077382292,
                    "text": "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",
                    "text_start": 1077379072,
                    "data": "WADKP2qQN0A/kTdA1ZU3QN+RN0BikTdA35E3QDiSN0A/kzdAtZM3QFqTN0D1jzdA55I3QDSTN0BWkjdA1pM3QH6SN0DWkzdANpE3QJiRN0DfkTdAOJI3QEiRN0A2kDdArJQ3QJqVN0DMlTdAtpU3QMyVN0DMlTdAzJU3QMyVN0DMlTdAzJU3QMyVN0DMlTdAM5Q3QMyVN0DIlDdAmpU3QAQInwAAAAAAAAAYAQQIBQAAAAAAAAAIAQQIBgAAAAAAAAAAAQQIIQAAAAAAIAAAEQQI3AAAAAAAIAAAEQQIDAAAAAAAIAAAAQQIEgAAAAAAIAAAESAoDAAQAQAA",
                    "data_start": 1070279676,
                    "bss_start": 1070202880
                }
            },
            "esp32c2": {
                "mac_efuse_reg": 0x60008840,
                "stub":
                {
                    "entry": 1077413350,
                    "text": "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",
                    "text_start": 1077411840,
                    "data": "DEDKP+IIOEBICThA3Ak4QLAKOEAYCzhAxgo4QNAHOEBsCjhArAo4QPgJOECABzhAIAo4QIAHOEDACDhACAk4QEgJOEDcCThA0gg4QP4HOEAyCDhAzgg4QAoNOEBICThA1As4QM4MOEBcBzhA8Aw4QFwHOEBcBzhAXAc4QFwHOEBcBzhAXAc4QFwHOEBcBzhAegs4QFwHOEDsCzhAzgw4QA==",
                    "data_start": 1070295980,
                    "bss_start": 1070219264
                }
            },
            "esp32c3": {
                "mac_efuse_reg": 0x60008844,
                "magic_value": [0x6921506F, 0x1B31506F, 0x4881606F, 0x4361606F],
                "stub":
                {
                    "entry": 1077413582,
                    "text": "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",
                    "text_start": 1077411840,
                    "data": "FEDIP5IKOED8CjhAjgs4QGIMOEDKDDhAeAw4QGwJOEAeDDhAXgw4QKoLOEAcCThA0gs4QBwJOEBwCjhAugo4QPwKOECOCzhAggo4QJQJOEDgCThAfgo4QMQOOED8CjhAhg04QIAOOEDaCDhApg44QNoIOEDaCDhA2gg4QNoIOEDaCDhA2gg4QNoIOEDaCDhALA04QNoIOECeDThAgA44QA==",
                    "data_start": 1070164916,
                    "bss_start": 1070088192
                }
            },
            "esp32c5": {
                "mac_efuse_reg": 0x600B4844,
                "stub":
                {
                    "entry": 1082133122,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "FACEQOYOgEBQD4BA5A+AQLgQgEAgEYBAzhCAQEANgEB0EIBAtBCAQAAQgEDwDIBAKBCAQPAMgEDCDoBADg+AQFAPgEDkD4BA1A6AQGgNgECWDYBA0A6AQBoTgEBQD4BA3BGAQNYSgECqDIBA/BKAQKoMgECqDIBAqgyAQKoMgECqDIBAqgyAQKoMgECqDIBAghGAQKoMgED0EYBA1hKAQA==",
                    "data_start": 1082469300,
                    "bss_start": 1082392576
                }
            },
            "esp32c6": {
                "mac_efuse_reg": 0x600B0844,
                "magic_value": 0x2CE0806F,
                "stub":
                {
                    "entry": 1082132158,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "EACEQD4KgECoCoBANguAQAoMgEByDIBAIAyAQDAJgEDGC4BABgyAQFILgEDgCIBAeguAQOAIgEAcCoBAZgqAQKgKgEA2C4BALgqAQFgJgECMCYBAKgqAQGwOgECoCoBALg2AQCgOgECeCIBATg6AQJ4IgECeCIBAngiAQJ4IgECeCIBAngiAQJ4IgECeCIBA1AyAQJ4IgEBGDYBAKA6AQA==",
                    "data_start": 1082469296,
                    "bss_start": 1082392576
                }
            },
            "esp32c61": {
                "mac_efuse_reg": 0x600B4844,
                "stub":
                {
                    "entry": 1082132158,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "EECAQEIKgECsCoBAOguAQA4MgEB2DIBAJAyAQDQJgEDKC4BACgyAQFYLgEDkCIBAfguAQOQIgEAgCoBAagqAQKwKgEA6C4BAMgqAQFwJgECQCYBALgqAQHAOgECsCoBAMg2AQCwOgECiCIBAUg6AQKIIgECiCIBAogiAQKIIgECiCIBAogiAQKIIgECiCIBA2AyAQKIIgEBKDYBALA6AQA==",
                    "data_start": 1082223536,
                    "bss_start": 1082146816
                }
            },
            "esp32h2": {
                "stub":
                {
                    "entry": 1082132158,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "EACDQD4KgECoCoBANguAQAoMgEByDIBAIAyAQDAJgEDGC4BABgyAQFILgEDgCIBAeguAQOAIgEAcCoBAZgqAQKgKgEA2C4BALgqAQFgJgECMCYBAKgqAQGwOgECoCoBALg2AQCgOgECeCIBATg6AQJ4IgECeCIBAngiAQJ4IgECeCIBAngiAQJ4IgECeCIBA1AyAQJ4IgEBGDYBAKA6AQA==",
                    "data_start": 1082403760,
                    "bss_start": 1082327040
                }
            },
            "esp32p4": {
                "mac_efuse_reg": 0x5012D044,
                "stub":
                {
                    "entry": 1341459336,
                    "text": "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",
                    "text_start": 1341456384,
                    "data": "XAD2T8gQ9U8yEfVPzhH1T6oS9U8SE/VPwBL1TwAP9U9mEvVPphL1T+oR9U+wDvVPEhL1T7AO9U+kEPVP8BD1TzIR9U/OEfVPthD1TyoP9U9eD/VPshD1TwwV9U8yEfVP1hP1T9AU9U/SDfVP8hT1T9IN9U/SDfVP0g31T9IN9U/SDfVP0g31T9IN9U/SDfVPdBP1T9IN9U/uE/VP0BT1Tw==",
                    "data_start": 1341598716,
                    "bss_start": 1341521920
                }
            },
            "esp32p4rc1": {
                "mac_efuse_reg": 0x5012D044,
                "stub":
                {
                    "entry": 1341197206,
                    "text": "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",
                    "text_start": 1341194240,
                    "data": "XAD1T6wQ8U8WEfFPshHxT44S8U/2EvFPpBLxTwQP8U9KEvFPihLxT84R8U+0DvFP9hHxT7QO8U+IEPFP1BDxTxYR8U+yEfFPmhDxTy4P8U9iD/FPlhDxT/AU8U8WEfFPuhPxT7QU8U/WDfFP1hTxT9YN8U/WDfFP1g3xT9YN8U/WDfFP1g3xT9YN8U/WDfFPWBPxT9YN8U/SE/FPtBTxTw==",
                    "data_start": 1341533180,
                    "bss_start": 1341456384
                }
            }
        }
    }
};

/* CommonJS export for Node.js */
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ChipDescriptions;
}

/* For browser environments, ChipDescriptions is already available globally from this script */


    </script>
    <script>
/* Inlined from flasher.js */
/**
 * ESP32 Bootloader Command Codes
 * Commands for communication with ESP32 ROM bootloader and stub loader
 */
const FLASH_BEGIN = 0x02;
const FLASH_DATA = 0x03;
const FLASH_END = 0x04;
const MEM_BEGIN = 0x05;
const MEM_END = 0x06;
const MEM_DATA = 0x07;
const SYNC = 0x08;
const WRITE_REG = 0x09;
const READ_REG = 0x0a;
const SPI_SET_PARAMS = 0x0b;
const SPI_ATTACH = 0x0d;
const CHANGE_BAUDRATE = 0x0f;
const FLASH_DEFL_BEGIN = 0x10;
const FLASH_DEFL_DATA = 0x11;
const FLASH_DEFL_END = 0x12;
const SPI_FLASH_MD5 = 0x13;
const GET_SECURITY_INFO = 0x14;
const ERASE_FLASH = 0xd0;
const ERASE_REGION = 0xd1;
const READ_FLASH = 0xd2;
const RUN_USER_CODE = 0xd3;

/**
 * IMPORTANT: For browser usage, chips.js must be loaded BEFORE flasher.js
 * 
 * This will make ChipDescriptions available globally for flasher.js to use.
 * For Node.js, flasher.js will automatically require('./chips.js')
 */

/* Resolve ChipDescriptions for both browser and Node environments */
const ChipDescriptionsClass = typeof ChipDescriptions !== 'undefined'
    ? ChipDescriptions
    : (typeof require !== 'undefined' ? require('./chips.js') : null);

/* ESP32 Reset Reason Codes (from ESP-IDF esp_system.h) */
const RESET_REASON_MAP = {
    0: { name: 'NO_MEAN', desc: 'No reset reason' },
    1: { name: 'POWERON_RESET', desc: 'Vbat power on reset' },
    3: { name: 'RTC_SW_SYS_RESET', desc: 'Software reset digital core' },
    5: { name: 'DEEPSLEEP_RESET', desc: 'Deep Sleep reset digital core' },
    7: { name: 'TG0WDT_SYS_RESET', desc: 'Timer Group0 Watch dog reset digital core' },
    8: { name: 'TG1WDT_SYS_RESET', desc: 'Timer Group1 Watch dog reset digital core' },
    9: { name: 'RTCWDT_SYS_RESET', desc: 'RTC Watch dog Reset digital core' },
    10: { name: 'INTRUSION_RESET', desc: 'Intrusion tested to reset CPU' },
    11: { name: 'TG0WDT_CPU_RESET', desc: 'Timer Group0 reset CPU' },
    12: { name: 'RTC_SW_CPU_RESET', desc: 'Software reset CPU' },
    13: { name: 'RTCWDT_CPU_RESET', desc: 'RTC Watch dog Reset CPU' },
    15: { name: 'RTCWDT_BROWN_OUT_RESET', desc: 'Reset when the vdd voltage is not stable' },
    16: { name: 'RTCWDT_RTC_RESET', desc: 'RTC Watch dog reset digital core and rtc module' },
    17: { name: 'TG1WDT_CPU_RESET', desc: 'Timer Group1 reset CPU' },
    18: { name: 'SUPER_WDT_RESET', desc: 'Super watchdog reset digital core and rtc module' },
    19: { name: 'GLITCH_RTC_RESET', desc: 'Glitch reset digital core and rtc module' },
    20: { name: 'EFUSE_RESET', desc: 'eFuse reset digital core' },
    21: { name: 'USB_UART_CHIP_RESET', desc: 'USB UART reset digital core' },
    22: { name: 'USB_JTAG_CHIP_RESET', desc: 'USB JTAG reset digital core' },
    23: { name: 'POWER_GLITCH_RESET', desc: 'Power glitch reset digital core and rtc module' }
};

const CHIP_ID_MAP = {
    0x0000: 'esp32',
    0x0002: 'esp32s2',
    0x0005: 'esp32c3',
    0x0009: 'esp32s3',
    0x000C: 'esp32c2',
    0x000D: 'esp32c6',
    0x0010: 'esp32h2',
    0x0012: 'esp32p4',
    0x0017: 'esp32c5',
    0x0014: 'esp32c61',
    0x0019: 'esp32h21',
    0x001C: 'esp32h4',
    0x0020: 'esp32s31',
    0xFFFF: 'Invalid'
};

/**
 * SLIP Protocol Layer Handler
 * Implements Serial Line IP (RFC 1055) encoding/decoding for packet framing
 */
class SlipLayer {
    /**
     * Initialize SLIP layer with empty buffer
     */
    constructor() {
        this.buffer = [];
        this.escaping = false;
        this.verbose = true;
        this.logPackets = false;
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    /**
     * Log SLIP layer data with color coding
     * @param {Uint8Array} data - Data to log
     * @param {string} type - 'ENCODE' or 'DECODE'
     * @param {string} label - Description label
     */
    logSlipData(data, type, label) {
        if (!this.verbose) return;

        this._preSyncState = 'idle';
        const isEncode = type === 'ENCODE'; const color = isEncode ? 'color: #FFC107; font-weight: bold' : 'color: #9C27B0; font-weight: bold';

        const bgColor = isEncode ? 'background: #F57F17; color: #000' : 'background: #6A1B9A; color: #fff';
        const symbol = isEncode ? '‚ñ∂' : '‚óÄ';

        const maxBytes = 128;
        const bytesToShow = Math.min(data.length, maxBytes);
        const truncated = data.length > maxBytes;

        let hexStr = '';
        let asciiStr = '';
        let lines = [];

        for (let i = 0; i < bytesToShow; i++) {
            const byte = data[i];
            hexStr += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
            asciiStr += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';

            if ((i + 1) % 16 === 0 || i === bytesToShow - 1) {
                const hexPadding = ' '.repeat(Math.max(0, (16 - ((i % 16) + 1)) * 3));
                lines.push(`    ${hexStr}${hexPadding} | ${asciiStr}`);
                hexStr = '';
                asciiStr = '';
            }
        }

        if (this.logPackets) {
            const truncMsg = truncated ? ` (showing ${bytesToShow}/${data.length} bytes)` : '';
            this.logDebug(`${symbol} SLIP ${type} ${label} [${data.length} bytes]${truncMsg}`);
            lines.forEach(line => this.logDebug(line));
        }
    }

    /**
     * Encode data using SLIP framing
     * Wraps packet with SLIP_END delimiters and escapes special bytes
     * @param {Uint8Array} packet - Raw packet data
     * @returns {Uint8Array} SLIP-framed packet with delimiters
     */
    encode(packet) {
        const SLIP_END = 0xC0;
        const SLIP_ESC = 0xDB;
        const SLIP_ESC_END = 0xDC;
        const SLIP_ESC_ESC = 0xDD;

        if (this.logPackets) {
            this.logSlipData(packet, 'ENCODE', 'Payload before framing');
        }

        let slipFrame = [SLIP_END];

        for (let byte of packet) {
            if (byte === SLIP_END) {
                slipFrame.push(SLIP_ESC, SLIP_ESC_END);
            } else if (byte === SLIP_ESC) {
                slipFrame.push(SLIP_ESC, SLIP_ESC_ESC);
            } else {
                slipFrame.push(byte);
            }
        }

        slipFrame.push(SLIP_END);
        const result = new Uint8Array(slipFrame);

        return result;
    }

    /**
     * Decode SLIP-framed packet stream
     * Extracts complete packets from framed data, handling escape sequences
     * @param {Uint8Array|ArrayLike} value - SLIP-encoded bytes
     * @returns {Uint8Array[]} Array of decoded complete packets
     */
    decode(value) {
        const SLIP_END = 0xC0;
        const SLIP_ESC = 0xDB;
        const SLIP_ESC_END = 0xDC;
        const SLIP_ESC_ESC = 0xDD;

        let outputPackets = [];

        for (let byte of value) {
            if (byte === SLIP_END) {
                if (this.buffer.length > 0) {
                    const packet = new Uint8Array(this.buffer);
                    outputPackets.push(packet);
                    this.buffer = [];
                }
            } else if (this.escaping) {
                if (byte === SLIP_ESC_END) {
                    this.buffer.push(0xC0);
                } else if (byte === SLIP_ESC_ESC) {
                    this.buffer.push(0xDB);
                }
                this.escaping = false;
            } else if (byte === SLIP_ESC) {
                this.escaping = true;
            } else {
                this.buffer.push(byte);
            }
        }

        if (this.logPackets) {
            // Log decoded packets
            for (let i = 0; i < outputPackets.length; i++) {
                const label = outputPackets.length > 1 ? `Decoded packet ${i + 1}/${outputPackets.length}` : 'Decoded packet';
                this.logSlipData(outputPackets[i], 'DECODE', label);
            }
        }

        return outputPackets;
    }
}

/**
 * WebUSBSerial - Web Serial API-like wrapper for WebUSB
 * Provides a familiar interface for serial communication over USB
 */
class WebUSBSerial {
    constructor() {
        this.device = null;
        this.interfaceNumber = null;
        this.endpointIn = null;
        this.endpointOut = null;
        this.controlInterface = null;
        this.readableStream = null;
        this.writableStream = null;
        this._reader = null;
        this._writer = null;
        this._readLoopRunning = false;
        this._usbDisconnectHandler = null;
        this._eventListeners = {
            'close': [],
            'disconnect': []
        };
        this.logger = null; /* optional {info, error} callbacks for UI logging */
        this.maxTransferSize = 0x10000;
    }

    /**
     * Request USB device (mimics navigator.serial.requestPort())
     * @returns {Promise<WebUSBSerial>} This instance
     */
    static async requestPort() {
        const filters = [
            { vendorId: 0x303A }, // Espressif
            { vendorId: 0x0403 }, // FTDI
            { vendorId: 0x1A86 }, // CH340
            { vendorId: 0x10C4 }, // CP210x
            { vendorId: 0x067B }  // PL2303
        ];

        const device = await navigator.usb.requestDevice({ filters });
        const port = new WebUSBSerial();
        port.device = device;
        return port;
    }

    /**
     * Open the USB device (mimics port.open())
     * @param {Object} options - {baudRate: number}
     * @returns {Promise<void>}
     */
    async open(options = {}) {
        if (!this.device) {
            throw new Error('No device selected');
        }

        /* If already open (e.g., prior attempt), close to avoid stale claims */
        if (this.device.opened) {
            try { await this.device.close(); } catch (e) { }
        }

        /* Best-effort reset before attempting to open (helps if host kept a stale claim) */
        try { if (this.device.reset) { await this.device.reset(); } } catch (e) { }

        const attemptOpenAndClaim = async () => {
            await this.device.open();
            try {
                /* Ensure configuration 1 is selected; some hosts keep a different active config */
                const currentCfg = this.device.configuration ? this.device.configuration.configurationValue : null;
                if (!currentCfg || currentCfg !== 1) {
                    await this.device.selectConfiguration(1);
                }
            } catch (e) { /* ignore config select errors */ }

            const config = this.device.configuration;

            /* Try to claim CDC control interface FIRST on Android/CH34x to unblock data iface claim */
            const preControlIface = config.interfaces.find(i => i.alternates && i.alternates[0] && i.alternates[0].interfaceClass === 0x02);
            if (preControlIface) {
                try {
                    await this.device.claimInterface(preControlIface.interfaceNumber);
                    /* Ensure alt setting 0 is active */
                    try { await this.device.selectAlternateInterface(preControlIface.interfaceNumber, 0); } catch (e) { }
                    this.controlInterface = preControlIface.interfaceNumber;
                    this.logMessage(`[WebUSB] Pre-claimed CDC control iface ${preControlIface.interfaceNumber}`);
                } catch (e) {
                    this.logError(`[WebUSB] Could not pre-claim CDC control iface ${preControlIface.interfaceNumber}: ${e && e.message ? e.message : e}`);
                }
            }

            /* Collect all bulk IN/OUT interfaces and try preferred ones first (CDC > vendor > other)
               Rationale: Espressif composite devices expose CDC data on iface 1 (class 0x0A) and JTAG/debug on vendor iface 2.
               Selecting CDC first avoids landing on a non-UART function that won't speak the ROM bootloader. */
            const candidates = [];
            for (const iface of config.interfaces) {
                const alt = iface.alternates[0];
                let hasIn = false, hasOut = false;
                for (const ep of alt.endpoints) {
                    if (ep.type === 'bulk' && ep.direction === 'in') hasIn = true;
                    if (ep.type === 'bulk' && ep.direction === 'out') hasOut = true;
                }
                if (hasIn && hasOut) {
                    let score = 2; /* default */
                    if (alt.interfaceClass === 0x0a) score = 0; /* CDC data first */
                    else if (alt.interfaceClass === 0xff) score = 1; /* vendor-specific next */
                    candidates.push({ iface, score });
                }
            }

            if (!candidates.length) {
                await this._dumpDeviceDetails('No suitable USB interface found');
                throw new Error('No suitable USB interface found');
            }

            candidates.sort((a, b) => a.score - b.score);
            let lastErr = null;
            for (const cand of candidates) {
                try {
                    /* Ensure alt setting 0 before claiming */
                    try { await this.device.selectAlternateInterface(cand.iface.interfaceNumber, 0); } catch (e) { }
                    await this.device.claimInterface(cand.iface.interfaceNumber);
                    this.interfaceNumber = cand.iface.interfaceNumber;

                    /* Get endpoints */
                    const alt = cand.iface.alternates[0];
                    for (const ep of alt.endpoints) {
                        if (ep.type === 'bulk' && ep.direction === 'in') {
                            this.endpointIn = ep.endpointNumber;
                        } else if (ep.type === 'bulk' && ep.direction === 'out') {
                            this.endpointOut = ep.endpointNumber;
                        }
                    }
                    /* Adopt endpoint packet size as transfer length (Android prefers max-packet) */
                    try {
                        const inEp = alt.endpoints.find(ep => ep.type === 'bulk' && ep.direction === 'in');
                        if (inEp && inEp.packetSize) {
                            this.maxTransferSize = Math.min(inEp.packetSize, 64);
                        }
                    } catch (e) { }
                    this.logMessage(`[WebUSB] Claimed iface ${cand.iface.interfaceNumber} (class=${alt.interfaceClass}) with IN=${this.endpointIn} OUT=${this.endpointOut}`);
                    return config;
                } catch (claimErr) {
                    lastErr = claimErr;
                    this.logError(`[WebUSB] claim failed on iface ${cand.iface.interfaceNumber} (class=${cand.iface.alternates[0].interfaceClass}): ${claimErr && claimErr.message ? claimErr.message : claimErr}`);
                }
            }

            await this._dumpDeviceDetails('All candidate interfaces failed to claim', lastErr);
            this.logMessage('[WebUSB] If you are on Windows and see repeat claim failures, ensure the interface is bound to WinUSB (e.g., via Zadig) and close any app using it.');
            throw lastErr || new Error('Unable to claim any USB interface');
        };

        let config;
        try {
            config = await attemptOpenAndClaim();
        } catch (err) {
            console.warn('[WebUSBSerial-flasher] open/claim failed:', err.message);
            await this._dumpDeviceDetails('open/claim failed (first attempt)', err);
            /* Retry once after a best-effort device reset/close to clear stale claims (common on Android) */
            console.warn('[WebUSBSerial-flasher] claimInterface failed, retrying after reset/close:', err.message);
            try { if (this.device.reset) { await this.device.reset(); } } catch (e) { }
            try { await this.device.close(); } catch (e) { }
            try {
                config = await attemptOpenAndClaim();
            } catch (err2) {
                await this._dumpDeviceDetails('claimInterface failed (retry)', err2);
                throw new Error(`Unable to claim USB interface. This can happen if another app has the device open or Android retained a stale claim. Unplug/replug the device, close other apps, and retry. Original: ${err2.message}`);
            }
        }

        /* Control iface may already be claimed in attemptOpenAndClaim; avoid double-claim */
        if (this.controlInterface == null) {
            const controlIface = config.interfaces.find(i =>
                i.alternates[0].interfaceClass === 0x02 &&
                i.interfaceNumber !== this.interfaceNumber
            );

            if (controlIface) {
                try {
                    await this.device.claimInterface(controlIface.interfaceNumber);
                    try { await this.device.selectAlternateInterface(controlIface.interfaceNumber, 0); } catch (e) { }
                    this.controlInterface = controlIface.interfaceNumber;
                } catch (e) {
                    /* Use data interface for control if claim fails */
                    this.controlInterface = this.interfaceNumber;
                }
            } else {
                this.controlInterface = this.interfaceNumber;
            }
        }

        // Set line coding
        const baudRate = options.baudRate || 115200;
        try {
            const lineCoding = new Uint8Array([
                baudRate & 0xFF,
                (baudRate >> 8) & 0xFF,
                (baudRate >> 16) & 0xFF,
                (baudRate >> 24) & 0xFF,
                0x00, // 1 stop bit
                0x00, // No parity
                0x08  // 8 data bits
            ]);

            await this.device.controlTransferOut({
                requestType: 'class',
                recipient: 'interface',
                request: 0x20, // SET_LINE_CODING
                value: 0,
                index: this.controlInterface
            }, lineCoding);
        } catch (e) {
            console.warn('Could not set line coding:', e.message);
        }

        // Assert DTR/RTS
        try {
            await this.device.controlTransferOut({
                requestType: 'class',
                recipient: 'interface',
                request: 0x22, // SET_CONTROL_LINE_STATE
                value: 0x03, // DTR=1, RTS=1
                index: this.controlInterface
            });
        } catch (e) {
            console.warn('Could not set control lines:', e.message);
        }

        // Create streams
        this._createStreams();

        // Setup disconnect handler
        this.logDebug('[WebUSBSerial-flasher] Setting up USB disconnect handler');
        this._usbDisconnectHandler = (event) => {
            this.logDebug('[WebUSBSerial-flasher] USB disconnect event fired, device:', event.device.productId);
            if (event.device === this.device) {
                this.logDebug('[WebUSBSerial-flasher] Device matches, firing close event');
                // Fire 'close' event to mimic Web Serial behavior
                this._fireEvent('close');
                this._cleanup();
            } else {
                this.logDebug('[WebUSBSerial-flasher] Device mismatch - different device disconnected');
            }
        };
        navigator.usb.addEventListener('disconnect', this._usbDisconnectHandler);
        this.logDebug('[WebUSBSerial-flasher] Disconnect handler registered with navigator.usb');
    }

    /**
     * Close the device (mimics port.close())
     * @returns {Promise<void>}
     */
    async close() {
        this._cleanup();
        if (this.device) {
            try {
                if (this.interfaceNumber !== null) {
                    await this.device.releaseInterface(this.interfaceNumber);
                }
                if (this.controlInterface !== null && this.controlInterface !== this.interfaceNumber) {
                    await this.device.releaseInterface(this.controlInterface);
                }
                await this.device.close();
            } catch (e) {
                // Ignore errors if device already disconnected
                if (!e.message || !e.message.includes('disconnected')) {
                    console.warn('Error closing device:', e.message || e);
                }
            }
            this.device = null;
        }
    }

    /* Dump detailed device info for diagnostics */
    async _dumpDeviceDetails(label, err) {
        try {
            if (!this.device) {
                this.logMessage(`[WebUSB] ${label}: no device set`);
                return;
            }
            const d = this.device;
            const lines = [];
            lines.push(`[WebUSB] ${label}: ${err && err.message ? err.message : err || ''}`);
            lines.push(`[WebUSB] Basic: opened=${d.opened} vid=0x${(d.vendorId || 0).toString(16).padStart(4, '0')} pid=0x${(d.productId || 0).toString(16).padStart(4, '0')}`);
            lines.push(`[WebUSB] Strings: product="${d.productName || 'n/a'}" manufacturer="${d.manufacturerName || 'n/a'}" serial="${d.serialNumber || 'n/a'}"`);
            const cfg = d.configuration;
            if (!cfg) {
                lines.push('[WebUSB] No active configuration');
                this.logMessage(lines.join('\n'));
                return;
            }
            lines.push(`[WebUSB] Active config: value=${cfg.configurationValue} interfaces=${cfg.interfaces.length}`);
            for (const iface of cfg.interfaces) {
                const alt = iface.alternates[0];
                lines.push(`[WebUSB]  iface ${iface.interfaceNumber}: class=${alt.interfaceClass} subclass=${alt.interfaceSubclass} proto=${alt.interfaceProtocol} eps=${alt.endpoints.length}`);
                for (const ep of alt.endpoints) {
                    lines.push(`[WebUSB]    ep ${ep.endpointNumber}: dir=${ep.direction} type=${ep.type} packetSize=${ep.packetSize}`);
                }
            }
            this.logMessage(lines.join('\n'));
        } catch (dumpErr) {
            this.logError(`[WebUSB] Failed to dump device details: ${dumpErr && dumpErr.message ? dumpErr.message : dumpErr}`);
        }
    }

    /**
     * Get device info (mimics port.getInfo())
     * @returns {Object} {usbVendorId, usbProductId}
     */
    getInfo() {
        if (!this.device) {
            return {};
        }
        return {
            usbVendorId: this.device.vendorId,
            usbProductId: this.device.productId
        };
    }

    /**
     * Set DTR/RTS signals (mimics port.setSignals())
     * @param {Object} signals - {dataTerminalReady, requestToSend}
     * @returns {Promise<void>}
     */
    async setSignals(signals) {
        if (!this.device) {
            throw new Error('Device not open');
        }

        var value = 0;
        value |= signals.dataTerminalReady ? 1 : 0;
        value |= signals.requestToSend ? 2 : 0;

        return this.device.controlTransferOut({
            requestType: 'class',
            recipient: 'interface',
            request: 0x22, /* CDC_SET_CONTROL_LINE_STATE */
            value: value,
            index: this.controlInterface
        });
    }

    /**
     * Get readable stream
     */
    get readable() {
        return this.readableStream;
    }

    /**
     * Get writable stream
     */
    get writable() {
        return this.writableStream;
    }

    /**
     * Create ReadableStream and WritableStream
     * @private
     */
    _createStreams() {
        // ReadableStream for incoming data
        this.readableStream = new ReadableStream({
            start: async (controller) => {
                this._readLoopRunning = true;

                try {
                    while (this._readLoopRunning && this.device) {
                        try {
                            /* Request one max-packet worth; large sizes can stall on some Android stacks */
                            const result = await this.device.transferIn(this.endpointIn, this.maxTransferSize);

                            if (result.status === 'ok') {
                                controller.enqueue(new Uint8Array(result.data.buffer, result.data.byteOffset, result.data.byteLength));
                                continue;
                            } else if (result.status === 'stall') {
                                await this.device.clearHalt('in', this.endpointIn);
                                await new Promise(r => setTimeout(r, 1));
                                continue;
                            } else {
                                console.warn('USB transferIn returned status:', result.status);
                            }
                            /* No data or zero-length transfer: immediately loop */
                            await new Promise(r => setTimeout(r, 1));
                        } catch (error) {
                            if (error.message && (error.message.includes('device unavailable') ||
                                error.message.includes('device has been lost') ||
                                error.message.includes('device was disconnected') ||
                                error.message.includes('No device selected'))) {
                                break;
                            }
                            if (error.message && (error.message.includes('transfer was cancelled') ||
                                error.message.includes('transfer error has occurred'))) {
                                continue;
                            }
                            /* Log other errors but continue */
                            console.warn('USB read error:', error.message);
                        }
                    }
                } catch (error) {
                    controller.error(error);
                } finally {
                    controller.close();
                }
            },
            cancel: () => {
                console.log('[WebUSBSerial-flasher] Read loop canceled');
                this._readLoopRunning = false;
            }
        });

        // WritableStream for outgoing data
        this.writableStream = new WritableStream({
            write: async (chunk) => {
                if (!this.device) {
                    throw new Error('Device not open');
                }
                await this.device.transferOut(this.endpointOut, chunk);
            }
        });
    }

    /**
     * Cleanup resources
     * @private
     */
    _cleanup() {
        console.log('[WebUSBSerial-flasher] Cleanup called');
        this._readLoopRunning = false;
        if (this._usbDisconnectHandler) {
            navigator.usb.removeEventListener('disconnect', this._usbDisconnectHandler);
            this._usbDisconnectHandler = null;
            console.log('[WebUSBSerial-flasher] Disconnect handler unregistered');
        }
    }

    /**
     * Fire event to all registered listeners
     * @private
     */
    _fireEvent(type) {
        const listeners = this._eventListeners[type] || [];
        console.log(`[WebUSBSerial-flasher] Firing '${type}' event to ${listeners.length} listener(s)`);
        listeners.forEach(listener => {
            try {
                listener();
            } catch (e) {
                console.error(`Error in ${type} event listener:`, e);
            }
        });
    }

    /**
     * Add event listener (mimics addEventListener for 'close' and 'disconnect')
     * @param {string} type - Event type
     * @param {Function} listener - Event handler
     */
    addEventListener(type, listener) {
        if (this._eventListeners[type]) {
            this._eventListeners[type].push(listener);
            console.log(`[WebUSBSerial-flasher] addEventListener('${type}') - now have ${this._eventListeners[type].length} listener(s)`);
        } else {
            console.log(`[WebUSBSerial-flasher] addEventListener('${type}') - unknown event type`);
        }
    }

    /**
     * Remove event listener
     * @param {string} type - Event type
     * @param {Function} listener - Event handler
     */
    removeEventListener(type, listener) {
        if (this._eventListeners[type]) {
            const index = this._eventListeners[type].indexOf(listener);
            if (index !== -1) {
                this._eventListeners[type].splice(index, 1);
            }
        }
    }
}

/**
 * ESP32 Bootloader Communication Handler
 * Manages serial communication with ESP32 devices using bootloader protocol
 * Supports reading/writing flash, downloading code to RAM, and firmware verification
 * @class ESPFlasher
 */
class ESPFlasher {

    /**
     * Initialize ESP32 flasher instance
     * Creates new instance with default configuration and empty state
     */
    constructor(options = {}) {
        this.devMode = options.devMode || false;
        this.logDebug = options.logDebug || ((msg) => { });
        this.logError = options.logError || ((msg) => { });
        this.logWarning = options.logWarning || ((msg) => { });
        this.logMessage = options.logMessage || ((msg) => { });
        this.logPackets = options.logPackets || false;

        /*
        Technical Limitation:
            Web Serial cannot change the baud rate without reopening the port, which may reset the device.
            Therefore, this tool keeps a single baud rate from start to end.
            ESP32 ROM prints its reset messages at 115200 baud.
            
            When using a USB-UART adapter with RX/TX wiring:
            - Use 115200 to see ROM reset messages (slower link), or
            - Use a higher baud (e.g., 921600) for speed but you will not see reset messages.

            This does not apply to native USB/JTAG interfaces of course.

            Normal ESP32 needs 115200 or 250000 for any operation.
        */
        this.initialBaudRate = options.initialBaudRate || 921600;



        this.chip_magic_addr = 0x40001000;
        this.chip_descriptions = new ChipDescriptionsClass().chip_descriptions;
        this.port = null;
        this.currentAddress = 0x0000;
        this.current_chip = "none";
        this.stubLoaded = false;
        this.responseHandlers = new Map();
        this.buffer = [];
        this.escaping = false;
        this.slipLayer = new SlipLayer();
        this.synced = false;
        this.consoleBuffer = '';
        this._preSyncState = 'idle';
        this.reader = null;
        this.dtrState = true;
        this.rtsState = true;

        /* Command execution lock to prevent concurrent command execution */
        this._commandLock = Promise.resolve();

        /* Persistent writer + queued writes to avoid WritableStream lock contention */
        this._activeWriter = null;
        this._writeChain = Promise.resolve();
    }

    /**
     * Ensure a single persistent WritableStreamDefaultWriter exists
     * @private
     */
    async _ensureWriter() {
        if (!this.port || !this.port.writable) {
            throw new Error('Port is not writable.');
        }
        if (!this._activeWriter) {
            this._activeWriter = this.port.writable.getWriter();
        }
        return this._activeWriter;
    }

    /**
     * Queue a write on the persistent writer to serialize all writes
     * @private
     */
    async _writeFrame(frame) {
        this._writeChain = this._writeChain.then(async () => {
            const writer = await this._ensureWriter();
            this.logSerialData(frame, true);
            await writer.write(frame);
        });
        return this._writeChain;
    }

    /**
     * Release the persistent writer if held
     * @private
     */
    _releaseWriter() {
        if (this._activeWriter) {
            try { this._activeWriter.releaseLock(); } catch (e) { }
            this._activeWriter = null;
        }
    }

    /**
     * Format bytes as colored hex dump for console
     * @param {Uint8Array} data - Data to format
     * @param {string} isTx - 'TX' or 'RX'
     * @param {number} maxBytes - Maximum bytes to show (default: 256)
     */
    logSerialData(data, isTx, maxBytes = 256) {
        if (!this.logPackets) return;

        const arrow = isTx ? '‚Üí' : '‚Üê';

        const bytesToShow = Math.min(data.length, maxBytes);
        const truncated = data.length > maxBytes;

        // Format hex string with spaces every 2 bytes and newline every 16 bytes
        let hexStr = '';
        let asciiStr = '';
        let lines = [];

        for (let i = 0; i < bytesToShow; i++) {
            const byte = data[i];
            hexStr += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
            asciiStr += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';

            if ((i + 1) % 16 === 0 || i === bytesToShow - 1) {
                // Pad hex string to align ASCII
                const hexPadding = ' '.repeat(Math.max(0, (16 - ((i % 16) + 1)) * 3));
                lines.push(`  ${hexStr}${hexPadding} | ${asciiStr}`);
                hexStr = '';
                asciiStr = '';
            }
        }
        if (this.logPackets) {
            const truncMsg = truncated ? ` (showing ${bytesToShow}/${data.length} bytes)` : '';
            this.logDebug(`${arrow} ${isTx} [${data.length} bytes]${truncMsg}`);
            lines.forEach(line => this.logDebug(line));
        }
    }

    /**
     * Open serial port and start reading packets
     * @async
     * @returns {Promise<void>}
     * @throws {Error} If port request fails
     */
    async openPort() {
        /* Require Web Serial API (available in Chrome/Edge) */
        if (typeof navigator === 'undefined' || !navigator.serial) {
            throw new Error('Web Serial API not available. Please use Chrome or Edge.');
        }

        const port = await navigator.serial.requestPort();
        return this.openPortWithPort(port);
    }

    /**
     * Open a provided serial port (Web Serial or WebUSB)
     * @async
     * @param {SerialPort|WebUSBSerial} port - Port instance to open
     * @returns {Promise<void>}
     * @throws {Error} If connection fails
     */
    async openPortWithPort(port) {
        return new Promise(async (resolve, reject) => {

            /* Open the port */
            try {
                this.port = port;

                /* If WebUSBSerial, provide logger callbacks so low-level dumps reach UI log */
                if (this.port instanceof WebUSBSerial) {
                    this.port.logger = {
                        info: (msg) => { this.logDebug && this.logDebug(msg); },
                        error: (msg) => { this.logError && this.logError(msg); }
                    };
                }

                await this.port.open({ baudRate: this.initialBaudRate });

                /* Get and log VID/PID information */
                const portInfo = this.port.getInfo();
                if (portInfo.usbVendorId !== undefined && portInfo.usbProductId !== undefined) {
                    const vid = portInfo.usbVendorId;
                    const pid = portInfo.usbProductId;
                    this.logDebug(`Device: VID=0x${vid.toString(16).padStart(4, '0').toUpperCase()}, PID=0x${pid.toString(16).padStart(4, '0').toUpperCase()}`);

                    /* Check for Espressif USB JTAG device */
                    if (vid === 0x303A) {
                        this.logDebug('Detected Espressif USB JTAG device - high baud rates supported, bootloader messages will be visible');
                        this.isEspressifUsbJtag = true;
                    } else {
                        this.isEspressifUsbJtag = false;
                    }
                } else {
                    this.logDebug('Device: VID/PID information not available (may not be a USB device)');
                    this.isEspressifUsbJtag = false;
                }
            } catch (error) {
                reject(error);
                return;
            }


            // Register for device lost (Web Serial API)
            if (navigator.serial) {
                navigator.serial.addEventListener('disconnect', (event) => {
                    if (event.target === this.port) {
                        this.logError(`The device was disconnected`);
                        this.disconnect();
                    }
                });
            }

            // Register for port closing
            if (this.port.addEventListener) {
                this.port.addEventListener('close', () => {
                    if (!this._disconnecting) {
                        this.logError('Device disconnected unexpectedly');
                    }
                });
            }

            resolve();

            /* Set up reading from the port */
            this.reader = this.port.readable.getReader();

            this.startRxLoop();
        });
    }

    async startRxLoop() {
        try {
            while (true) {
                if (typeof performance !== 'undefined' && performance.mark && performance.measure) {
                    performance.mark('esp32_flasher_receive_start');
                }
                const { value, done } = await this.reader.read();
                if (typeof performance !== 'undefined' && performance.mark && performance.measure) {
                    performance.mark('esp32_flasher_receive_end');
                    try {
                        performance.measure('esp32_flasher_receive', 'esp32_flasher_receive_start', 'esp32_flasher_receive_end');
                    } catch (measureErr) {
                    }
                }
                if (done) {
                    this.logDebug('Reader has been canceled');
                    break;
                }
                if (value) {
                    this.logSerialData(value, false);
                    this.parseResetMessages(value);
                    const packets = this.slipLayer.decode(value);
                    for (let packet of packets) {
                        await this.processPacket(packet);
                    }
                }
            }
        } catch (err) {
            // Handle cancellation
        } finally {
            if (this.reader) {
                this.reader.releaseLock();
                this.reader = null;
            }
        }
    }

    /**
     * Reopen the existing serial port with a new baud rate
     * Closes the current reader and port, then opens the same port at `baudRate`
     * and restarts the RX loop without re-requesting the device.
     * @async
     * @param {number} baudRate - New baud rate to use
     * @returns {Promise<void>}
     * @throws {Error} If port is not selected/openable
     */
    async reopenPort(baudRate) {
        if (!this.port) {
            throw new Error('No port selected. Call openPort() first to choose a device.');
        }

        /* Stop existing reader if any */
        if (this.reader) {
            try {
                await this.reader.cancel();
            } catch (error) {
                /* Ignore cancellation errors */
            }
            try {
                this.reader.releaseLock();
            } catch (e) {
                /* Ignore release errors */
            }
            this.reader = null;
        }

        /* Wait for pending writes and release writer before closing */
        try {
            await this._writeChain;
        } catch (e) { /* Ignore pending write errors on reopen */ }
        this._releaseWriter();

        /* Close and reopen the same port with new baud */
        try {
            await this.port.close();
        } catch (error) {
            /* Ignore close errors, we will try to open regardless */
        }

        const newBaud = baudRate || this.initialBaudRate;
        this.initialBaudRate = newBaud;
        await this.port.open({ baudRate: newBaud });

        /* Restart RX loop (do not re-register global listeners to avoid duplicates) */
        this.reader = this.port.readable.getReader();

        this.startRxLoop();
    }

    parseResetMessages(data) {
        /*
        ESP32
            ets Jun  8 2016 00:22:57

            rst:0x1 (POWERON_RESET),boot:0x1 (DOWNLOAD_BOOT(UART0/UART1/SDIO_FEI_REO_V2))
            waiting for download
           
        ESP32-S3 (normal)     
            ESP-ROM:esp32s3-20210327
            Build:Mar 27 2021
            rst:0x1 (POWERON),boot:0x0 (DOWNLOAD(USB/UART0))
            waiting for download

        ESP32-C3 (secure)
            ESP-ROM:esp32c3-api1-20210207
            Build:Feb  7 2021
            rst:0x15 (USB_UART_CHIP_RESET),boot:0x5 (DOWNLOAD(USB/UART0/1))
            Saved PC:0x4004d1f8
            wait uart download(secure mode)

        ESP32-C3 (normal)
            ESP-ROM:esp32c3-api1-20210207
            Build:Feb  7 2021
            rst:0x15 (USB_UART_CHIP_RESET),boot:0x7 (DOWNLOAD(USB/UART0/1))
            Saved PC:0x4004c0d4
            waiting for download

        */


        /* Only care about pre-sync console chatter */
        if (!data || !data.length) {
            return;
        }

        /* Accumulate printable ASCII and newlines */
        let chunk = '';
        for (let i = 0; i < data.length; i++) {
            const b = data[i];
            if (b === 10 || b === 13) {
                chunk += '\n';
            } else if (b >= 32 && b <= 126) {
                chunk += String.fromCharCode(b);
            }
        }

        if (!chunk.length) {
            return;
        }

        this.consoleBuffer = (this.consoleBuffer || '') + chunk;

        let newlineIdx = this.consoleBuffer.indexOf('\n');
        while (newlineIdx !== -1) {
            const line = this.consoleBuffer.slice(0, newlineIdx).trim();
            this.consoleBuffer = this.consoleBuffer.slice(newlineIdx + 1);
            if (line.length) {
                // Only print device messages if not yet synced
                if (!this.synced) {
                    this.logDebug(`[Device] ${line}`);
                }

                const lower = line.toLowerCase();
                const rstBootMatch = line.match(/rst:0x([0-9a-f]+)/i);
                const bootMatch = line.match(/boot:0x([0-9a-f]+)/i);

                if (rstBootMatch && bootMatch) {
                    const rst = parseInt(rstBootMatch[1], 16);
                    const boot = parseInt(bootMatch[1], 16);
                    const rstInfo = RESET_REASON_MAP[rst] || { name: 'UNKNOWN', desc: `Unknown reset reason 0x${rst.toString(16)}` };
                    this.deviceStateCallback && this.deviceStateCallback('reboot', { rst, rstName: rstInfo.name, rstDesc: rstInfo.desc, boot });
                    /* Enable mode detection after reboot line */
                    this._preSyncState = 'seen_reboot';
                }

                /* State machine: after reboot line, accept one mode line */
                if (this._preSyncState === 'seen_reboot') {
                    if (lower.includes('(secure mode)')) {
                        this.deviceStateCallback && this.deviceStateCallback('secure');
                        this._preSyncState = 'idle';
                    } else if (lower.includes('waiting for download') || lower.includes('wait uart download')) {
                        this.deviceStateCallback && this.deviceStateCallback('download');
                        this._preSyncState = 'idle';
                    }
                }

            }
            newlineIdx = this.consoleBuffer.indexOf('\n');
        }
    }

    /**
     * Read 32-bit value from chip register
     * @async
     * @param {number} addr - Register address
     * @returns {Promise<number>} Register value
     */
    async readReg(addr) {
        return this.executeCommand(this.buildCommandPacketU32(READ_REG, addr),
            async (resolve, reject, responsePacket) => {
                if (responsePacket) {
                    resolve(responsePacket.value);
                } else {
                    reject('Failed to read register');
                }
            });
    }


    /**
     * Detect if stub loader is running on device
     * @async
     * @returns {Promise<boolean>} True if stub loader active, false if ROM bootloader
     * @throws {Error} If detection fails
     * @description Distinguishes stub loader from ROM bootloader by magic address response size
     */
    async isStubLoader() {
        return this.executeCommand(this.buildCommandPacketU32(READ_REG, this.chip_magic_addr),
            async (resolve, reject, responsePacket) => {
                if (responsePacket && responsePacket.data) {
                    if (responsePacket.data.length == 2) {
                        resolve(true);
                    }
                    if (responsePacket.data.length == 4) {
                        resolve(false);
                    }
                    reject('Unexpected length');
                } else {
                    reject('Failed to read register');
                }
            });
    }

    /**
     * Execute command on device
     * @async
     * @param {Object} packet - Command packet from buildCommandPacket
     * @param {Function} packetResponseCbr - Response handler(resolve, reject, responsePacket)
     * @param {Function} [rawDataCbr] - Raw data handler
     * @param {number} [timeout=500] - Timeout in milliseconds
     * @param {Function} [checkTimeoutCbr] - Optional timeout check returning boolean
     * @returns {Promise<*>} Result from callback
     * @throws {Error} On timeout or command failure
     */
    async executeCommand(packet, packetResponseCbr, rawDataCbr, timeout = 500, checkTimeoutCbr = null) {
        /*
         Serialize command execution properly:
         - Do NOT create the command promise before acquiring the logical lock.
           Creating it early can start the async work and contend for the writable stream.
         - Instead, chain the creation to the existing lock so only one writer is active.
        */
        const run = () => this._executeCommandUnlocked(packet, packetResponseCbr, rawDataCbr, timeout, checkTimeoutCbr);
        this._commandLock = this._commandLock.then(run, run);
        return this._commandLock;
    }

    /**
     * Internal command execution (unlocked)
     * @async
     * @private
     */
    async _executeCommandUnlocked(packet, packetResponseCbr, rawDataCbr, timeout = 500, checkTimeoutCbr = null) {
        if (!this.port || !this.port.writable) {
            throw new Error("Port is not writable.");
        }

        if (this.devMode) {
            this.dumpPacket(this.parsePacket(packet.payload));
        }

        return new Promise(async (resolve, reject) => {
            /* Set timeout handler */
            let timeoutHandle = null;

            const scheduleTimeout = () => {
                timeoutHandle = setTimeout(() => {
                    if (checkTimeoutCbr) {
                        if (checkTimeoutCbr()) {
                            safeReject(new Error(`Timeout in command ${packet.command}`));
                        } else {
                            scheduleTimeout();
                        }
                    } else {
                        safeReject(new Error(`Timeout after ${timeout} ms waiting for response to command ${packet.command}`));
                    }
                }, timeout);
            };

            const safeResolve = (value) => { clearTimeout(timeoutHandle); return resolve(value); };
            const safeReject = (err) => { clearTimeout(timeoutHandle); return reject(err); };


            /* Register response handlers */
            this.responseHandlers.clear();

            /* decide which callbacks to register */
            if (rawDataCbr) {
                /* this command seems to have have normal response then raw data */
                this.responseHandlers.set(packet.command, async (response) => {
                    if (packetResponseCbr) {
                        return packetResponseCbr(safeResolve, safeReject, response);
                    }
                });
                this.responseHandlers.set(-1, async (response) => {
                    return rawDataCbr(safeResolve, safeReject, response);
                });
            } else {
                /* only normal response */
                this.responseHandlers.set(packet.command, async (response) => {
                    if (packetResponseCbr) {
                        return packetResponseCbr(safeResolve, safeReject, response);
                    }
                });
            }

            /* Send the packet with proper error handling */
            try {
                scheduleTimeout();
                if (typeof performance !== 'undefined' && performance.mark) {
                    performance.mark('esp32_flasher_send_start');
                }

                await this._writeFrame(this.slipLayer.encode(packet.payload));

                if (typeof performance !== 'undefined' && performance.mark && performance.measure) {
                    performance.mark('esp32_flasher_send_end');
                    try {
                        performance.measure('esp32_flasher_send', 'esp32_flasher_send_start', 'esp32_flasher_send_end');
                        performance.measure('esp32_flasher_latency', 'esp32_flasher_receive_end', 'esp32_flasher_send_start');
                        /* measured ~50-100us latency on USB-JTAG for register read flooding */
                    } catch (measureErr) {
                    }
                }
            } catch (error) {
                clearTimeout(timeoutHandle);
                reject(error);
            }
        });
    }

    /**
     * Disconnect from serial port
     * @async
     * @returns {Promise<void>}
     */
    async disconnect() {
        if (this._disconnecting) {
            return;
        }
        this._disconnecting = true;

        navigator.serial.removeEventListener('disconnect', this.disconnect);

        if (this.reader) {
            try {
                await this.reader.cancel();
            } catch (error) {
                this.logError('Error cancelling reader:', error);
            }
        }

        /* Release persistent writer before closing port */
        this._releaseWriter();

        if (this.port) {
            try {
                this.port.removeEventListener('close', this.disconnect);
                await this.port.close();
            } catch (error) {
                //this.logError('Error during disconnect:', error);
            }
            this.port = null;
        }

        this.synced = false;
        this.consoleBuffer = '';
        this._preSyncState = 'idle';
        this._disconnecting = false;

        this.disconnected && this.disconnected();
    }

    async setDtr(value) {
        try {
            this.dtrState = value;
            await this.port.setSignals({
                dataTerminalReady: value,
                requestToSend: this.rtsState,
            });
            return true;
        } catch (error) {
            console.error(`Could not set DTR: ${error}.`);
            return false;
        }
    }

    async setRts(value) {
        try {
            this.rtsState = value;
            await this.port.setSignals({
                dataTerminalReady: this.dtrState,
                requestToSend: value,
            });
            return true;
        } catch (error) {
            console.error(`Could not set RTS: ${error}.`);
            return false;
        }
    }

    async setDtrRts(dtr, rts) {
        if (!this.port) {
            this.logError("Port is not open. Cannot set signals.");
            return false;
        }

        this.dtrState = dtr;
        this.rtsState = rts;

        try {
            await this.port.setSignals({
                dataTerminalReady: dtr,
                requestToSend: rts,
            });
            return true;
        } catch (error) {
            this.logError(`Could not set signals: ${error}.`);
            return false;
        }
    }

    async setSignals(signals) {
        if (!this.port) {
            this.logError("Port is not open. Cannot set signals.");
            return false;
        }

        if (signals.dataTerminalReady !== undefined) {
            this.dtrState = signals.dataTerminalReady;
        }
        if (signals.requestToSend !== undefined) {
            this.rtsState = signals.requestToSend;
        }

        try {
            await this.setDtr(this.dtrState);
            await this.setRts(this.rtsState);
            return true;
        } catch (error) {
            this.logError(`Could not set signals: ${error}.`);
            return false;
        }
    }

    /**
     * Attempts to put the ESP device into bootloader mode using RTS/DTR signals.
     * Relies on the common DTR=EN, RTS=GPIO0 circuit. May not work on all boards.
     * @returns {Promise<boolean>} True if the sequence was sent, false if an error occurred (e.g., signals not supported).
     */
    async hardReset(bootloader = true) {
        if (!this.port) {
            this.logError("Port is not open. Cannot set signals.");
            return false;
        }

        this.synced = false;
        this.consoleBuffer = '';
        this._preSyncState = 'idle';

        this.logDebug("Automatic bootloader reset sequence...");

        try {

            if (this.isEspressifUsbJtag) {
                /* Native USB/JTAG interface - use the method described in ESP32-S3 Table 33.4-3. Reset SoC into Download Mode.
                   This procedure assumes the Windows CDC driver toggles DRT only when RTS is set explicitly. */

                /* set to known state first, but causes an extra reset usually */
                await this.setDtr(false);
                await this.setRts(false);

                if (bootloader) {
                    await this.setDtr(true);
                    await this.setRts(false);
                    await this.setRts(true);
                    await this.setDtr(false);
                }

                await this.setRts(false);
                await this.setRts(true);
            } else {
                /* high/low vs. asserted/deasserted logic is a bit pain here:
                   EN pin (RTS) - active low - to reset, pull low (EN high means RTS=false)
                   IO0 pin (DTR) - active low - to enter bootloader, pull low (IO0 high means DTR=false)
                */
                const setPins = async ({ io0PinHigh, enPinHigh }) => {
                    const io0Level = io0PinHigh ? false : true;
                    const enLevel = enPinHigh ? false : true;
                    await this.setSignals({ requestToSend: enLevel, dataTerminalReady: io0Level });
                };

                await setPins({ io0PinHigh: true, enPinHigh: true });
                await setPins({ io0PinHigh: false, enPinHigh: false });
                await setPins({ io0PinHigh: true, enPinHigh: false });
                await new Promise(r => setTimeout(r, 50));
                await setPins({ io0PinHigh: bootloader ? false : true, enPinHigh: true });
                await new Promise(r => setTimeout(r, 100));
                await setPins({ io0PinHigh: true, enPinHigh: true });
            }

            return true;
        } catch (error) {
            this.logError(`Could not set signals for automatic reset: ${error}. Please ensure device is in bootloader mode manually.`);
            return false;
        }
    }


    /**
     * Convert base64-encoded string to binary data
     * @param {string} base64 - Base64-encoded data string
     * @returns {Uint8Array} Decoded binary data
     * @description Decodes base64 string using native atob and converts to Uint8Array
     */
    base64ToByteArray(base64) {
        const binaryString = atob(base64);
        const byteArray = new Uint8Array(binaryString.length);
        for (let index = 0; index < binaryString.length; index++) {
            byteArray[index] = binaryString.charCodeAt(index);
        }
        return byteArray;
    }

    /**
     * Download binary payload to device RAM
     * @async
     * @param {number} address - Target RAM address
     * @param {string} payload - Base64-encoded binary data
     * @returns {Promise<void>}
     * @throws {Error} If download fails
     * @description Used for downloading stub loader and other code to RAM
     */
    async downloadMem(address, payload) {
        var binary = this.base64ToByteArray(payload);

        await this.executeCommand(this.buildCommandPacketU32(MEM_BEGIN, binary.length, 1, binary.length, address),
            async (resolve, reject, responsePacket) => {
                resolve();
            });
        await this.executeCommand(this.buildCommandPacketU32(MEM_DATA, binary.length, 0, 0, 0, binary),
            async (resolve, reject, responsePacket) => {
                resolve();
            });
    }

    /**
     * Synchronize with bootloader and detect chip type
     * @async
     * @returns {Promise<void>}
     * @throws {Error} If synchronization fails after all retries
     * @description Performs SYNC command with retry logic, then reads chip magic value
     *              to detect connected chip type (ESP32, ESP32-S3, etc.)
     */
    async sync() {
        const maxRetries = 4;
        const retryDelayMs = 100; /* Delay between retries (Android stacks can be slower) */
        const syncTimeoutMs = 300; /* Timeout for each individual sync attempt */
        let synchronized = false;

        this.logDebug(`Attempting to synchronize (${maxRetries} attempts)...`);

        const syncData = new Uint8Array([0x07, 0x07, 0x12, 0x20, ...Array(32).fill(0x55)]);
        const syncPacket = this.buildCommandPacket(SYNC, syncData);

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            this.logDebug(`Sync attempt ${attempt}...`);
            try {
                await this.executeCommand(
                    syncPacket,
                    async (resolve, reject, responsePacket) => {
                        // The ROM bootloader responds to SYNC with 0x08 0x00 status - check value maybe?
                        // For now, just receiving *any* response to SYNC is considered success here.
                        // If the command times out, the catch block below handles it.
                        resolve(); // Signal success for this attempt
                    },
                    null, // No default callback needed here
                    syncTimeoutMs // Use a specific timeout for sync
                );

                // If executeCommand resolved without throwing/rejecting:
                this.logDebug(`Synchronized successfully on attempt ${attempt}.`);
                synchronized = true;
                break; // Exit the retry loop on success

            } catch (error) {
                this.logDebug(`Sync attempt ${attempt} failed: ${error.message}`);
                if (attempt === maxRetries) {
                    this.logError(`Failed to synchronize after ${maxRetries} attempts.`);
                    // Throw an error to indicate overall failure of the sync process
                    throw new Error(`Failed to synchronize with device after ${maxRetries} attempts.`);
                }
                // Wait before the next retry
                await new Promise(resolve => setTimeout(resolve, retryDelayMs));
            }
        }

        // This part only runs if synchronized was set to true
        if (!synchronized) {
            // This should technically not be reached if the error is thrown above,
            // but adding as a safeguard.
            throw new Error("Synchronization failed (unexpected state).");
        }

        this.synced = true;

        // Read security information
        try {
            this.logDebug("Reading security information...");
            this.securityInfo = await this.getSecurityInfo();
            this.current_chip = CHIP_ID_MAP[this.securityInfo.chip_id_hex >>> 0] || "unknown";

            this.logDebug(`Security Info: Flags=${this.securityInfo.flags_hex}, Flash Crypt=${this.securityInfo.flash_crypt_cnt}, Chip ID=${this.securityInfo.chip_id_hex} (${this.current_chip}), ECO=${this.securityInfo.eco_version_hex}`);

            /* Log enabled security features */
            const enabledFlags = Object.entries(this.securityInfo.flags_decoded)
                .filter(([key, value]) => value)
                .map(([key, _]) => key);
            if (enabledFlags.length > 0) {
                this.logDebug(`  Enabled security features: ${enabledFlags.join(', ')}`);
            } else {
                this.logDebug(`  No security features enabled`);
            }

            if (this.securityInfo.flags_decoded.SECURE_BOOT_EN) {
                if (!this.securityInfo.flags_decoded.SECURE_DOWNLOAD_ENABLE) {
                    this.deviceStateCallback && this.deviceStateCallback('secure_boot');
                } else {
                    this.deviceStateCallback && this.deviceStateCallback('secure_download');
                }
            }

            /* if this command succeeded, we already have the chip type, so we can just return. only plain ESP32 doesn't have the security info command */
            return;
        } catch (error) {
            this.logDebug(`Failed to read security info: ${error.message}, maybe plain ESP32? Continuing to old chip detection...`);
        }

        // --- Chip Detection (Runs only after successful sync) ---
        this.logDebug("Reading chip magic value...");
        let currentValue;
        try {
            // Use a slightly longer timeout for register reads if needed
            currentValue = await this.readReg(this.chip_magic_addr);
        } catch (readError) {
            this.logError(`Failed to read magic value after sync: ${readError}`);
            throw new Error(`Successfully synced, but failed to read chip magic value: ${readError.message}`);
        }

        /* Function to check if the value matches any of the magic values */
        const isMagicValue = (stub, value) => {
            if (Array.isArray(stub.magic_value)) {
                return stub.magic_value.includes(value);
            } else {
                return stub.magic_value === value;
            }
        };

        let chipDetected = false;
        /* Iterate through each stub in the object */
        for (const desc in this.chip_descriptions) {
            if (this.chip_descriptions.hasOwnProperty(desc)) {
                const checkStub = this.chip_descriptions[desc];
                if (isMagicValue(checkStub, currentValue)) {
                    this.logDebug(`Detected Chip: ${desc} (Magic: 0x${currentValue.toString(16)})`);
                    this.current_chip = desc;
                    chipDetected = true;
                    break; // Found the chip
                }
            }
        }

        if (!chipDetected) {
            this.logError(`Synced, but chip magic value 0x${currentValue.toString(16)} is unknown.`);
            this.current_chip = "unknown"; // Mark as unknown
        }
    }

    /**
     * Read device MAC address from eFuses
     * @async
     * @returns {Promise<string>} MAC address as colon-separated hex string (e.g., "aa:bb:cc:dd:ee:ff")
     * @throws {Error} If register read fails
     * @description Reads MAC address from chip-specific eFuse registers
     */
    async readMac() {
        /* Read the MAC address registers */
        var chip = this.chip_descriptions[this.current_chip];
        if (!chip.mac_efuse_reg) {
            throw new Error(`MAC eFuse register not defined for chip ${this.current_chip}`);
        }
        const register1 = await this.readReg(chip.mac_efuse_reg);
        const register2 = await this.readReg(chip.mac_efuse_reg + 4);

        if (!register1 || !register2) {
            return;
        }

        const lower = (register1 >>> 0);
        const higher = (register2 >>> 0) & 0xFFFF;

        // Construct MAC address from register values
        const macBytes = new Uint8Array(6);
        macBytes[0] = (higher >> 8) & 0xFF;
        macBytes[1] = higher & 0xFF;
        macBytes[2] = (lower >> 24) & 0xFF;
        macBytes[3] = (lower >> 16) & 0xFF;
        macBytes[4] = (lower >> 8) & 0xFF;
        macBytes[5] = lower & 0xFF;

        function toHex(byte) {
            const hexString = byte.toString(16);
            return hexString.length === 1 ? '0' + hexString : hexString;
        }
        const mac = Array.from(macBytes)
            .map(byte => toHex(byte))
            .join(':');

        return mac;
    }

    /**
     * Read chip security information
     * @async
     * @returns {Promise<Object>} Security info object with flags, flash_crypt_cnt, key_purposes, chip_id, eco_version
     * @throws {Error} If read fails
     * @description Reads chip security configuration including encryption status and key purposes
     */
    async getSecurityInfo() {
        return this.executeCommand(
            this.buildCommandPacketU32(GET_SECURITY_INFO, 0),
            async (resolve, reject, responsePacket) => {
                if (responsePacket && responsePacket.data && responsePacket.data.length >= 20) {
                    const data = responsePacket.data;

                    /* Parse 32-bit flags (little-endian) */
                    const flags = (data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24)) >>> 0;

                    /* Decode security flags */
                    const decodedFlags = {
                        SECURE_BOOT_EN: !!(flags & (1 << 0)),
                        SECURE_BOOT_AGGRESSIVE_REVOKE: !!(flags & (1 << 1)),
                        SECURE_DOWNLOAD_ENABLE: !!(flags & (1 << 2)),
                        SECURE_BOOT_KEY_REVOKE0: !!(flags & (1 << 3)),
                        SECURE_BOOT_KEY_REVOKE1: !!(flags & (1 << 4)),
                        SECURE_BOOT_KEY_REVOKE2: !!(flags & (1 << 5)),
                        SOFT_DIS_JTAG: !!(flags & (1 << 6)),
                        HARD_DIS_JTAG: !!(flags & (1 << 7)),
                        DIS_USB: !!(flags & (1 << 8)),
                        DIS_DOWNLOAD_DCACHE: !!(flags & (1 << 9)),
                        DIS_DOWNLOAD_ICACHE: !!(flags & (1 << 10))
                    };

                    /* Parse 1 byte flash_crypt_cnt */
                    const flash_crypt_cnt = data[4];

                    /* Parse 7 bytes key_purposes */
                    const key_purposes = Array.from(data.slice(5, 12));

                    /* Parse 32-bit chip_id (little-endian) */
                    const chip_id = (data[12] | (data[13] << 8) | (data[14] << 16) | (data[15] << 24)) >>> 0;

                    /* Parse 32-bit eco_version (little-endian) */
                    const eco_version = (data[16] | (data[17] << 8) | (data[18] << 16) | (data[19] << 24)) >>> 0;

                    const securityInfo = {
                        flags: flags,
                        flags_hex: '0x' + flags.toString(16).toUpperCase().padStart(8, '0'),
                        flags_decoded: decodedFlags,
                        flash_crypt_cnt: flash_crypt_cnt,
                        key_purposes: key_purposes,
                        chip_id: chip_id,
                        chip_id_hex: '0x' + chip_id.toString(16).toUpperCase().padStart(8, '0'),
                        eco_version: eco_version,
                        eco_version_hex: '0x' + eco_version.toString(16).toUpperCase().padStart(8, '0')
                    };

                    resolve(securityInfo);
                } else {
                    reject('Invalid security info response');
                }
            },
            null,
            100
        );
    }

    /**
     * Test serial communication reliability
     * @async
     * @param {Function} [cbr] - Progress callback(percentComplete)
     * @returns {Promise<boolean>} True if test passed, false if failed
     * @description Performs 1-second stress test reading the same register repeatedly,
     *              verifying all reads return identical values
     */
    async testReliability(cbr) {

        var chip = this.chip_descriptions[this.current_chip];
        var reference = 0;

        try {
            reference = await this.executeCommand(this.buildCommandPacketU32(READ_REG, chip.mac_efuse_reg),
                async (resolve, reject, responsePacket) => {
                    if (responsePacket) {
                        resolve(responsePacket.value);
                    } else {
                        this.logError(`Test read failed`);
                        reject(`Test read failed`);
                    }
                });
        } catch (error) {
            this.logError(`Test read failed due to an error`, `${error.message}`);
            return false;
        }

        var duration = 1000;
        const endTime = Date.now() + duration;

        let totalReads = 0;
        let totalTime = 0;

        while (Date.now() < endTime) {
            try {
                const startTime = Date.now();

                var testread = await this.executeCommand(this.buildCommandPacketU32(READ_REG, chip.mac_efuse_reg),
                    async (resolve, reject, responsePacket) => {
                        if (responsePacket) {
                            resolve(responsePacket.value);
                        } else {
                            reject(`Test read failed`);
                        }
                    });

                const endTimeRead = Date.now();
                const readDuration = endTimeRead - startTime;

                totalTime += readDuration;
                totalReads++;

                /* Update the progress bar */
                const elapsed = Date.now() - (endTime - duration); // duration is the total time period (change to 30000 for 30 seconds)
                const progressPercentage = Math.min(100, (elapsed / duration) * 100); // Cap at 100%

                cbr && cbr(progressPercentage);

                /* Check if the read value differs from the reference */
                if (testread !== reference) {
                    this.logError(`Test read failed! Expected: 0x${reference.toString(16).padStart(8, '0')}, but got: 0x${testread.toString(16).padStart(8, '0')}`);
                    break;
                }
            } catch (error) {
                this.logError(`Test read failed due to an error`, `${error.message}`);
                return false;
            }
        }

        if (totalReads > 0) {
            const averageTime = totalTime / totalReads;
            this.logMessage(`Average read time: ${averageTime.toFixed(2)} ms over ${totalReads} reads.`);
        }

        return true;
    }

    /**
     * Download and execute stub loader on device
     * @async
     * @returns {Promise<boolean>} True if stub loaded successfully, false otherwise
     * @throws {Error} If stub loading or initialization fails
     * @description Downloads stub firmware to RAM and executes it.
     *              Stub provides additional capabilities like flash read/write and MD5.
     */
    async downloadStub() {
        var stub = this.chip_descriptions[this.current_chip].stub

        if (stub.data_start != undefined && stub.data != undefined) {
            await this.downloadMem(stub.data_start, stub.data);
        }
        await this.downloadMem(stub.text_start, stub.text);

        try {
            await this.executeCommand(this.buildCommandPacketU32(MEM_END, 0, stub.entry),
                async (resolve, reject, responsePacket) => {
                    this.logDebug("Final MEM_END ACK");
                },
                async (resolve, reject, rawData) => {
                    const decoder = new TextDecoder('utf-8');
                    const responseData = decoder.decode(rawData);

                    if (responseData == "OHAI") {
                        this.logDebug(`Stub loader executed successfully (received ${responseData})`);
                        this.stubLoaded = true;
                        resolve();
                    } else {
                        this.logError(`Unexpected stub response: ${responseData}`);
                        reject(`Unexpected response from stub: ${responseData}`);
                    }
                },
                3000 // Longer timeout for stub execution
            );
        } catch (error) {
            this.logDebug(error);
            this.logError("Failed to execute stub", "Is the device locked?");
            return false;
        }

        try {
            await this.executeCommand(this.buildCommandPacketU32(SPI_SET_PARAMS, 0, 0x800000, 64 * 1024, 4 * 1024, 256, 0xFFFF), async (resolve, reject, responsePacket) => {
                this.logDebug("SPI_SET_PARAMS configured");
                resolve();
            });
        } catch (error) {
            this.logError("Failed to configure SPI parameters", error.message);
            return false;
        }

        return true;
    }

    /**
     * Write data to flash memory
     * @async
     * @param {number} address - Target flash address
     * @param {Uint8Array} data - Binary data to write
     * @param {Function} [progressCallback] - Callback(bytesWritten, totalBytes)
     * @returns {Promise<void>}
     * @throws {Error} If write fails
     */
    async writeFlashPlain(address, data, progressCallback) {
        const MAX_PACKET_SIZE = 0x1000;
        const packets = Math.ceil(data.length / MAX_PACKET_SIZE);

        /* Send FLASH_BEGIN command with the total data size
           according to https://docs.espressif.com/projects/esptool/en/latest/esp32s3/advanced-topics/serial-protocol.html
           the ROM bootloader is also able to flash. unfortunately there are some issues with it.
           it doesn't respond anymore. use with stub only!
        */
        await this.executeCommand(
            this.buildCommandPacketU32(FLASH_BEGIN, data.length, packets,
                Math.min(MAX_PACKET_SIZE, data.length),
                address
            ),
            async (resolve) => {
                resolve();
            }
        );

        /* Split data into chunks and send FLASH_DATA commands */
        var seq = 0;
        for (let offset = 0; offset < data.length; offset += MAX_PACKET_SIZE) {
            const chunk = data.slice(offset, offset + MAX_PACKET_SIZE);

            /* Four 32-bit words: data size, sequence number, 0, 0, then data. Uses Checksum. */
            await this.executeCommand(
                this.buildCommandPacketU32(FLASH_DATA, chunk.length, seq++, 0, 0, chunk),
                async (resolve) => {
                    resolve();
                },
                null,
                5000
            );

            progressCallback && progressCallback(offset + chunk.length, data.length);
        }
    }

    /**
     * Read data from flash memory
     * @async
     * @param {number} address - Source flash address
     * @param {number} [totalLength=0x1000] - Number of bytes to read
     * @param {Function} [progressCallback] - Callback(bytesRead, totalBytes)
     * @returns {Promise<Uint8Array>} Read data (MD5 verified)
     * @throws {Error} If read fails or MD5 mismatch
     * 

       ESP32-C3
        [01:04:10] [DEBUG] ReadFlash timing: 262144 bytes in 22772ms
        [01:04:10] [DEBUG]   Data rate: 0.01 MB/s (11512 B/s)
        [01:04:10] [DEBUG]   Packet latency: min=348ms, max=358ms, avg=355.8ms
        [01:04:10] [DEBUG]   Packets received: 64

       ESP32-C6
        [01:05:00] [DEBUG] ReadFlash timing: 262144 bytes in 841ms
        [01:05:00] [DEBUG]   Data rate: 0.30 MB/s (311705 B/s)
        [01:05:00] [DEBUG]   Packet latency: min=13ms, max=14ms, avg=13.1ms
        [01:05:00] [DEBUG]   Packets received: 64

       ESP32-S3
        [01:06:29] [DEBUG] ReadFlash timing: 262144 bytes in 22762ms
        [01:06:29] [DEBUG]   Data rate: 0.01 MB/s (11517 B/s)
        [01:06:29] [DEBUG]   Packet latency: min=350ms, max=356ms, avg=355.6ms
        [01:06:29] [DEBUG]   Packets received: 64

     */
    async readFlashPlain(address, totalLength = 0x1000, cbr) {
        let blockSize = Math.min(totalLength, 0x1000);
        let maxInFlight = Math.min(totalLength, blockSize * 2);
        const packetCount = totalLength / blockSize;

        let packet = 0;
        let lastAckedLength = 0;
        var data = new Uint8Array(0);
        var lastDataTime = Date.now();

        /* Timing measurements */
        const readStartTime = Date.now();
        let packetLatencies = [];
        let lastPacketTime = readStartTime;
        let totalBytesReceived = 0;

        if (this.devMode) {
            this.logDebug(`[ReadFlashPlain] Starting ReadFlash:`, { address: `0x${address.toString(16)}`, length: totalLength, sectorSize: blockSize, packets: packetCount, maxInFlight: maxInFlight });
        }

        return this.executeCommand(
            this.buildCommandPacketU32(READ_FLASH, address, totalLength, blockSize, maxInFlight),
            async () => {
                packet = 0;
            },
            async (resolve, reject, rawData) => {
                const currentTime = Date.now();
                lastDataTime = currentTime;

                if (data.length == totalLength) {
                    if (rawData.length == 16) {
                        /* Calculate MD5 of received data */
                        const calculatedMD5 = this.calculateMD5(data);

                        /* Convert received MD5 bytes to hex string */
                        const receivedMD5 = Array.from(rawData)
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');

                        /* Compare MD5 hashes */
                        if (calculatedMD5.toLowerCase() === receivedMD5.toLowerCase()) {
                            /* Calculate and log timing statistics */
                            const totalTime = currentTime - readStartTime;
                            const dataRate = totalBytesReceived / (totalTime / 1000);
                            const avgLatency = packetLatencies.length > 0
                                ? packetLatencies.reduce((a, b) => a + b, 0) / packetLatencies.length
                                : 0;
                            const minLatency = packetLatencies.length > 0
                                ? Math.min(...packetLatencies)
                                : 0;
                            const maxLatency = packetLatencies.length > 0
                                ? Math.max(...packetLatencies)
                                : 0;

                            if (this.devMode) {
                                this.logDebug(`ReadFlash timing: ${totalBytesReceived} bytes in ${totalTime}ms`);
                                this.logDebug(`  Data rate: ${(dataRate / 1024 / 1024).toFixed(2)} MB/s (${dataRate.toFixed(0)} B/s)`);
                                this.logDebug(`  Packet latency: min=${minLatency}ms, max=${maxLatency}ms, avg=${avgLatency.toFixed(1)}ms`);
                                this.logDebug(`  Packets received: ${packetLatencies.length}`);
                            }

                            resolve(data);
                        } else {
                            const error = `MD5 mismatch! Expected: ${receivedMD5}, Got: ${calculatedMD5}`;
                            this.logError(error);
                            reject(new Error(error));
                        }
                    } else {
                        const error = `Unknown response length for MD5! Expected: 16, Got: ${rawData.length}`;
                        this.logError(error);
                        reject(new Error(error));
                    }
                } else {
                    /* Track packet latency */
                    const packetLatency = currentTime - lastPacketTime;
                    packetLatencies.push(packetLatency);
                    lastPacketTime = currentTime;
                    totalBytesReceived += rawData.length;

                    /* Append rawData to accumulated data */
                    const newData = new Uint8Array(data.length + rawData.length);
                    newData.set(data);
                    newData.set(rawData, data.length);
                    data = newData;
                    packet++;

                    /* Prepare response */
                    if (data.length >= (lastAckedLength + maxInFlight) || (data.length >= totalLength)) {

                        /* Encode and write response */
                        var resp = new Uint8Array(4);
                        resp[0] = (data.length >> 0) & 0xFF;
                        resp[1] = (data.length >> 8) & 0xFF;
                        resp[2] = (data.length >> 16) & 0xFF;
                        resp[3] = (data.length >> 24) & 0xFF;

                        await this._writeFrame(this.slipLayer.encode(resp));

                        /* move last acked length further */
                        lastAckedLength = Math.min(lastAckedLength + maxInFlight, totalLength);
                    }

                    /* Call progress callback */
                    if (cbr) {
                        cbr(data.length, totalLength);
                    }
                }
            },
            500,
            /* Timeout condition: if the last raw data callback was more than a second ago */
            () => {
                const timeSinceLastData = Date.now() - lastDataTime;
                const hasTimedOut = timeSinceLastData > 1000;
                if (hasTimedOut) {
                    this.logError(`[ReadFlashPlain] TIMEOUT CHECK: timeSinceLastData=${timeSinceLastData}ms, triggering timeout`);
                }
                return hasTimedOut;
            }
        );
    }

    /**
     * Calculate MD5 checksum of flash region
     * @async
     * @param {number} address - Start address
     * @param {number} length - Number of bytes
     * @returns {Promise<string>} MD5 hash (hex)
     * @throws {Error} If checksum fails
     */
    async checksumFlash(address, length) {
        return this.executeCommand(
            this.buildCommandPacketU32(SPI_FLASH_MD5, address, length, 0, 0),
            async (resolve, reject, responsePacket) => {
                /* MD5 response is in the data field */
                if (responsePacket && responsePacket.data) {
                    /* Convert data bytes to hex string */
                    const md5 = Array.from(responsePacket.data.slice(0, 16))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');
                    resolve(md5);
                } else {
                    reject('No MD5 data received');
                }
            },
            async (resolve, reject, rawData) => {
                /* Handle raw data response if it comes this way */
                const decoder = new TextDecoder('utf-8');
                const md5String = decoder.decode(rawData);
                resolve(md5String.trim());
            },
            1000 + length / 500 // Timeout based on length
        );
    }

    /**
     * Calculate local MD5 hash
     * @param {Uint8Array|string} data - Data to hash
     * @returns {string} MD5 hash (hex)
     */
    calculateMD5(data) {
        /* Create MD5 hash using the Md5 class */
        const md5 = new this.Md5();
        md5.update(data);
        return md5.hex();
    }

    /**
     * Read flash with comprehensive MD5 verification
     * @async
     * @param {number} address - Source address
     * @param {number} size - Number of bytes
     * @param {Function} [progressCallback] - Callback(read, total, stage)
     * @returns {Promise<Uint8Array>} Verified data
     * @throws {Error} If read/verification fails
     */
    async readFlash(address, size, progressCallback) {
        var blockSize = 64 * 0x1000;

        if (this.port instanceof WebUSBSerial) {
            blockSize = (this.port.maxTransferSize - 2) / 2; /* remove 2 bytes for SLIP overhead, divide by 2 because 0xC0 gets potentially escaped */
        }

        try {
            /* Step 1: Read data in blocks */
            this.logDebug(`ReadFlashSafe: Reading ${size} bytes in ${blockSize}-byte blocks...`);
            const allData = new Uint8Array(size);
            let offset = 0;

            while (offset < size) {
                const readSize = Math.min(blockSize, size - offset);
                let cbr = (read, readBlockSize) => {
                    progressCallback && progressCallback(offset + read, size, 'reading');
                }
                const blockData = await this.readFlashPlain(address + offset, readSize, cbr);

                /* Copy block to buffer */
                allData.set(blockData.slice(0, readSize), offset);
                offset += readSize;

                /* Call progress callback */
                progressCallback && progressCallback(offset, size, 'reading');

                if (this.devMode) {
                    this.logDebug(`ReadFlashSafe: Read ${offset}/${size} bytes (${Math.round((offset / size) * 100)}%)`);
                }
            }

            /* Step 2: Calculate MD5 of read data */
            progressCallback && progressCallback(size, size, 'calc MD5 of input');
            this.logDebug(`ReadFlashSafe: Calculating MD5 of read data...`);
            const actualMD5 = await this.calculateMD5(allData);
            this.logDebug(`Actual MD5: ${actualMD5}`);

            /* Step 3: Get expected MD5 from flash */
            progressCallback && progressCallback(size, size, 'calc MD5 onchip');

            this.logDebug(`ReadFlashSafe: Calculating expected MD5 for ${size} bytes at 0x${address.toString(16).padStart(8, '0')}...`);
            const expectedMD5 = await this.checksumFlash(address, size);
            this.logDebug(`Expected MD5: ${expectedMD5}`);

            /* Step 4: Compare MD5 hashes */
            if (expectedMD5.toLowerCase() !== actualMD5.toLowerCase()) {
                this.logError(`ReadFlashSafe FAILED: MD5 mismatch!`);
                this.logError(`  Expected: ${expectedMD5}`);
                this.logError(`  Actual:   ${actualMD5}`);
                throw new Error(`MD5 verification failed: expected ${expectedMD5}, got ${actualMD5}`);
            }

            this.logDebug(`ReadFlashSafe: MD5 verification passed ‚úì`);
            return allData;

        } catch (error) {
            this.logError(`ReadFlashSafe failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * Write flash with MD5 verification
     * @async
     * @param {number} address - Target address
     * @param {Uint8Array} data - Data to write
     * @param {Function} [progressCbr] - Callback(written, total, stage)
     * @returns {Promise<Object>} {success: boolean, md5: string}
     * @throws {Error} If write/verification fails
     */
    async writeFlash(address, data, progressCbr) {
        try {
            /* Step 1: Write data to flash */
            this.logDebug(`WriteFlashSafe: Writing ${data.length} bytes to 0x${address.toString(16).padStart(8, '0')}...`);
            await this.writeFlashPlain(address, data, (offset, total) => {
                progressCbr && progressCbr(offset, total, 'Writing');
            });
            this.logDebug(`WriteFlashSafe: Write complete`);

            /* Step 2: Calculate MD5 of input data */
            progressCbr && progressCbr(data.length, data.length, 'Calculating MD5 of input');
            this.logDebug(`WriteFlashSafe: Calculating MD5 of ${data.length} bytes to write...`);
            const expectedMD5 = this.calculateMD5(data);
            this.logDebug(`Input data MD5: ${expectedMD5}`);

            /* Step 3: Get MD5 from device */
            progressCbr && progressCbr(data.length, data.length, 'Calculating MD5 on device');
            this.logDebug(`WriteFlashSafe: Calculating MD5 on device for verification...`);
            const deviceMD5 = await this.checksumFlash(address, data.length);
            this.logDebug(`Device MD5: ${deviceMD5}`);

            /* Step 4: Compare MD5 hashes */
            if (expectedMD5.toLowerCase() !== deviceMD5.toLowerCase()) {
                this.logError(`WriteFlashSafe FAILED: MD5 mismatch!`);
                this.logError(`  Expected: ${expectedMD5}`);
                this.logError(`  Device:   ${deviceMD5}`);
                throw new Error(`MD5 verification failed after write: expected ${expectedMD5}, got ${deviceMD5}`);
            }

            this.logDebug(`WriteFlashSafe: MD5 verification passed ‚úì`);

            progressCbr && progressCbr(data.length, data.length, expectedMD5, 'Verified');

            return { success: true, md5: expectedMD5 };

        } catch (error) {
            this.logError(`WriteFlashSafe failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * Check if flash memory is erased
     * @async
     * @param {Function} [cbr] - Progress callback
     * @returns {Promise<void>}
     */
    async blankCheck(startAddress = 0x000000, endAddress = 0x800000, cbr = null) {
        const blockSize = 0x1000;

        let totalReads = 0;
        let totalTime = 0;
        let erasedBytesTotal = 0;
        let currentAddress = startAddress;

        while (currentAddress < endAddress) {

            try {
                const startTime = Date.now();
                var rawData = await this.readFlashPlain(currentAddress, blockSize);
                const endTimeRead = Date.now();
                const readDuration = endTimeRead - startTime;

                var erasedBytes = 0;
                for (var pos = 0; pos < rawData.length; pos++) {
                    if (rawData[pos] == 0xFF) {
                        erasedBytes++;
                    }
                }

                currentAddress += rawData.length;
                erasedBytesTotal += erasedBytes;
                totalTime += readDuration;
                totalReads++;

                cbr && cbr(currentAddress, startAddress, endAddress, blockSize, erasedBytes, erasedBytesTotal);
            } catch (error) {
                this.logError(`Read failed due to an error`, `${error.message}`);
                this.disconnect();
                break;
            }
        }

        if (totalReads > 0) {
            const averageTime = totalTime / totalReads;
            this.logDebug(`Average read time: ${averageTime.toFixed(2)} ms over ${totalReads} reads.`);
        }
    }

    /**
     * Write/Read stress test
     * @async
     * @param {number} address - Test address
     * @param {number} size - Test data size
     * @param {Function} [cbr] - Progress callback
     * @returns {Promise<Object>} Test result
     * @throws {Error} On critical failure
     */
    async writeReadTest(address, size, cbr) {
        try {
            /* Step 1: Read original data */
            this.logDebug(`Test: Reading original ${size} bytes from 0x${address.toString(16).padStart(8, '0')}...`);
            cbr && cbr('reading_original', 0, 3);
            const originalData = await this.readFlashPlain(address, size);
            this.logDebug(`Original data read complete`);

            /* Hexdump original data (first 64 bytes) */
            const dumpSize = Math.min(64, size);
            this.logDebug(`Original data hexdump (first ${dumpSize} bytes):`);
            for (let i = 0; i < dumpSize; i += 16) {
                const chunk = originalData.slice(i, i + 16);
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                const ascii = Array.from(chunk).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
                this.logDebug(`  ${(address + i).toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`);
            }

            /* Step 2: Generate random data */
            this.logDebug(`Test: Generating ${size} bytes of random data...`);
            cbr && cbr('generating_random', 1, 3);
            const randomData = new Uint8Array(size);
            for (let i = 0; i < size; i++) {
                randomData[i] = Math.floor(Math.random() * 256);
            }
            this.logDebug(`Random data generated`);

            /* Hexdump random data (first 64 bytes) */
            this.logDebug(`Random data hexdump (first ${dumpSize} bytes):`);
            for (let i = 0; i < dumpSize; i += 16) {
                const chunk = randomData.slice(i, i + 16);
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                const ascii = Array.from(chunk).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
                this.logDebug(`  ${(address + i).toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`);
            }

            /* Step 3: Write random data to flash */
            this.logDebug(`Test: Writing ${size} bytes to flash at 0x${address.toString(16).padStart(8, '0')}...`);
            cbr && cbr('writing', 2, 3);
            await this.writeFlashPlain(address, randomData, (offset, total) => {
                const percent = Math.round((offset / total) * 100);
                cbr && cbr('writing', 2, 3, percent);
            });
            this.logDebug(`Write complete`);

            /* Step 4: Read back the data */
            this.logDebug(`Test: Reading back ${size} bytes from 0x${address.toString(16).padStart(8, '0')}...`);
            cbr && cbr('reading_back', 3, 3);
            const readbackData = await this.readFlashPlain(address, size);
            this.logDebug(`Readback complete`);

            /* Hexdump readback data (first 64 bytes) */
            this.logDebug(`Readback data hexdump (first ${dumpSize} bytes):`);
            for (let i = 0; i < dumpSize; i += 16) {
                const chunk = readbackData.slice(i, i + 16);
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                const ascii = Array.from(chunk).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
                this.logDebug(`  ${(address + i).toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`);
            }

            /* Step 5: Verify data matches */
            let errors = 0;
            let firstError = -1;
            for (let i = 0; i < size; i++) {
                if (randomData[i] !== readbackData[i]) {
                    if (firstError === -1) {
                        firstError = i;
                    }
                    errors++;
                }
            }

            const result = {
                success: errors === 0,
                errors: errors,
                firstError: firstError,
                address: address,
                size: size,
                originalData: originalData,
                randomData: randomData,
                readbackData: readbackData
            };

            if (errors === 0) {
                this.logDebug(`‚úì Test PASSED: All ${size} bytes match!`);
            } else {
                this.logError(`‚úó Test FAILED: ${errors} byte(s) mismatch!`);
                this.logError(`  First error at offset 0x${firstError.toString(16).padStart(4, '0')} (byte ${firstError})`);
                this.logError(`  Expected: 0x${randomData[firstError].toString(16).padStart(2, '0')}, Got: 0x${readbackData[firstError].toString(16).padStart(2, '0')}`);
            }

            cbr && cbr('complete', 3, 3, 100, result);
            return result;

        } catch (error) {
            this.logError(`Write/Read test failed: ${error.message}`);
            cbr && cbr('error', 0, 3, 0, { success: false, error: error.message });
            throw error;
        }
    }

    /**
     * Build command packet with 32-bit arguments
     * @param {number} command - Command code
     * @param {...(number|Uint8Array)} values - Arguments
     * @returns {Object} {command, payload: Uint8Array}
     */
    buildCommandPacketU32(command, ...values) {
        /* Calculate total length for data */
        let totalLength = 0;
        values.forEach(value => {
            if (typeof value === 'number') {
                totalLength += 4; // uint32 is 4 bytes
            } else if (value instanceof Uint8Array) {
                totalLength += value.length;
            }
        });

        /* Convert each uint32_t to little-endian bytes or append byte arrays */
        const data = new Uint8Array(totalLength);
        let offset = 0;
        values.forEach(value => {
            if (typeof value === 'number') {
                data[offset] = (value >> 0) & 0xFF;
                data[offset + 1] = (value >> 8) & 0xFF;
                data[offset + 2] = (value >> 16) & 0xFF;
                data[offset + 3] = (value >> 24) & 0xFF;
                offset += 4;
            } else if (value instanceof Uint8Array) {
                data.set(value, offset);
                offset += value.length;
            }
        });

        /* Call the original function with the constructed data */
        return this.buildCommandPacket(command, data);
    }

    /**
     * Build raw command packet
     * @param {number} command - Command code
     * @param {Uint8Array} data - Payload
     * @returns {Object} {command, payload: Uint8Array}
     */
    buildCommandPacket(command, data) {
        /* Construct command packet */
        const direction = 0x00;
        const size = data.length;
        let checksum = 0;

        if (size > 32) {
            checksum = 0xEF;
            for (let index = 16; index < size; index++) {
                checksum ^= data[index];
            }
        }

        const packet = new Uint8Array(8 + size);
        packet[0] = direction;
        packet[1] = command;
        packet[2] = size & 0xff;
        packet[3] = (size >> 8) & 0xff;
        packet[4] = checksum & 0xff;
        packet[5] = (checksum >> 8) & 0xff;
        packet[6] = (checksum >> 16) & 0xff;
        packet[7] = (checksum >> 24) & 0xff;
        packet.set(data, 8);

        var ret = {};

        ret.command = command;
        ret.payload = packet;

        return ret;
    }

    /**
     * Debug dump packet to console
     * @param {Object} pkt - Parsed packet
     */
    dumpPacket(pkt) {
        if (!this.devMode) {
            return;
        }

        /* Log command execution with parameters */
        const commandNames = {
            0x02: 'FLASH_BEGIN', 0x03: 'FLASH_DATA', 0x04: 'FLASH_END',
            0x05: 'MEM_BEGIN', 0x06: 'MEM_END', 0x07: 'MEM_DATA',
            0x08: 'SYNC', 0x09: 'WRITE_REG', 0x0a: 'READ_REG',
            0x0b: 'SPI_SET_PARAMS', 0x0d: 'SPI_ATTACH', 0x0f: 'CHANGE_BAUDRATE',
            0x10: 'FLASH_DEFL_BEGIN', 0x11: 'FLASH_DEFL_DATA', 0x12: 'FLASH_DEFL_END',
            0x13: 'SPI_FLASH_MD5', 0x14: 'GET_SECURITY_INFO',
            0xd0: 'ERASE_FLASH', 0xd1: 'ERASE_REGION', 0xd2: 'READ_FLASH', 0xd3: 'RUN_USER_CODE'
        };
        const cmdName = commandNames[packet.command] || `0x${packet.command.toString(16)}`;
        this.logDebug(`[CMD] ${cmdName} (0x${packet.command.toString(16).padStart(2, '0')})`, 'params:', pkt);

        if (pkt.dir == 0) {
            this.logDebug(`Command: `, pkt);
            this.logDebug(`Command raw: ${Array.from(pkt.raw).map(byte => byte.toString(16).padStart(2, '0')).join(' ')}`);
        }
        if (pkt.dir == 1) {
            this.logDebug(`Response: `, pkt);
            this.logDebug(`Response raw: ${Array.from(pkt.raw).map(byte => byte.toString(16).padStart(2, '0')).join(' ')}`);
        }
    }

    /**
     * Parse raw packet bytes
     * @param {Uint8Array} packet - Raw packet data
     * @returns {Object|null} Parsed packet or null if invalid
     */
    parsePacket(packet) {
        var pkt = {};

        pkt.dir = packet[0];
        pkt.command = packet[1];
        pkt.size = packet[2] | (packet[3] << 8);
        pkt.value = (packet[4] | (packet[5] << 8) | (packet[6] << 16) | (packet[7] << 24)) >>> 0;

        if (pkt.dir > 2 || packet.length != 8 + pkt.size) {
            return null;
        }
        pkt.data = packet.slice(8, 8 + pkt.size);
        pkt.raw = packet;

        return pkt;
    }

    /**
     * Process received packet
     * @async
     * @param {Uint8Array} packet - Raw packet bytes
     * @returns {Promise<void>}
     */
    async processPacket(packet) {
        var pkt = this.parsePacket(packet);

        if (pkt && pkt.dir === 0x01) {
            this.dumpPacket(pkt);
            /* Call response handler if registered */
            if (this.responseHandlers.has(pkt.command)) {
                var handler = this.responseHandlers.get(pkt.command);
                await handler(pkt);
            }
        } else {
            //this.logDebug(`Received raw SLIP: ${ Array.from(packet).map(byte => byte.toString(16).padStart(2, '0')).join(' ') }`);

            if (this.responseHandlers.has(-1)) {
                var handler = this.responseHandlers.get(-1);
                await handler(packet);
            }
        }
    }

    /* ==================== MD5 Hash Implementation ==================== */
    /**
     * MD5 Hash Implementation (from js-md5 library)
     * Standalone client-side hashing for data verification
     */
    Md5 = (function () {
        const ARRAY_BUFFER = typeof ArrayBuffer !== 'undefined';
        const HEX_CHARS = '0123456789abcdef'.split('');
        const EXTRA = [128, 32768, 8388608, -2147483648];
        const SHIFT = [0, 8, 16, 24];
        const FINALIZE_ERROR = 'finalize already called';

        let blocks = [], buffer8;
        if (ARRAY_BUFFER) {
            const buffer = new ArrayBuffer(68);
            buffer8 = new Uint8Array(buffer);
            blocks = new Uint32Array(buffer);
        }

        function formatMessage(message) {
            if (typeof message === 'string') {
                return [message, true];
            }
            if (message instanceof ArrayBuffer) {
                return [new Uint8Array(message), false];
            }
            if (message.constructor === Uint8Array || message.constructor === Array) {
                return [message, false];
            }
            return [message, false];
        }

        /**
         * Md5 class
         * @class Md5
         * @description This is internal class.
         * @see {@link md5.create}
         */
        function Md5(sharedMemory) {
            if (sharedMemory) {
                blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                    blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                    blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                    blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                this.blocks = blocks;
                this.buffer8 = buffer8;
            } else {
                if (ARRAY_BUFFER) {
                    var buffer = new ArrayBuffer(68);
                    this.buffer8 = new Uint8Array(buffer);
                    this.blocks = new Uint32Array(buffer);
                } else {
                    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                }
            }
            this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
            this.finalized = this.hashed = false;
            this.first = true;
        }

        /**
         * from https://www.npmjs.com/package/js-md5
         * @method update
         * @memberof Md5
         * @instance
         * @description Update hash
         * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
         * @returns {Md5} Md5 object.
         * @see {@link md5.update}
         */
        Md5.prototype.update = function (message) {
            if (this.finalized) {
                throw new Error(FINALIZE_ERROR);
            }

            var result = formatMessage(message);
            message = result[0];
            var isString = result[1];
            var code, index = 0, i, length = message.length, blocks = this.blocks;
            var buffer8 = this.buffer8;

            while (index < length) {
                if (this.hashed) {
                    this.hashed = false;
                    blocks[0] = blocks[16];
                    blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                }

                if (isString) {
                    if (ARRAY_BUFFER) {
                        for (i = this.start; index < length && i < 64; ++index) {
                            code = message.charCodeAt(index);
                            if (code < 0x80) {
                                buffer8[i++] = code;
                            } else if (code < 0x800) {
                                buffer8[i++] = 0xc0 | (code >>> 6);
                                buffer8[i++] = 0x80 | (code & 0x3f);
                            } else if (code < 0xd800 || code >= 0xe000) {
                                buffer8[i++] = 0xe0 | (code >>> 12);
                                buffer8[i++] = 0x80 | ((code >>> 6) & 0x3f);
                                buffer8[i++] = 0x80 | (code & 0x3f);
                            } else {
                                code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
                                buffer8[i++] = 0xf0 | (code >>> 18);
                                buffer8[i++] = 0x80 | ((code >>> 12) & 0x3f);
                                buffer8[i++] = 0x80 | ((code >>> 6) & 0x3f);
                                buffer8[i++] = 0x80 | (code & 0x3f);
                            }
                        }
                    } else {
                        for (i = this.start; index < length && i < 64; ++index) {
                            code = message.charCodeAt(index);
                            if (code < 0x80) {
                                blocks[i >>> 2] |= code << SHIFT[i++ & 3];
                            } else if (code < 0x800) {
                                blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                            } else if (code < 0xd800 || code >= 0xe000) {
                                blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                            } else {
                                code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
                                blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                            }
                        }
                    }
                } else {
                    if (ARRAY_BUFFER) {
                        for (i = this.start; index < length && i < 64; ++index) {
                            buffer8[i++] = message[index];
                        }
                    } else {
                        for (i = this.start; index < length && i < 64; ++index) {
                            blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];
                        }
                    }
                }
                this.lastByteIndex = i;
                this.bytes += i - this.start;
                if (i >= 64) {
                    this.start = i - 64;
                    this.hash();
                    this.hashed = true;
                } else {
                    this.start = i;
                }
            }
            if (this.bytes > 4294967295) {
                this.hBytes += this.bytes / 4294967296 << 0;
                this.bytes = this.bytes % 4294967296;
            }
            return this;
        };

        /**
         * Finalize hash computation
         * @method finalize
         * @memberof Md5
         * @description Pads message and performs final hash operations
         */
        Md5.prototype.finalize = function () {
            if (this.finalized) {
                return;
            }
            this.finalized = true;
            var blocks = this.blocks, i = this.lastByteIndex;
            blocks[i >>> 2] |= EXTRA[i & 3];
            if (i >= 56) {
                if (!this.hashed) {
                    this.hash();
                }
                blocks[0] = blocks[16];
                blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                    blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                    blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                    blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            }
            blocks[14] = this.bytes << 3;
            blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
            this.hash();
        };

        /**
         * Internal hash computation round
         * @method hash
         * @memberof Md5
         * @description Performs one MD5 hash block computation
         */
        Md5.prototype.hash = function () {
            var a, b, c, d, bc, da, blocks = this.blocks;

            if (this.first) {
                a = blocks[0] - 680876937;
                a = (a << 7 | a >>> 25) - 271733879 << 0;
                d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
                d = (d << 12 | d >>> 20) + a << 0;
                c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;
                c = (c << 17 | c >>> 15) + d << 0;
                b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;
                b = (b << 22 | b >>> 10) + c << 0;
            } else {
                a = this.h0;
                b = this.h1;
                c = this.h2;
                d = this.h3;
                a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;
                a = (a << 7 | a >>> 25) + b << 0;
                d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;
                d = (d << 12 | d >>> 20) + a << 0;
                c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;
                c = (c << 17 | c >>> 15) + d << 0;
                b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;
                b = (b << 22 | b >>> 10) + c << 0;
            }

            a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;
            b = (b << 20 | b >>> 12) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[5] - 378558;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[8] - 2022574463;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[11] + 1839030562;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[14] - 35309556;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[1] - 1530992060;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[4] + 1272893353;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[7] - 155497632;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[10] - 1094730640;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[13] + 681279174;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[0] - 358537222;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[3] - 722521979;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[6] + 76029189;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[9] - 640364487;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[12] - 421815835;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[15] + 530742520;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[2] - 995338651;
            b = (b << 23 | b >>> 9) + c << 0;
            a += (c ^ (b | ~d)) + blocks[0] - 198630844;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[5] - 57434055;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[10] - 1051523;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[15] - 30611744;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[4] - 145523070;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[2] + 718787259;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[9] - 343485551;
            b = (b << 21 | b >>> 11) + c << 0;

            if (this.first) {
                this.h0 = a + 1732584193 << 0;
                this.h1 = b - 271733879 << 0;
                this.h2 = c - 1732584194 << 0;
                this.h3 = d + 271733878 << 0;
                this.first = false;
            } else {
                this.h0 = this.h0 + a << 0;
                this.h1 = this.h1 + b << 0;
                this.h2 = this.h2 + c << 0;
                this.h3 = this.h3 + d << 0;
            }
        };

        /**
         * @method hex
         * @memberof Md5
         * @instance
         * @description Output hash as hex string
         * @returns {String} Hex string
         * @see {@link md5.hex}
         * @example
         * hash.hex();
         */
        Md5.prototype.hex = function () {
            this.finalize();

            var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;

            return HEX_CHARS[(h0 >>> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
                HEX_CHARS[(h0 >>> 12) & 0x0F] + HEX_CHARS[(h0 >>> 8) & 0x0F] +
                HEX_CHARS[(h0 >>> 20) & 0x0F] + HEX_CHARS[(h0 >>> 16) & 0x0F] +
                HEX_CHARS[(h0 >>> 28) & 0x0F] + HEX_CHARS[(h0 >>> 24) & 0x0F] +
                HEX_CHARS[(h1 >>> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
                HEX_CHARS[(h1 >>> 12) & 0x0F] + HEX_CHARS[(h1 >>> 8) & 0x0F] +
                HEX_CHARS[(h1 >>> 20) & 0x0F] + HEX_CHARS[(h1 >>> 16) & 0x0F] +
                HEX_CHARS[(h1 >>> 28) & 0x0F] + HEX_CHARS[(h1 >>> 24) & 0x0F] +
                HEX_CHARS[(h2 >>> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
                HEX_CHARS[(h2 >>> 12) & 0x0F] + HEX_CHARS[(h2 >>> 8) & 0x0F] +
                HEX_CHARS[(h2 >>> 20) & 0x0F] + HEX_CHARS[(h2 >>> 16) & 0x0F] +
                HEX_CHARS[(h2 >>> 28) & 0x0F] + HEX_CHARS[(h2 >>> 24) & 0x0F] +
                HEX_CHARS[(h3 >>> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
                HEX_CHARS[(h3 >>> 12) & 0x0F] + HEX_CHARS[(h3 >>> 8) & 0x0F] +
                HEX_CHARS[(h3 >>> 20) & 0x0F] + HEX_CHARS[(h3 >>> 16) & 0x0F] +
                HEX_CHARS[(h3 >>> 28) & 0x0F] + HEX_CHARS[(h3 >>> 24) & 0x0F];
        };
        return Md5;
    })();
}

/* CommonJS export for Node.js */
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ESPFlasher;
}
    </script>
    <script>
        let flasher = null;
        let selectedFile = null;
        let devicePopupTimer = null;
        let devicePopupContent = '';
        let isDebugMode = window.location.hash.includes('debug');
        let selectedBaudRate = 921600;
        let readStartTime = null;
        let writeStartTime = null;

        // Register presets for each chip type
        const registerPresets = {
            'esp32': [
                { addr: 0x3FF00054, name: 'GPIO_OUT_REG', desc: 'GPIO output register' },
                { addr: 0x3FF0003C, name: 'GPIO_IN_REG', desc: 'GPIO input register' },
                { addr: 0x3FF5A000, name: 'DPORT_PRO_CPU_RECORD_CTRL_REG', desc: 'CPU record control' },
                { addr: 0x3FF480B0, name: 'RTC_CNTL_STORE0_REG', desc: 'RTC control store register 0' },
                { addr: 0x3FF00044, name: 'GPIO_STRAP_REG', desc: 'Bootstrap pin values' },
                { addr: 0x60008800, name: 'EFUSE_BLK0_RDATA0_REG', desc: 'eFuse block 0 word 0' },
                { addr: 0x6000880C, name: 'EFUSE_BLK0_RDATA3_REG', desc: 'eFuse block 0 word 3 (MAC high)' },
                { addr: 0x60008810, name: 'EFUSE_BLK0_RDATA4_REG', desc: 'eFuse block 0 word 4 (MAC low)' }
            ],
            'esp32s2': [
                { addr: 0x3F404004, name: 'GPIO_OUT_REG', desc: 'GPIO output register' },
                { addr: 0x3F40403C, name: 'GPIO_IN_REG', desc: 'GPIO input register' },
                { addr: 0x3F404038, name: 'GPIO_STRAP_REG', desc: 'Bootstrap pin values' },
                { addr: 0x3F41A044, name: 'EFUSE_RD_MAC_SPI_SYS_0_REG', desc: 'MAC address word 0' },
                { addr: 0x3F41A048, name: 'EFUSE_RD_MAC_SPI_SYS_1_REG', desc: 'MAC address word 1' },
                { addr: 0x3F408000, name: 'RTC_CNTL_OPTIONS0_REG', desc: 'RTC control options' },
                { addr: 0x3F41A000, name: 'EFUSE_PGM_DATA0_REG', desc: 'eFuse program data 0' }
            ],
            'esp32s3': [
                { addr: 0x60004004, name: 'GPIO_OUT_REG', desc: 'GPIO output register' },
                { addr: 0x6000403C, name: 'GPIO_IN_REG', desc: 'GPIO input register' },
                { addr: 0x60004038, name: 'GPIO_STRAP_REG', desc: 'Bootstrap pin values' },
                { addr: 0x60007044, name: 'EFUSE_RD_MAC_SPI_SYS_0_REG', desc: 'MAC address word 0' },
                { addr: 0x60007048, name: 'EFUSE_RD_MAC_SPI_SYS_1_REG', desc: 'MAC address word 1' },
                { addr: 0x60008000, name: 'RTC_CNTL_OPTIONS0_REG', desc: 'RTC control options' },
                { addr: 0x6000702C, name: 'EFUSE_RD_REPEAT_DATA1_REG', desc: 'eFuse repeat data 1' }
            ],
            'esp32c3': [
                { addr: 0x60004004, name: 'GPIO_OUT_REG', desc: 'GPIO output register' },
                { addr: 0x6000403C, name: 'GPIO_IN_REG', desc: 'GPIO input register' },
                { addr: 0x60004038, name: 'GPIO_STRAP_REG', desc: 'Bootstrap pin values' },
                { addr: 0x60008844, name: 'EFUSE_RD_MAC_SPI_SYS_0_REG', desc: 'MAC address word 0' },
                { addr: 0x60008848, name: 'EFUSE_RD_MAC_SPI_SYS_1_REG', desc: 'MAC address word 1' },
                { addr: 0x60008000, name: 'RTC_CNTL_OPTIONS0_REG', desc: 'RTC control options' },
                { addr: 0x6000802C, name: 'EFUSE_RD_REPEAT_DATA1_REG', desc: 'eFuse repeat data 1' }
            ],
            'esp32c6': [
                { addr: 0x60091004, name: 'GPIO_OUT_REG', desc: 'GPIO output register' },
                { addr: 0x6009103C, name: 'GPIO_IN_REG', desc: 'GPIO input register' },
                { addr: 0x60091038, name: 'GPIO_STRAP_REG', desc: 'Bootstrap pin values' },
                { addr: 0x600B0844, name: 'EFUSE_RD_MAC_SPI_SYS_0_REG', desc: 'MAC address word 0' },
                { addr: 0x600B0848, name: 'EFUSE_RD_MAC_SPI_SYS_1_REG', desc: 'MAC address word 1' },
                { addr: 0x60008000, name: 'LP_CLKRST_LP_CLK_CONF_REG', desc: 'Low power clock config' },
                { addr: 0x600B002C, name: 'EFUSE_RD_REPEAT_DATA1_REG', desc: 'eFuse repeat data 1' }
            ]
        };

        function updateRegisterPresets(chipType) {
            const presetSelect = document.getElementById('regPreset');
            presetSelect.innerHTML = '<option value="">-- Select a register --</option>';

            if (chipType && chipType !== 'none' && chipType !== 'unknown' && registerPresets[chipType]) {
                const presets = registerPresets[chipType];
                presets.forEach(preset => {
                    const option = document.createElement('option');
                    option.value = JSON.stringify(preset);
                    option.textContent = `${preset.name} (0x${preset.addr.toString(16).toUpperCase()})`;
                    presetSelect.appendChild(option);
                });
                log(`Loaded ${presets.length} register presets for ${chipType}`, 'debug');
            }
        }

        function loadRegisterPreset() {
            const presetSelect = document.getElementById('regPreset');
            const selectedValue = presetSelect.value;

            if (selectedValue) {
                const preset = JSON.parse(selectedValue);
                document.getElementById('regAddress').value = '0x' + preset.addr.toString(16).toUpperCase();
                document.getElementById('regDescRow').style.display = 'flex';
                document.getElementById('regDesc').textContent = preset.desc;
                log(`Selected register: ${preset.name}`, 'info');
            } else {
                document.getElementById('regDescRow').style.display = 'none';
            }
        }

        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLog() {
            const logContainer = document.getElementById('logContainer');
            logContainer.innerHTML = '<div class="log-entry log-info">Log cleared.</div>';
        }

        function showDevicePopup(message, state = null) {
            const popup = document.getElementById('devicePopup');
            if (!popup) {
                return;
            }

            if (popup.style.display !== 'none' && devicePopupContent) {
                devicePopupContent += '\n' + message;
            } else {
                devicePopupContent = message;
            }

            popup.innerHTML = '<strong>Device Info</strong><br>' + devicePopupContent.replace(/\n/g, '<br>');
            if (state === 'secure') {
                popup.classList.add('secure-warning');
            } else {
                popup.classList.remove('secure-warning');
            }
            popup.style.display = 'block';

            if (devicePopupTimer) {
                clearTimeout(devicePopupTimer);
            }
            devicePopupTimer = setTimeout(() => {
                popup.style.display = 'none';
                devicePopupContent = '';
            }, 5000);
        }

        function formatDeviceStateMessage(state, data) {
            if (state === 'secure') {
                return '‚ö†Ô∏è Warning: Device is secured, this tool won\'t work with it';
            }
            if (state === 'download') {
                return 'Device waiting for download (ROM bootloader)';
            }
            if (state === 'reboot' && data) {
                const rstHex = '0x' + (data.rst ?? 0).toString(16);
                const rstName = data.rstName || 'UNKNOWN';
                const bootHex = '0x' + (data.boot ?? 0).toString(16);
                return `Reboot: ${rstName} (${rstHex}), boot=${bootHex}`;
            }
            return `Device state: ${state}`;
        }

        function updateStatus(status, badge = 'disconnected') {
            const statusEl = document.getElementById('connectionStatus');
            const badgeClass = `status-${badge}`;
            const badgeText = badge === 'connected' ? 'ONLINE' : badge === 'busy' ? 'BUSY' : badge === 'warning' ? 'PROBLEM' : 'OFFLINE';
            statusEl.innerHTML = `${status}<span class="status-badge ${badgeClass}">${badgeText}</span>`;
        }

        function updateButtons(connected = false, synced = false, stubLoaded = false) {
            document.getElementById('connectBtn').disabled = connected;
            document.getElementById('disconnectBtn').disabled = !connected;
            document.getElementById('hardResetBtn').disabled = !connected;
            document.getElementById('appResetBtn').disabled = !connected;
            document.getElementById('syncBtn').disabled = !connected;
            document.getElementById('loadStubBtn').disabled = !synced || stubLoaded;
            document.getElementById('readRegBtn').disabled = !synced;
            document.getElementById('writeFlashBtn').disabled = !selectedFile || !stubLoaded;
            document.getElementById('readFlashBtn').disabled = !stubLoaded;
            document.getElementById('md5FlashBtn').disabled = !stubLoaded;
            document.getElementById('testReliabilityBtn').disabled = !synced;
            document.getElementById('blankCheckBtn').disabled = !stubLoaded;
            document.getElementById('writeReadTestBtn').disabled = !stubLoaded;
            document.getElementById('stubStatus').textContent = stubLoaded ? 'Loaded' : 'Not loaded';

            // Update tooltips
            const writeBtn = document.getElementById('writeFlashBtn');
            const readBtn = document.getElementById('readFlashBtn');
            const md5Btn = document.getElementById('md5FlashBtn');
            const blankBtn = document.getElementById('blankCheckBtn');
            const testBtn = document.getElementById('writeReadTestBtn');

            if (!stubLoaded) {
                writeBtn.title = 'Load stub loader first';
                readBtn.title = 'Load stub loader first';
                md5Btn.title = 'Load stub loader first';
                blankBtn.title = 'Load stub loader first';
                testBtn.title = 'Load stub loader first';
            } else if (!selectedFile) {
                writeBtn.title = 'Select a binary file first';
                readBtn.title = 'Read data from flash and download as binary';
                md5Btn.title = 'Calculate MD5 hash of flash region';
                blankBtn.title = 'Check if flash is blank';
                testBtn.title = 'Write random data and verify readback';
            } else {
                writeBtn.title = 'Write binary to flash';
                readBtn.title = 'Read data from flash and download as binary';
                md5Btn.title = 'Calculate MD5 hash of flash region';
                blankBtn.title = 'Check if flash is blank';
                testBtn.title = 'Write random data and verify readback';
            }
        }

        function setupAdvancedControls() {
            const group = document.getElementById('baudSelectGroup');
            const select = document.getElementById('baudRateSelect');

            if (!group || !select) {
                return;
            }

            if (!isDebugMode) {
                group.style.display = 'none';
                return;
            }

            group.style.display = 'block';
            select.value = selectedBaudRate.toString();

            select.addEventListener('change', () => {
                const nextBaud = parseInt(select.value, 10);
                if (!Number.isFinite(nextBaud)) {
                    return;
                }
                selectedBaudRate = nextBaud;
                if (flasher) {
                    flasher.initialBaudRate = selectedBaudRate;
                }
                log(`Baud rate set to ${selectedBaudRate} (applies to next open)`, 'info');
            });

            log('Advanced mode enabled: baud selector available', 'info');
        }

        async function connectDevice() {
            try {
                const connectionType = document.querySelector('input[name="connectionType"]:checked').value;

                log(`Requesting ${connectionType === 'webusb' ? 'WebUSB' : 'Web Serial'} port...`, 'info');
                flasher = new ESPFlasher();
                flasher.initialBaudRate = selectedBaudRate;
                flasher.logMessage = (msg) => log(msg, 'info');

                if (isDebugMode) {
                    flasher.logPackets = true;
                    flasher.logDebug = (msg) => {
                        log(`[DEBUG] ${msg}`, 'debug');
                        console.log(`[Flasher DEBUG] ${msg}`);
                    };
                }
                flasher.logError = (msg, detail = '') => log(`[ERROR] ${msg} ${detail}`, 'error');

                flasher.deviceStateCallback = (state, data) => {
                    const msg = formatDeviceStateMessage(state, data);
                    showDevicePopup(msg, state);
                    log(`Device state: ${msg}`, 'info');
                };

                flasher.disconnected = () => {
                    log('Device disconnected', 'warn');
                    updateStatus('Disconnected', 'disconnected');
                    updateButtons(false, false, false);
                    document.getElementById('chipType').textContent = 'Not detected';
                    document.getElementById('macAddress').textContent = '--:--:--:--:--:--';
                    document.getElementById('stubStatus').textContent = 'Not loaded';
                    const popup = document.getElementById('devicePopup');
                    if (popup) {
                        popup.style.display = 'none';
                    }
                    devicePopupContent = '';
                    if (devicePopupTimer) {
                        clearTimeout(devicePopupTimer);
                        devicePopupTimer = null;
                    }
                };

                if (connectionType === 'webusb') {
                    // Use WebUSB
                    const port = await WebUSBSerial.requestPort();
                    await flasher.openPortWithPort(port);
                } else {
                    // Use Web Serial
                    await flasher.openPort();
                }

                log('Port opened successfully', 'info');

                if (!flasher.isEspressifUsbJtag) {
                    // Technical limitation note about baud rate and ROM messages
                    log('Note: Web Serial cannot change baud rate without reopening; to avoid unintended resets we keep one baud from start to end. The ROM prints reset messages at 115200. With USB-UART RX/TX wiring you must choose: slow baud (115200) to see reset messages, or high baud (e.g., 921600) to get speed but miss those messages.', 'warn');
                }
                updateStatus('Connected', 'connected');

                updateButtons(true, false, false);

                // Highlight Hard Reset button to indicate next step
                const hardResetBtn = document.getElementById('hardResetBtn');
                hardResetBtn.classList.add('highlighted');
                log('Please click "Hard Reset" to continue...', 'info');

            } catch (error) {
                log(`Failed to connect: ${error.message}`, 'error');
                updateStatus('Connection failed', 'disconnected');
            }
        }

        async function hardReset() {
            if (!flasher) return;
            try {
                const hardResetBtn = document.getElementById('hardResetBtn');
                hardResetBtn.classList.remove('highlighted');

                updateStatus('Performing reset (download mode)...', 'busy');
                log('Initiating reset to download mode...', 'info');
                const result = await flasher.hardReset(true);
                if (result) {
                    log('Reset to download mode successful', 'info');
                } else {
                    log('Reset failed or not supported', 'warn');
                }
                updateStatus('Connected', 'connected');

                // Highlight Sync button for next step
                const syncBtn = document.getElementById('syncBtn');
                syncBtn.classList.add('highlighted');
                log('Please click "Sync & Detect" to continue...', 'info');


            } catch (error) {
                log(`Reset error: ${error.message}`, 'error');
                updateStatus('Connected (Error)', 'warning');
            }
        }

        async function appReset() {
            if (!flasher) return;
            try {
                updateStatus('Performing reset (application mode)...', 'busy');
                log('Initiating reset to application mode...', 'info');
                const result = await flasher.hardReset(false);
                if (result) {
                    log('Reset to application mode successful', 'info');
                } else {
                    log('Reset failed or not supported', 'warn');
                }
                updateStatus('Connected', 'connected');
            } catch (error) {
                log(`Reset error: ${error.message}`, 'error');
                updateStatus('Connected (Error)', 'warning');
            }
        }

        async function syncDevice() {
            if (!flasher) return;
            try {
                const syncBtn = document.getElementById('syncBtn');
                syncBtn.classList.remove('highlighted');

                updateStatus('Syncing with device...', 'busy');
                log('Starting sync process...', 'info');
                await flasher.sync();
                log(`Sync successful! Detected chip: ${flasher.current_chip}`, 'info');
                document.getElementById('chipType').textContent = flasher.current_chip;

                // Update register presets based on detected chip
                updateRegisterPresets(flasher.current_chip);

                // Read MAC address
                const mac = await flasher.readMac();
                if (mac) {
                    log(`MAC Address: ${mac}`, 'info');
                    document.getElementById('macAddress').textContent = mac;
                }

                updateStatus('Connected & Synced', 'connected');
                updateButtons(true, true, await flasher.isStubLoader());
            } catch (error) {
                log(`Sync failed: ${error.message}`, 'error');
                updateStatus('Connected (Sync Failed)', 'warning');
                const syncBtn = document.getElementById('syncBtn');
                syncBtn.classList.remove('highlighted');
            }
        }

        async function disconnectDevice() {
            if (!flasher) return;
            try {
                await flasher.disconnect();
                log('Disconnected successfully', 'info');
                updateStatus('Disconnected', 'disconnected');
                updateButtons(false, false, false);

                // Clear any highlights
                document.getElementById('hardResetBtn').classList.remove('highlighted');
                document.getElementById('appResetBtn').classList.remove('highlighted');
                document.getElementById('syncBtn').classList.remove('highlighted');

                const popup = document.getElementById('devicePopup');
                if (popup) {
                    popup.style.display = 'none';
                }
                devicePopupContent = '';
                if (devicePopupTimer) {
                    clearTimeout(devicePopupTimer);
                    devicePopupTimer = null;
                }
            } catch (error) {
                log(`Disconnect error: ${error.message}`, 'error');
            }
        }

        async function loadStub() {
            if (!flasher) return;
            try {
                updateStatus('Loading stub...', 'busy');
                log('Loading stub loader...', 'info');
                const result = await flasher.downloadStub();
                if (result) {
                    log('Stub loaded successfully!', 'info');
                    updateButtons(true, true, await flasher.isStubLoader());
                } else {
                    log('Failed to load stub', 'error');
                }
                updateStatus('Connected & Synced', 'connected');
            } catch (error) {
                log(`Stub load error: ${error.message}`, 'error');
                updateStatus('Connected (Stub Failed)', 'warning');
            }
        }

        async function readRegister() {
            if (!flasher) return;
            try {
                const address = parseInt(document.getElementById('regAddress').value);
                log(`Reading register at 0x${address.toString(16).padStart(8, '0')}...`, 'info');
                const value = await flasher.readReg(address);
                const hexValue = '0x' + value.toString(16).padStart(8, '0').toUpperCase();
                log(`Register value: ${hexValue} (${value})`, 'info');
                document.getElementById('regValue').textContent = `${hexValue} (${value})`;
            } catch (error) {
                log(`Read register error: ${error.message}`, 'error');
            }
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                selectedFile = file;
                const fileInfo = document.getElementById('fileInfo');
                const sizeKB = (file.size / 1024).toFixed(2);
                fileInfo.textContent = `Selected: ${file.name} (${sizeKB} KB)`;
                fileInfo.style.display = 'block';
                log(`File selected: ${file.name} (${sizeKB} KB)`, 'info');

                // Update button states with current flasher status
                if (flasher && flasher.current_chip !== 'none') {
                    updateButtons(true, true, await flasher.isStubLoader());
                }
            }
        }

        async function writeFlash() {
            if (!flasher || !selectedFile) return;
            try {
                const address = parseInt(document.getElementById('flashAddress').value);
                log(`Reading file data...`, 'info');

                const arrayBuffer = await selectedFile.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);

                log(`Writing ${data.length} bytes to flash at 0x${address.toString(16).padStart(8, '0')}...`, 'info');
                updateStatus('Writing flash...', 'busy');

                const progressBar = document.getElementById('flashProgress');
                progressBar.style.transition = 'none'; // Disable smooth transition
                writeStartTime = Date.now();

                await flasher.writeFlash(address, data, (offset, total, status) => {
                    const percent = Math.round((offset / total) * 100);
                    let text = `${percent}% (${status})`;

                    /* Calculate speed if operation has been running > 1 second */
                    if (writeStartTime) {
                        const elapsedMs = Date.now() - writeStartTime;
                        if (elapsedMs > 1000 && offset > 0) {
                            const speedBytesPerSec = (offset / elapsedMs) * 1000;
                            const speedKiBPerSec = Math.round(speedBytesPerSec / 1024);
                            text += ` - ${speedKiBPerSec} KiB/s`;
                        }
                    }
                    progressBar.style.width = percent + '%';
                    progressBar.textContent = text;
                });

                progressBar.style.width = '100%';
                progressBar.textContent = '100%';
                writeStartTime = null;
                log('Flash write completed successfully!', 'info');
                updateStatus('Connected & Synced', 'connected');

                setTimeout(() => {
                    progressBar.style.width = '0%';
                    progressBar.textContent = '0%';
                }, 3000);
            } catch (error) {
                log(`Flash write error: ${error.message}`, 'error');
                updateStatus('Connected (Write Failed)', 'warning');
            }
        }

        async function calculateMD5() {
            if (!flasher) return;
            try {
                const address = parseInt(document.getElementById('flashAddress').value);
                const size = parseInt(document.getElementById('flashSize').value);

                log(`Calculating MD5 hash for ${size} bytes at 0x${address.toString(16).padStart(8, '0')}...`, 'info');
                updateStatus('Calculating MD5...', 'busy');

                const md5Hash = await flasher.checksumFlash(address, size);

                log(`MD5 hash: ${md5Hash}`, 'info');
                document.getElementById('md5Value').textContent = md5Hash;
                document.getElementById('md5Row').style.display = 'flex';

                updateStatus('Connected & Synced', 'connected');
            } catch (error) {
                log(`MD5 calculation error: ${error.message}`, 'error');
                updateStatus('Connected (MD5 Failed)', 'warning');
                document.getElementById('md5Value').textContent = 'Error';
                document.getElementById('md5Row').style.display = 'flex';
            }
        }

        async function readFlash() {
            if (!flasher) return;
            try {
                const address = parseInt(document.getElementById('flashAddress').value);
                const totalSize = parseInt(document.getElementById('flashSize').value);

                log(`Reading ${totalSize} bytes from flash at 0x${address.toString(16).padStart(8, '0')} with MD5 verification...`, 'info');
                updateStatus('Reading flash...', 'busy');

                const progressBar = document.getElementById('flashProgress');
                progressBar.style.transition = 'none'; // Disable smooth transition
                readStartTime = Date.now();

                // Use readFlash which handles MD5 verification
                const allData = await flasher.readFlash(address, totalSize, (offset, size, status) => {
                    // Update progress
                    const percent = Math.round((offset / size) * 100);
                    let text = `${percent}% (${status})`;

                    /* Calculate speed if operation has been running > 1 second */
                    if (readStartTime) {
                        const elapsedMs = Date.now() - readStartTime;
                        if (elapsedMs > 1000 && offset > 0) {
                            const speedBytesPerSec = (offset / elapsedMs) * 1000;
                            const speedKiBPerSec = Math.round(speedBytesPerSec / 1024);
                            text += ` - ${speedKiBPerSec} KiB/s`;
                        }
                    }
                    progressBar.style.width = percent + '%';
                    progressBar.textContent = text;

                    if (offset % (0x1000 * 10) === 0) {
                        log(`Read ${offset} / ${size} bytes (${percent}%)`, 'debug');
                    }
                });

                progressBar.style.width = '100%';
                progressBar.textContent = '100% - Verified ‚úì';
                readStartTime = null;

                // Download the data as a binary file
                const blob = new Blob([allData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `flash_dump_0x${address.toString(16)}_${totalSize}bytes.bin`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                log(`Read ${totalSize} bytes successfully with MD5 verification and saved to file`, 'info');
                updateStatus('Connected & Synced', 'connected');

                setTimeout(() => {
                    progressBar.style.width = '0%';
                    progressBar.textContent = '0%';
                }, 3000);
            } catch (error) {
                log(`Flash read error: ${error.message}`, 'error');
                updateStatus('Connected (Read Failed)', 'warning');
            }
        }

        async function testReliability() {
            if (!flasher) return;
            try {
                log('Starting reliability test (1 second)...', 'info');
                updateStatus('Testing reliability...', 'busy');
                document.getElementById('testResult').textContent = 'Testing...';

                const progressBar = document.getElementById('testProgress');
                progressBar.style.transition = 'none'; // Disable smooth transition

                const result = await flasher.testReliability((progress) => {
                    progressBar.style.width = progress + '%';
                    progressBar.textContent = Math.round(progress) + '%';
                });

                progressBar.style.width = '100%';
                progressBar.textContent = '100%';

                if (result) {
                    log('Reliability test PASSED', 'info');
                    document.getElementById('testResult').textContent = '‚úì PASSED';
                    document.getElementById('testResult').style.color = '#2e7d32';
                } else {
                    log('Reliability test FAILED', 'error');
                    document.getElementById('testResult').textContent = '‚úó FAILED';
                    document.getElementById('testResult').style.color = '#c62828';
                }

                updateStatus('Connected & Synced', 'connected');

                setTimeout(() => {
                    document.getElementById('testProgress').style.width = '0%';
                    document.getElementById('testProgress').textContent = '0%';
                }, 3000);
            } catch (error) {
                log(`Reliability test error: ${error.message}`, 'error');
                document.getElementById('testResult').textContent = '‚úó ERROR';
                document.getElementById('testResult').style.color = '#c62828';
                updateStatus('Connected (Test Failed)', 'warning');
            }
        }

        async function blankCheck() {
            if (!flasher) return;
            try {
                const address = parseInt(document.getElementById('testAddress').value);
                const size = parseInt(document.getElementById('testSize').value);
                log('Starting blank check (this may take a while)...', 'info');
                updateStatus('Checking flash...', 'busy');

                const progressBar = document.getElementById('testProgress');
                progressBar.style.transition = 'none'; // Disable smooth transition

                await flasher.blankCheck(address, size, (current, start, end, blockSize, erased, totalErased) => {
                    const progress = ((current - start) / (end - start)) * 100;
                    progressBar.style.width = progress + '%';
                    progressBar.textContent = Math.round(progress) + '%';

                    if (Math.round(progress) % 10 === 0) {
                        const percentErased = (totalErased / current) * 100;
                        log(`Progress: ${Math.round(progress)}% | Erased: ${percentErased.toFixed(1)}%`, 'debug');
                    }
                });

                log('Blank check completed', 'info');
                updateStatus('Connected & Synced', 'connected');
            } catch (error) {
                log(`Blank check error: ${error.message}`, 'error');
                updateStatus('Connected (Check Failed)', 'warning');
            }
        }

        async function writeReadTest() {
            if (!flasher) return;
            try {
                const address = parseInt(document.getElementById('testAddress').value);
                const size = parseInt(document.getElementById('testSize').value);

                log(`Starting Write/Read test at 0x${address.toString(16).padStart(8, '0')}, size: ${size} bytes`, 'info');
                updateStatus('Running Write/Read test...', 'busy');
                document.getElementById('testResult').textContent = 'Testing...';
                document.getElementById('testDetailsRow').style.display = 'none';

                const progressBar = document.getElementById('testProgress');
                progressBar.style.transition = 'none';

                const result = await flasher.writeReadTest(address, size, (stage, current, total, percent = 0, data = null) => {
                    if (stage === 'reading_original') {
                        progressBar.style.width = '10%';
                        progressBar.textContent = 'Reading original...';
                    } else if (stage === 'generating_random') {
                        progressBar.style.width = '20%';
                        progressBar.textContent = 'Generating random...';
                    } else if (stage === 'writing') {
                        const writeProgress = 20 + (percent * 0.5); // 20-70%
                        progressBar.style.width = writeProgress + '%';
                        progressBar.textContent = `Writing... ${percent}%`;
                    } else if (stage === 'reading_back') {
                        progressBar.style.width = '80%';
                        progressBar.textContent = 'Reading back...';
                    } else if (stage === 'complete') {
                        progressBar.style.width = '100%';
                        progressBar.textContent = '100%';

                        if (data && data.success) {
                            log(`‚úì Write/Read test PASSED: All ${size} bytes verified!`, 'info');
                            document.getElementById('testResult').textContent = '‚úì PASSED';
                            document.getElementById('testResult').style.color = '#2e7d32';
                            document.getElementById('testDetailsRow').style.display = 'flex';
                            document.getElementById('testDetails').textContent = `All ${size} bytes matched after write/read cycle`;
                        } else if (data && !data.success) {
                            log(`‚úó Write/Read test FAILED: ${data.errors} byte(s) mismatch`, 'error');
                            document.getElementById('testResult').textContent = '‚úó FAILED';
                            document.getElementById('testResult').style.color = '#c62828';
                            document.getElementById('testDetailsRow').style.display = 'flex';
                            document.getElementById('testDetails').textContent = `${data.errors} byte(s) mismatch. First error at offset 0x${data.firstError.toString(16)}`;
                        }
                    } else if (stage === 'error') {
                        progressBar.style.width = '0%';
                        progressBar.textContent = '0%';
                    }
                });

                updateStatus('Connected & Synced', 'connected');

                setTimeout(() => {
                    progressBar.style.width = '0%';
                    progressBar.textContent = '0%';
                }, 5000);
            } catch (error) {
                log(`Write/Read test error: ${error.message}`, 'error');
                document.getElementById('testResult').textContent = '‚úó ERROR';
                document.getElementById('testResult').style.color = '#c62828';
                document.getElementById('testDetailsRow').style.display = 'flex';
                document.getElementById('testDetails').textContent = error.message;
                updateStatus('Connected (Test Failed)', 'warning');
            }
        }

        function toggleDebugMode() {
            if (flasher) {
                flasher.devMode = !flasher.devMode;
                log(`Debug mode ${flasher.devMode ? 'ENABLED' : 'DISABLED'}`, 'info');
            } else {
                log('Connect to a device first', 'warn');
            }
        }

        // Initialize
        window.onload = () => {
            log('ESP32 Flasher Test Suite initialized', 'info');
            log('Supported chips: ESP32, ESP32-S2, ESP32-S3, ESP32-C3, ESP32-C6', 'info');
            updateButtons(false, false, false);
            setupAdvancedControls();
        };
    </script>
</body>

</html>
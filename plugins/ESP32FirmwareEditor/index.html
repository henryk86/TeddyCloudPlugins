<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Firmware Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            color: #d4d4d4;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1f35 0%, #1c1424 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1900px;
            margin: 0 auto;
            background: #2a2a2a;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #3d4a7a 0%, #2d1f3d 100%);
            color: #e0e0e0;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .drop-zone {
            border: 3px dashed #5a6bb8;
            border-radius: 10px;
            padding: 10px 10px;
            text-align: center;
            background: #333333;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }

        .drop-zone:hover {
            background: #3a3f5a;
            border-color: #7a6bb8;
        }

        .drop-zone.drag-over {
            background: #404560;
            border-color: #8a7bc8;
            transform: scale(1.02);
        }

        .drop-zone i {
            font-size: 4em;
            color: #7a8bdc;
            margin-bottom: 20px;
            display: block;
        }

        .drop-zone p {
            font-size: 1.2em;
            color: #a0a0a0;
            margin: 10px 0;
        }

        .drop-zone .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #5a6bb8 0%, #6a5294 100%);
            color: #e8e8e8;
            border: none;
            padding: 12px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(90, 107, 184, 0.5);
        }

        .file-info {
            background: #333333;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .file-info.visible {
            display: block;
        }

        .file-info h3 {
            color: #7a8bdc;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: #252525;
            padding: 5px 8px;
            border-radius: 5px;
            border-left: 3px solid #5a6bb8;
        }

        .info-item label {
            font-weight: bold;
            color: #9a9a9a;
            font-size: 0.9em;
            display: block;
            margin-bottom: 5px;
        }

        .info-item span {
            color: #c8c8c8;
            font-size: 1em;
            word-break: break-all;
        }

        .size-selector {
            cursor: pointer;
            text-decoration: underline dotted;
            color: #6ec589;
        }

        .size-selector:hover {
            color: #8bf0a8;
        }

        .size-select {
            background: #252525;
            color: #c8c8c8;
            border: 1px solid #5a6bb8;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 0.95em;
            outline: none;
        }

        .size-select:focus {
            border-color: #8bf0a8;
            box-shadow: 0 0 0 2px rgba(139, 240, 168, 0.2);
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid #404040;
            margin-bottom: 20px;
            gap: 10px;
        }

        .tab {
            padding: 15px 30px;
            background: #2a2a2a;
            border: none;
            cursor: pointer;
            font-size: 1em;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s ease;
        }

        .tab:hover {
            background: #3a3a3a;
        }

        .tab.active {
            background: linear-gradient(135deg, #3d4565 0%, #3a2e4a 100%);
            color: #e8e8e8;
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: #2d2d2d;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        th {
            background: linear-gradient(135deg, #3d4565 0%, #3a2e4a 100%);
            color: #e0e0e0;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 4px 4px;
            border-bottom: 1px solid #404040;
        }

        tr:hover {
            background: #383840;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .fat-file-row {
            cursor: pointer;
        }

        .fat-file-row:hover {
            background: #3d3e48;
            box-shadow: inset 0 0 10px rgba(100, 100, 255, 0.2);
        }

        .delete-btn {
            background: #ff4444;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            padding: 0;
            transition: background 0.2s;
        }

        .delete-btn:hover {
            background: #ff6666;
        }

        .add-btn {
            background: #44cc44;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            line-height: 1;
            padding: 0;
            transition: background 0.2s;
        }

        .add-btn:hover {
            background: #66ee66;
        }

        .expandable {
            cursor: pointer;
        }

        .expandable:hover {
            background: #3d3e48;
        }

        .details-row {
            display: none;
            background: #333338;
        }

        .details-row.visible {
            display: table-row;
        }

        .details-content {
            padding: 15px;
            border-left: 3px solid #5a6bb8;
        }

        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
        }

        .detail-item {
            background: #3a3a3a;
            padding: 4px 8px;
            border-radius: 5px;
        }

        .detail-item strong {
            color: #7a8bdc;
            display: block;
            margin-bottom: 5px;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
            background: #404040;
        }

        .badge.app {
            color: #6b9aeb;
        }

        .badge.data {
            color: #b883d8;
        }

        .badge.nvs {
            color: #f39c63;
        }

        .badge.fat {
            color: #6ec589;
        }

        .code-block {
            background: #1e1e1e;
            color: #7a8bdc;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin: 10px 0;
        }

        .nvs-namespace {
            background: linear-gradient(90deg, #5a6bb8 0%, #6a5294 100%);
            color: #e8e8e8;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 5px;
            font-weight: bold;
        }

        .nvs-item {
            background: #2d2d2d;
            padding: 5px 8px;
            margin: 5px 0;
            border-left: 3px solid #5a6bb8;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .nvs-item:hover {
            background: #353535;
        }

        .nvs-item .mono {
            word-break: break-all;
            display: inline-block;
            max-width: calc(100% - 100px);
        }

        .nvs-item.crc-bad {
            border-left-color: #e57373;
            background: #3a2b2b;
        }

        .nvs-delete-btn {
            background: #c05050;
            color: #ffffff;
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            position: absolute;
            right: 8px;
            top: 8px;
        }

        .nvs-delete-btn:hover {
            background: #d06060;
        }

        .nvs-add-btn {
            background: #5a6bb8;
            color: #ffffff;
            border: none;
            padding: 4px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 8px;
        }

        .nvs-add-btn:hover {
            background: #6a7bc8;
        }

        .nvs-edit-btn {
            background: #63d437;
            color: #ffffff;
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            position: absolute;
            right: 40px;
            top: 8px;
        }

        .nvs-edit-btn:hover {
            background: #e0af47;
        }

        .nvs-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 2px solid #5a6bb8;
            border-radius: 8px;
            padding: 20px;
            z-index: 10001;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            min-width: 400px;
        }

        .nvs-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
        }

        .nvs-popup h3 {
            margin-bottom: 15px;
            color: #7a8bdc;
        }

        .nvs-popup label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
            color: #c8c8c8;
        }

        .nvs-popup input,
        .nvs-popup select {
            width: 100%;
            padding: 8px;
            border: 1px solid #5a6bb8;
            border-radius: 4px;
            background: #333333;
            color: #d4d4d4;
            font-size: 1em;
        }

        .nvs-popup-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .crc-info {
            font-size: 0.85em;
            color: #b0b0b0;
            margin-top: 4px;
        }

        .crc-info .bad {
            color: #e57373;
            font-weight: 600;
        }

        .crc-info .ok {
            color: #81c784;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7a8bdc;
            font-size: 1.2em;
        }

        .error {
            background: #3d1f1f;
            color: #e88888;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #c05050;
            margin: 10px 0;
        }

        .success {
            background: #1f3d24;
            color: #88d899;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #50a05e;
            margin: 10px 0;
        }

        .mono {
            font-family: 'Courier New', monospace;
            background: #3a3a3a;
            color: #d0d0d0;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .download-btn {
            background: #4d8f52;
            color: #e8e8e8;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
        }

        .download-btn:hover {
            background: #5aa05e;
        }

        .replace-btn {
            background: #8f4d4d;
            color: #e8e8e8;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
        }

        .replace-btn:hover {
            background: #a05a5a;
        }

        .hex-btn {
            background: #5a6bb8;
            color: #e8e8e8;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
        }

        .hex-btn:hover {
            background: #6a7bc8;
        }

        .hex-viewer {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .hex-line {
            display: flex;
            margin: 2px 0;
        }

        .hex-offset {
            color: #7a8bb8;
            margin-right: 15px;
            min-width: 80px;
        }

        .hex-bytes {
            color: #88d899;
            margin-right: 15px;
            flex: 1;
        }

        .hex-ascii {
            color: #d4a574;
        }

        .hex-controls {
            background: #3a3a3a;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .hex-controls label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .hex-controls input {
            width: 100%;
            padding: 8px;
            border: 1px solid #5a5a5a;
            border-radius: 4px;
            background: #2a2a2a;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
        }

        /* Fetch overlay */
        #fetchOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .fetch-overlay-box {
            background: #1f1f1f;
            color: #e0e0e0;
            padding: 20px 28px;
            border-radius: 10px;
            border: 1px solid #444;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
            text-align: center;
            min-width: 260px;
        }

        .fetch-overlay-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .fetch-overlay-text {
            font-size: 14px;
            color: #c9d1d9;
        }

        /* Import popup */
        #importPopup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .import-popup-box {
            background: #2a2a2a;
            color: #e0e0e0;
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #5a6bb8;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            min-width: 500px;
            max-width: 600px;
        }

        .import-popup-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #7a8bdc;
        }

        .import-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #444;
        }

        .import-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .import-tab:hover {
            color: #c9d1d9;
        }

        .import-tab.active {
            color: #7a8bdc;
            border-bottom-color: #7a8bdc;
        }

        .import-tab-content {
            display: none;
        }

        .import-tab-content.active {
            display: block;
        }

        .import-drop-zone {
            border: 2px dashed #5a6bb8;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            background: #333;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .import-drop-zone:hover {
            background: #3a3f5a;
            border-color: #7a6bb8;
        }

        .import-drop-zone.drag-over {
            background: #404560;
            border-color: #8a7bc8;
        }

        .import-field {
            margin-bottom: 20px;
        }

        .import-field label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #c9d1d9;
        }

        .import-field input {
            width: 100%;
            padding: 10px;
            background: #1f1f1f;
            border: 1px solid #444;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }

        .import-preview {
            background: #1f1f1f;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #444;
            margin-bottom: 20px;
            min-height: 80px;
        }

        .import-preview-label {
            font-weight: 600;
            margin-bottom: 10px;
            color: #7a8bdc;
        }

        .import-preview-info {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .import-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Write overlay (red accent) */
        #writeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .write-overlay-box {
            background: #2a1f1f;
            color: #e0e0e0;
            padding: 20px 28px;
            border-radius: 10px;
            border: 1px solid #c44;
            box-shadow: 0 10px 30px rgba(200, 50, 50, 0.45);
            text-align: center;
            min-width: 260px;
        }

        .write-overlay-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #ff6b6b;
        }

        .write-overlay-text {
            font-size: 14px;
            color: #ffcccc;
        }

        /* Device status display */
        #deviceStatusText {
            font-size: 14px;
            padding: 15px;
            border-radius: 5px;
            background: #252525;
            border-left: 4px solid #6ec589;
            word-break: break-word;
            white-space: pre-wrap;
        }

        #deviceStatusText.success {
            border-left-color: #6ec589;
            color: #a8e6b8;
        }

        #deviceStatusText.error {
            border-left-color: #ff6b6b;
            background: #3a2020;
            color: #ffb3b3;
        }

        #deviceStatusText.loading {
            border-left-color: #5a8fd8;
            background: #202540;
            color: #7aafff;
        }

        /* Memory map visualization */
        #memoryMapContainer {
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            display: none;
        }

        #memoryMapContainer h4 {
            margin: 0 0 10px 0;
            color: #7a8bdc;
            font-size: 14px;
        }

        #memoryMap {
            width: 100%;
            height: 40px;
            background: #1a1a1a;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            border: 1px solid #444;
        }

        .memory-segment {
            position: absolute;
            height: 100%;
            top: 0;
            transition: all 0.3s ease;
        }

        .memory-segment.unread {
            background: #3a3a3a;
        }

        .memory-segment.cached {
            background: linear-gradient(180deg, #4CAF50 0%, #2e7d32 100%);
        }

        .memory-segment.cached-ff {
            background: linear-gradient(180deg, #2e7d32 0%, #1b4620 100%);
        }

        .memory-segment.modified {
            background: linear-gradient(180deg, #f44336 0%, #b71c1c 100%);
        }

        .memory-segment.modified-ff {
            background: linear-gradient(180deg, #b23434 0%, #7a1212 100%);
        }

        #memoryMapLegend {
            display: flex;
            gap: 20px;
            margin-top: 8px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid #555;
        }

        .legend-color.unread {
            background: #3a3a3a;
        }

        .legend-color.cached {
            background: #4CAF50;
        }

        .legend-color.cached-ff {
            background: #2e7d32;
        }

        .legend-color.modified {
            background: #f44336;
        }

        .legend-color.modified-ff {
            background: #b23434;
        }

        /* Device popup */
        .device-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 31, 53, 0.95);
            border: 1px solid #4a4f70;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            padding: 12px 14px;
            border-radius: 8px;
            color: #f0f6fc;
            font-size: 14px;
            max-width: 440px;
            z-index: 1000;
            display: none;
            line-height: 1.4;
        }

        .device-popup strong {
            color: #7a8bdc;
        }

        @keyframes blink-red {

            0%,
            100% {
                box-shadow: 0 0 0 rgba(0, 0, 0, 0);
            }

            50% {
                box-shadow: 0 0 12px rgba(248, 81, 73, 0.8);
            }
        }

        .device-popup.secure-warning {
            border-color: #f85149;
            background: rgba(62, 12, 12, 0.95);
            color: #fff;
            animation: blink-red 1s linear infinite;
        }
    </style>
    <!-- Built: 2026-01-04T12:30:04.952Z -->
</head>

<body>
    <div id="fetchOverlay">
        <div class="fetch-overlay-box">
            <div class="fetch-overlay-title">Fetching firmwareâ€¦</div>
            <div class="fetch-overlay-text" id="fetchOverlayText">Please wait</div>
        </div>
    </div>
    <div id="writeOverlay">
        <div class="write-overlay-box">
            <div class="write-overlay-title">Writing to Deviceâ€¦</div>
            <div class="write-overlay-text" id="writeOverlayText">Please wait</div>
        </div>
    </div>

    <div id="importPopup">
        <div class="import-popup-box">
            <div class="import-popup-title">ðŸ“¥ Import Binary File</div>

            <div class="import-tabs">
                <button class="import-tab active" onclick="switchImportTab('file')">File</button>
                <button class="import-tab" onclick="switchImportTab('url')">URL</button>
            </div>

            <div id="importTabFile" class="import-tab-content active">
                <div class="import-drop-zone" id="importDropZone"
                    onclick="document.getElementById('importFileInput').click()">
                    <p style="font-size: 1.1em; margin-bottom: 10px;">ðŸ“‚ Drop .bin file here or click to browse</p>
                    <p style="font-size: 0.9em; color: #888;">Selected: <span id="importFileName">None</span></p>
                    <input type="file" id="importFileInput" accept=".bin,.json" style="display: none;">
                </div>
            </div>

            <div id="importTabUrl" class="import-tab-content">
                <div class="import-field" style="margin-bottom: 20px;">
                    <label for="importUrlInput">URL (.bin or .json):</label>
                    <input type="text" id="importUrlInput" placeholder="https://example.com/firmware.bin"
                        style="width: 100%;">
                    <button class="btn" onclick="loadImportUrl()" style="margin-top: 10px; width: 100%;">Load
                        URL</button>
                </div>
            </div>

            <div class="import-field">
                <label for="importAddress">Start Address (Hex):</label>
                <input type="text" id="importAddress" placeholder="0x00000000" value="0x00000000">
            </div>

            <div class="import-field" id="importEraseOption" style="display: none;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="importEraseFlash" checked style="width: auto; cursor: pointer;">
                    <span>Erase Flash (recommended)</span>
                </label>
                <p style="font-size: 0.85em; color: #888; margin-top: 5px; margin-left: 24px;">
                    Remaining data may cause misdetection of partition table
                </p>
            </div>

            <div class="import-preview">
                <div class="import-preview-label">Preview:</div>
                <div class="import-preview-info" id="importPreview">
                    Select a file/URL and enter an address to see preview
                </div>
            </div>

            <div class="import-buttons">
                <button class="btn" onclick="hideImportPopup()"
                    style="background: linear-gradient(135deg, #666 0%, #444 100%);">Cancel</button>
                <button class="btn" id="importApplyBtn" onclick="applyImport()" disabled
                    style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Import</button>
            </div>
        </div>
    </div>
    <div id="devicePopup" class="device-popup"></div>
    <div class="container">
        <div class="header">
            <h1>ESP32 Firmware Editor</h1>
            <p>Reverse engineering & firmware analysis</p>
            <div style="font-size: 0.75em; margin-top: 12px; opacity: 0.7;"><a href="https://www.g3gg0.de">g3gg0.de</a>
            </div>
        </div>

        <div class="content">
            <div class="drop-zone" id="dropZone">
                <p><strong>Drop your ESP32 firmware (.bin) file here</strong></p>
                <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
                    <button class="btn" onclick="document.getElementById('fileInput').click()">Browse Files</button>
                    <button class="btn" id="connectToggleBtn"
                        style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);"
                        onclick="toggleDeviceSession()">Connect to ESP32</button>
                </div>
                <div id="advancedBaudGroup" style="display:none; margin-top:10px; text-align:center;">
                    <label for="advancedBaudSelect" style="font-size:0.9em; color:#a0a0a0;">Baud Rate
                        (advanced):</label>
                    <div style="margin-top:6px;">
                        <select id="advancedBaudSelect"
                            style="padding:8px 10px; border-radius:6px; border:1px solid #5a6bb8; background:#252525; color:#c8c8c8;">
                            <option value="115200">115200</option>
                            <option value="921600" selected>921600</option>
                            <option value="1000000">1000000</option>
                        </select>
                    </div>
                </div>
                <input type="file" id="fileInput" class="file-input" accept=".bin">
            </div>

            <div class="file-info" id="fileInfo">
                <h3 ondblclick="toggleTargetActions()" style="cursor: pointer;"
                    title="Double-click to toggle advanced actions">ðŸŽ¯ Target Information</h3>
                <div class="info-grid" id="fileInfoGrid">
                </div>
                <div id="targetActions" style="display:none; margin-top:12px;">
                    <div id="targetActionsButtons" class="button-group" style="display:none; flex-wrap:wrap; gap:8px;">
                        <button class="btn" id="targetResetBtn" onclick="deviceHardReset()" disabled>Reset</button>
                        <button class="btn" id="targetSyncBtn" onclick="deviceSync()" disabled>Sync</button>
                        <button class="btn" id="targetStubBtn" onclick="deviceLoadStub()" disabled>Download
                            Stub</button>
                        <button class="btn" id="targetFetchBtn" onclick="deviceRefresh()" disabled>Refresh</button>
                    </div>
                </div>
                <div class="button-group" style="display: flex; flex-wrap:wrap; gap:8px;">
                    <button class="btn" id="deviceDisconnectBtn" onclick="toggleDeviceSession()"
                        style="background: linear-gradient(135deg, #b71c1c 0%, #ef5350 100%); display: none;">Disconnect</button>
                    <button class="btn" id="closeFileBtn" onclick="closeFile()"
                        style="background: linear-gradient(135deg, #b71c1c 0%, #ef5350 100%); display: none;">Close
                        File</button>
                    <button class="btn" id="importBinBtn"
                        onclick="showImportPopup(0x00000000, deviceFlashSizeBytes, true, async () => { await parseAndDisplay(true); })"
                        style="display: none; background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Import...</button>
                    <button class="btn" id="eraseFlashBtn" onclick="eraseFlash()"
                        style="display: none; background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);">Erase
                        Flash</button>
                    <button class="btn" id="writeToDeviceBtn" onclick="writeToDevice()"
                        style="display: none; background: linear-gradient(135deg, #b71c1c 0%, #ef5350 100%);">Write to
                        Device</button>
                    <button class="btn" id="saveImageBtn" onclick="saveImage()">Save Image</button>
                </div>
            </div>

            <div id="deviceStatusContainer" style="display: none; margin-bottom: 20px;">
                <div id="deviceStatusText" class="success"
                    style="padding: 15px; border-radius: 5px; background: #252525; border-left: 4px solid #6ec589;">
                </div>
            </div>

            <div id="memoryMapContainer">
                <h4>ðŸ“Š Memory Map</h4>
                <div id="memoryMap" style="cursor: pointer;"></div>
                <div id="memoryMapLegend">
                    <div class="legend-item">
                        <div class="legend-color unread"></div>
                        <span>Unread</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color cached"></div>
                        <span>Cached</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color modified"></div>
                        <span>Modified</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color cached-ff"></div>
                        <span>Cached (0xFF)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color modified-ff"></div>
                        <span>Modified (0xFF)</span>
                    </div>
                </div>
            </div>

            <div id="tabContainer" style="display: none;">
                <div style="display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 10px;">
                </div>
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('bootloader', event)">Bootloader</button>
                    <button class="tab" onclick="switchTab('partitions', event)">Partitions</button>
                    <button class="tab" onclick="switchTab('raw', event)">Hex Viewer</button>
                </div>

                <div class="tab-content active" id="bootloader-tab">
                    <h3>Bootloader</h3>
                    <div id="bootloaderContent"></div>
                </div>

                <div class="tab-content" id="partitions-tab">
                    <h3>Partition Table</h3>
                    <div id="partitionsContent"></div>
                </div>

                <div class="tab-content" id="nvs-tab">
                    <h3>Non-Volatile Storage (NVS)</h3>
                    <div id="nvsContent"></div>
                </div>

                <div class="tab-content" id="raw-tab">
                    <h3>Hex Viewer</h3>
                    <div class="hex-controls">
                        <div>
                            <label for="hexOffset">Offset (hex):</label>
                            <input type="text" id="hexOffset" value="0" placeholder="0x0" onchange="updateHexView()">
                        </div>
                        <div>
                            <label for="hexLength">Length (hex):</label>
                            <input type="text" id="hexLength" value="100" placeholder="0x100"
                                onchange="updateHexView()">
                        </div>
                        <div>
                            <label for="hexWidth">Width (bytes/line):</label>
                            <input type="number" id="hexWidth" value="32" min="4" max="64" step="4"
                                onchange="updateHexView()">
                        </div>
                        <div style="display: flex; align-items: flex-end;">
                            <button class="btn" onclick="updateHexView()">Update View</button>
                        </div>
                    </div>
                    <div id="rawContent"></div>
                </div>
            </div>

            <input type="file" id="partitionFileInput" class="file-input" style="display:none" accept=".bin">
        </div>
    </div>

    <script>
/* Inlined from chips.js */

class ChipDescriptions {
    constructor() {
        this.chip_descriptions = {
            /*
                These are the flash stub loaders from esptool: 
                https://github.com/espressif/esptool/tree/master/esptool/targets/stub_flasher/1
                
                The binaries in JSON format distributed in this directory are released as Free Software under GNU General Public License Version 2 or later. 
            */
            "esp32": {
                "magic_value": 0x00F01D83,
                "mac_efuse_reg": 0x3FF5A004,
                "stub":
                {
                    "entry": 1074521712,
                    "text": "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",
                    "text_start": 1074520064,
                    "data": "DMD8P3HoC0AH6QtAke0LQKfpC0Aq6QtAp+kLQADqC0AH6wtAfesLQCLrC0Ad6AtAs+oLQPzqC0Ae6gtAnusLQEjqC0Ce6wtA/ugLQGDpC0Cn6QtAAOoLQBDpC0Bs7AtAVu0LQIjtC0By7QtAiO0LQIjtC0CI7QtAiO0LQIjtC0CI7QtAiO0LQIjtC0D/6wtAiO0LQIfsC0BW7QtA",
                    "data_start": 1073605548,
                    "bss_start": 1073528832
                }
            },
            "esp32s2": {
                "mac_efuse_reg": 0x3F41A044,
                "magic_value": 0x000007C6,
                "stub":
                {
                    "entry": 1073907892,
                    "text": "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",
                    "text_start": 1073905664,
                    "data": "WAD9P/KLAkCHjAJAK5ECQCeNAkCqjAJAJ40CQICNAkCDjgJA+Y4CQJ6OAkB9iwJAL44CQHiOAkCejQJAGo8CQMaNAkAajwJAfowCQOCMAkAnjQJAgI0CQJCMAkC+iwJA9I8CQOKQAkAikQJABpECQCKRAkAikQJAIpECQCKRAkAikQJAIpECQCKRAkAikQJAe48CQCKRAkAQkAJA4pACQA==",
                    "data_start": 1073622016,
                    "bss_start": 1073545216
                }
            },
            "esp32s3": {
                "mac_efuse_reg": 0x60007044,
                "magic_value": 0x00000009,
                "stub":
                {
                    "entry": 1077382292,
                    "text": "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",
                    "text_start": 1077379072,
                    "data": "WADKP2qQN0A/kTdA1ZU3QN+RN0BikTdA35E3QDiSN0A/kzdAtZM3QFqTN0D1jzdA55I3QDSTN0BWkjdA1pM3QH6SN0DWkzdANpE3QJiRN0DfkTdAOJI3QEiRN0A2kDdArJQ3QJqVN0DMlTdAtpU3QMyVN0DMlTdAzJU3QMyVN0DMlTdAzJU3QMyVN0DMlTdAM5Q3QMyVN0DIlDdAmpU3QAQInwAAAAAAAAAYAQQIBQAAAAAAAAAIAQQIBgAAAAAAAAAAAQQIIQAAAAAAIAAAEQQI3AAAAAAAIAAAEQQIDAAAAAAAIAAAAQQIEgAAAAAAIAAAESAoDAAQAQAA",
                    "data_start": 1070279676,
                    "bss_start": 1070202880
                }
            },
            "esp32c2": {
                "mac_efuse_reg": 0x60008840,
                "stub":
                {
                    "entry": 1077413350,
                    "text": "ARG3BwBgTsaDqYcASsg3Sco/JspSxAbOIsyThMcBPooTCQkAgEATdPQ/GcgDJQoAgycJAH0UE3X1D4KXZfjdt/JAYkS3BwBgI6g3AdJEQkmySSJKBWGCgJMHAAyQQSqHYxj1AIVHBcYjoAUAeVWCgIVGYwfWAAlFYw2mAH1VgoBCBZMHsA1BhWMT9wKJR5zB9bcTBsANYxXHAJTBPoWCgJMH0A3jHPf8lMETBbANgoC3dcs/QRGThUW6BsZxP2NNBQS3d8s/k4fHsQOnBwiD1kcIE4YWACOSxwg2lyMApwAD10cIkWeThwcEYxr3Ajf3yj8TB8exoWe6lwOmBwi3Nss/k4bGtWMf5gAjpscII6DXCCOSBwghoPlX4wr1/LJAQQGCgCOm1wgjoOcI3bc3JwBgEwdHBRxDnYv1/zc3AGATB0cFHEOdi/X/goBBEQbG+T83JwBgtwYACCMmBwKTB8cCFMMUQ/3+iEOyQBNF9f8FiUEBgoBBEQbGyT993bcnAGA3BwBAmMOYQ33/skBBAYKAQREmwrfEyj+ThMQASsADqQQBBsYixGMJCQRFNzHFvUcBRGPWJwGARH2MEzQUAF0/tTeYRLcHAAE+hpMWxwAZwDcGgAD9F/WPtyYAYNzCkMKcQv3/kwf0/8WbwQczCflAPpcjqCQBmMSyQCJEkkQCSUEBgoBBEQbGEwcADGMQ5QITBbANlwDI/+eAIOQTBcANskBBARcDyP9nACPjEwewDeMY5f6XAMj/54Ag4hMF0A3Ft0ERIsQmwgbGKoSzBLUAYxeUALJAIkSSREEBgoADRQQABQRFN+23EwUADBcDyP9nAKPedXEixSbD0twGx0rBzt4TAQGAEwEBgKqEKAguhAVqlzDI/+eAAJUV5CAAooUoCJcwyP/ngICUIoXBRVE/AUWFYhaRukAqRJpECkn2WWZaSWGCgCKJY3OKAAVpSoaMGCaFlwDI/+eAYOYTdfUPAe1KhowYKAiXMMj/54Dgj8qUMwQkQVW3EwUwBl2/AREGzi01NwXOP2wAURWXAMj/54Ag5qqHBUWd57JHk/cHID7GiT23JwBgmEe3BkAANwXOP1WPmMeyRVEVlwDI/+eAgOMzNaAA8kAFYYKAQRG3x8o/BsaTh8cABUcjgOcAE9fFAJjHBWd9F8zDyMf5jTqVqpWxgQ1njMsjqgcAMzbAALqXI4bHsKU/GcETBVAMskBBAYKAeXEi1DfEyj8m0k7OLsYG1krQqokTBMQAlwDI/+eAoNWyRUREY/OVAK6EucgDKUQAJpkTWckAHEhjVfAAHERjX/kClTt93UhAJobOhZcAyP/ngODRAcWTB0AMXMhcQLJQAlmml1zAXETySYWPXMQiVJJURWEXA8j/ZwAj0EEzZb+yUCJUklQCWfJJRWGCgAERIsw3xMo/EwTEAI1nopeDx8ewBs4mykrITsaBy2JE8kDSREJJskkFYaG3RERj85UAroSxwAMpRACqiSaZE1nJABxIY1XwABxEY175Auk5fd1IQCaGzoWXAMj/54DAyxN19Q8BxZMHQAxcyFxAppdcwFxEhY9cxPJAYkTSREJJskkFYYKA5TFtvwFFFwPI/2cAA7w1cSLNTsdSxVbD3t4GzybLSslawRMBAYATAQGAqokTBQACLoqyiraLAsKXAMj/54AgMYVngBhj71cNKAiXIMj/54AAbwFJAytE+WNjaQtjYUsDeai5O6aFIoUNO5k7JoaihSgIlyDI/+eAwGymmSaZY3VJA7MHaUFj8XcDswQqQWPzmgDWhCaGooVOhZcAyP/ngIC/E3X1D1XdsT+BRCMsBPh5W6MJBPgTBTEAlwDI/+eAwK91+QNFNPksANU0kxcFAWPCBwKTt0QAkc+FZ5OHBweml4qXk4cHgJOHB4Ajiqf4hQTBt+MfZfuRR+ON9PQgAKKFKAiXIMj/54DgY1U5IoXBRWExdTETBQAClwDI/+eAQCOFYhaR+kBqRNpESkm6SSpKmkoKS/ZbDWGCgLdXQUkZcZOH94QBRT7Oht6i3KbaytjO1tLU1tLa0N7O4szmyurI7saXAMj/54CgqrdHyj83d8s/k4cHABMHx7pj7ecSgTGRRWgIETklOa09t/fKP5OHx7Ghar6aI6D6CLdJyj+3BzhAtwU4QAFGk4cHC5OFBQCTiQkAFUUjoPkAlwDI/+eAoBi3BwBg2EcTBQACN8rKPxNnFxDYx5cAyP/ngGAXt0cAYIhfgUW3e8s/cYlhFRM1FQCXAMj/54CgrUFmkwf2/xMHABCFZrcFAAEBRRMKygANa5cAyP/ngOCok4vLwFKbg6fKCPXfg6TKCIVHI6YKCCMC8QKDxxQACUcjE+ECowLxAgLUTUdji+cGUUdjiecGKUdjnucAg8c0AAPHJACiB9mPEUdjlecAnEScQz7UgT6hRUgQFTaDxjQAg8ckAKIG3Y6RZ8EHY//XAhMFsA2XAMj/54DgkRMFwA2XAMj/54AgkRMF4A6XAMj/54BgkAE+iTu9tyOgBwCRB8G1yUcjE/ECdbeDxxQAUUdjZ/cCBUdjZvcAAUkTBPAPMaT5F5P39w9JR+No9/43d8s/igcTBwe7upecQ4KHE4cHAxN39w8RRuNp5vyTh/cCk/f3Dw1HY2L3Bjd3yz+KBxMHx7+6l5xDgoeTB0ACY5n2DgLUHUQBRZcAyP/ngKCHAUU5PEE0vTyhRUgQfRSBPH3wAUkBRFmqiepwEIFFAUWXAMj/54CgigHFBUQBSb2q0UVoEC00AUTVvwVE5fqXAMj/54DAjjM0oADNt6FH4572/AOphADARLNniQDSB/H3bTwimXnxGcQzBYlAkxcFAcGDgetBbGNhjAIV6DM0gAB1tzGBlwDI/+eAYIwV7RMEBIATBASAwb8zBYlAQYGXAMj/54AAiwXlMwSEQem3MwWJQDGBlwDI/+eAYIkB7RMEBIATBASAVb8TBFADRb8TBGADbbcTBHADVbehR+OL9vIBSRMEAAzZoMFHzb/BRwVE45728sxEiERhOrG3k/e2/0FH45/n/JhIkWdj4uck0UeIRMxIAUZjk/YAkEyxNCqEMbeT97b/QUfjnOf6nEgRZ2Nv9yDYRIhEzEgziecC0UcBRmOT9gCQTAU0t8fKP5OHxwANZyOsBwC6lyqEI6QnsfG1t8fKP5OHxwADxwcAYw8HFphEwRYTBAAMYxPXAMBLgUcTBvAOY8HXBoPHVAADx0QAAUmiB9mPA8dkAEIHXY+Dx3QA4gfZj2MX9hoTdfQP7/AfhxN1+Q/v8J+G7/CfjOMbBNqDxxQASUdjYfcaCUfjc/fa9ReT9/cPPUfjbffYigfel5xDgoczh/QAA0eHAYUHOY5Jv7fHyj+Th8cAA8cHAG3H2EdjGwcUwEsjgAcAMb3hR2OQ9gLcTJhM1EiQSMxEiESX8Mf/54AgdCqJMzSgAK2/AUkFRJW/kUcFROOX9t63lgBguELld/0XBWZ9j1GPiES4wreWAGC4RoFFfY9Rj7jGt5YAYPhCfY9Rj/jCt5YAYNhe+Y/Rj9zel/DH/+eAYHFNu5P39gDjmwfkE9xGABOEhAABSf1c43yJ10hEl/DH/+eA4FscRFhAEEB9j2OHlwEUQpPH9//1j12PGMIFCUEE2b+RRxG9wUcFROOf9tScRNhII6T5ACOi6QChuwOnSQAThgb/EecBzgFJEwRgDG29g6eJAGPmxwaNiuORBt6DpokAgUWBR2PrxwDjggXQnY4+lyOk2QAjoukA1bmzhfQAiE2zBfcAkQeIwYVF6b+hRwVE45v2zgOkiQAZwBMEgAwjpAkAI6IJAAW7AUkTBCAMob0TBBAMib0BSRMEgAyptQFJEwSQDIm1EwcgDWOI5wYTB0AN45/nvoPFNACDxyQAE4WEAaIF3Y3BFe/wP4LVtgllEwUFcQOpxACARJfwx//ngOBLtwcAYNhLtwYAAcEWk1dHARIHdY+9i9mPs4cnAwFFs9WHApfwx//ngIBMEwWAPpfwx//ngIBIYb7USJBIzESIRO/wv45ptoPFNACDxyQAE4WEAaIF3Y3BFe/w/4ONvoPHNAADxyQAogfZjxONB/+DJ8oAgeeTN10Ancu3fcs/N8nKP7dMyj/hBAVEk43NuhMJyQATjMwAYwcNAIMnygCZw2NMgABjVQQIkwdwDBmgkweQDCMq+gAhvgMoi7ADpw0AatAzOA0BBgizB+lABQg6xj7WQsTv8A/TMkciSDfFyj+mhXwQ4oYQEBMFRQKX8Mf/54AgR4JXAyeLsIOlDQAzDf1AHY++lLJXIyTrsCqEvpUjoL0A4XezhYVBrpeRwyX9E4XMAO/wL/cjoI0BrbfjEASqgyfKAOOMB6iTB4AMlb+cROOWB6jv8K/9CWUTBQVxl/DH/+eAYDaX8Mf/54AgOr20wETjBQSm7/CP+xMFgD6X8Mf/54BgNAKUkbz2UGZU1lRGWbZZJlqWWgZb9ktmTNZMRk22TQlhgoA=",
                    "text_start": 1077411840,
                    "data": "DEDKP+IIOEBICThA3Ak4QLAKOEAYCzhAxgo4QNAHOEBsCjhArAo4QPgJOECABzhAIAo4QIAHOEDACDhACAk4QEgJOEDcCThA0gg4QP4HOEAyCDhAzgg4QAoNOEBICThA1As4QM4MOEBcBzhA8Aw4QFwHOEBcBzhAXAc4QFwHOEBcBzhAXAc4QFwHOEBcBzhAegs4QFwHOEDsCzhAzgw4QA==",
                    "data_start": 1070295980,
                    "bss_start": 1070219264
                }
            },
            "esp32c3": {
                "mac_efuse_reg": 0x60008844,
                "magic_value": [0x6921506F, 0x1B31506F, 0x4881606F, 0x4361606F],
                "stub":
                {
                    "entry": 1077413582,
                    "text": "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",
                    "text_start": 1077411840,
                    "data": "FEDIP5IKOED8CjhAjgs4QGIMOEDKDDhAeAw4QGwJOEAeDDhAXgw4QKoLOEAcCThA0gs4QBwJOEBwCjhAugo4QPwKOECOCzhAggo4QJQJOEDgCThAfgo4QMQOOED8CjhAhg04QIAOOEDaCDhApg44QNoIOEDaCDhA2gg4QNoIOEDaCDhA2gg4QNoIOEDaCDhALA04QNoIOECeDThAgA44QA==",
                    "data_start": 1070164916,
                    "bss_start": 1070088192
                }
            },
            "esp32c5": {
                "mac_efuse_reg": 0x600B4844,
                "stub":
                {
                    "entry": 1082133122,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "FACEQOYOgEBQD4BA5A+AQLgQgEAgEYBAzhCAQEANgEB0EIBAtBCAQAAQgEDwDIBAKBCAQPAMgEDCDoBADg+AQFAPgEDkD4BA1A6AQGgNgECWDYBA0A6AQBoTgEBQD4BA3BGAQNYSgECqDIBA/BKAQKoMgECqDIBAqgyAQKoMgECqDIBAqgyAQKoMgECqDIBAghGAQKoMgED0EYBA1hKAQA==",
                    "data_start": 1082469300,
                    "bss_start": 1082392576
                }
            },
            "esp32c6": {
                "mac_efuse_reg": 0x600B0844,
                "magic_value": 0x2CE0806F,
                "stub":
                {
                    "entry": 1082132158,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "EACEQD4KgECoCoBANguAQAoMgEByDIBAIAyAQDAJgEDGC4BABgyAQFILgEDgCIBAeguAQOAIgEAcCoBAZgqAQKgKgEA2C4BALgqAQFgJgECMCYBAKgqAQGwOgECoCoBALg2AQCgOgECeCIBATg6AQJ4IgECeCIBAngiAQJ4IgECeCIBAngiAQJ4IgECeCIBA1AyAQJ4IgEBGDYBAKA6AQA==",
                    "data_start": 1082469296,
                    "bss_start": 1082392576
                }
            },
            "esp32c61": {
                "mac_efuse_reg": 0x600B4844,
                "stub":
                {
                    "entry": 1082132158,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "EECAQEIKgECsCoBAOguAQA4MgEB2DIBAJAyAQDQJgEDKC4BACgyAQFYLgEDkCIBAfguAQOQIgEAgCoBAagqAQKwKgEA6C4BAMgqAQFwJgECQCYBALgqAQHAOgECsCoBAMg2AQCwOgECiCIBAUg6AQKIIgECiCIBAogiAQKIIgECiCIBAogiAQKIIgECiCIBA2AyAQKIIgEBKDYBALA6AQA==",
                    "data_start": 1082223536,
                    "bss_start": 1082146816
                }
            },
            "esp32h2": {
                "stub":
                {
                    "entry": 1082132158,
                    "text": "QRG39wBgIsQmwkrAEUcGxrcEg0DYyz6JM4TnAJOEBAAcQJGLmeeyQCJEkkQCSUEBgoADJQkAnEATdfUPgpfNtwERtwcAYE7Gg6mHAErINwmDQCbKUsQGziLMk4THAT6KEwkJAIBAE3T0DxnIAyUKAIMnCQB9FBN19Q+Cl2X43bfyQGJEtwcAYCOoNwHSREJJskkiSgVhgoCTBwAMkEEqh2MY9QCFRwXGI6AFAHlVgoCFRmMH1gAJRWMNpgB9VYKAQgWTB7ANQYVjE/cCiUecwfW3EwbADWMVxwCUwT6FgoCTB9AN4xz3/JTBEwWwDYKAtzWEQEERk4WFugbGcT9jTQUEtzeEQJOHB7IDpwcIg9ZHCBOGFgAjkscINpcjAKcAA9dHCJFnk4cHBGMa9wI3t4NAEwcHsqFnupcDpgcIt/aDQJOGBrZjH+YAI6bHCCOg1wgjkgcIIaD5V+MK9fyyQEEBgoAjptcII6DnCN23NzcAYBMHRwUcQ52L9f83JwBgEwdHBRxDnYv1/4KAQREGxvk/NzcAYLcGAAgjJgcCkwfHAhTDFEP9/ohDskATRfX/BYlBAYKAQREGxsk/fd23NwBgNwcAQJjDmEN9/7JAQQGCgEERJsK3hINAk4QEAUrAA6kEAQbGIsRjCQkERTcxxb1HAURj1icBgER9jBM0FABdP7U3mES3BwABPoaTFscAGcA3BoAA/Rf1j7c2AGDcwpDCnEL9/5MH9P/Fm8EHMwn5QD6XI6gkAZjEskAiRJJEAklBAYKAAREGzhU3NwWFQGwAQRWXAID/54CA8qqHBUWd57JHk/cHID7GsTe3NwBgmEe3BkAANwWFQFWPmMeyRUEVlwCA/+eA4O8zNaAA8kAFYYKAQRG3h4NABsaThwcBBUcjgOcAE9fFAJjHBWd9F8zDyMf5jTqVqpWxgQ1njMsjqgcAMzbAALqXI4bHsKU/GcETBVAMskBBAYKAeXEi1DeEg0Am0k7OLsYG1krQqokTBAQBlwCA/+eAAOKyRUREY/OVAK6EucgDKUQAJpkTWckAHEhjVfAAHERjX/kCvTV93UhAJobOhZcAgP/ngEDeAcWTB0AMXMhcQLJQAlmml1zAXETySYWPXMQiVJJURWEXA4D/ZwCD3K09Zb+yUCJUklQCWfJJRWGCgAERIsw3hINAEwQEAY1nopeDx8ewBs4mykrITsaBy2JE8kDSREJJskkFYaG3RERj85UAroSxwAMpRACqiSaZE1nJABxIY1XwABxEY175AtE7fd1IQCaGzoWXAID/54Ag2BN19Q8BxZMHQAxcyFxAppdcwFxEhY9cxPJAYkTSREJJskkFYYKAzTNtv0ERBsaXAID/54DAywNFhQGyQHUVEzUVAEEBgoBBEQbGxTcNxbcHg0CThwcA1EOZzjdnCWATB8cQHEM3Bv3/fRbxjzcGAwDxjtWPHMOyQEEBgoBBESLEBsYqhF03Ec039wBgEQccQ4mL9d+39wBgskCAwyJEQQGCgCKFIkSyQEEBFwOA/2cAg75BEQbGEwcADGMa5QATBbANbT8TBcANskBBAUW/EwewDeMb5f5dNxMF0A31t0ERIsQmwgbGKoSzBLUAYxeUALJAIkSSREEBgoADRQQABQRNP+23dXEixSbD0twGx0rBzt4TAQGAEwEBgKqEKAguhAVqlwCA/+eAwCIN5CgALAiXAID/54BgIigAwUVNNwFFhWIWkbpAKkSaRApJ9llmWklhgoAiiWNzigAFaUqGjBgmhZcAgP/ngMDBE3X1DwHtSoaMGCgIlwCA/+eAwB3KlDMEJEFdtxMFMAZdvxMFAAz1tUERBsZRPQHJskC39wBgBUfYw0EBgoCyQEEBFwOA/2cA4681cSLNTsdSxVbD3t4GzybLSslawRMBAYATAQGAqokuirKKtosCwoE9gBi3BwIAGeGTBwACPoWXAID/54CAFYVnY+NXDygIlwCA/+eAQBUBSQMrRPljY2kLY2FLA3morT+mhSKF2TWNPyaGooUoCJcAgP/ngAATppkmmWN1SQOzB2lBY/F3A7MEKkFj85oA1oQmhqKFToWXAID/54BAsxN19Q9V3S0/gUQjLAT4eVujCQT4EwUxAJcAgP/ngMCidfkDRTT5LACRPJMXBQFjwgcCk7dEAJHPhWeThwcHppeKl5OHB4CThweAI4qn+IUEwbfjH2X7kUfjjfT0KAAsCJcAgP/ngEAKyT3BRSgAOT3pNZ0zkwcAAhnBtwcCAD6FlwCA/+eAQAeFYhaR+kBqRNpESkm6SSpKmkoKS/ZbDWGCgLdXQUkZcZOH94QBRYbeotym2srYztbS1NbS2tDezuLM5srqyO7GPs6XAID/54DgnRkzDcE3ZwlgEwfHEBxDtwaDQCOi9gC3Bv3//Rb1j8Fm1Y8cw80xBc23JwtgN0fYUJOHx8ETBxeqmMO3JgtgI6AGwCOgBwCTh0bCmMMThwbCFEM3BgQA0Y4UwyOgBwC3B4NANzeEQJOHBwATBwe7IaAjoAcAkQfj7ef+/TORRWgILTvdM+0zt7eDQJOHB7Khar6aI6D6CLcJg0C3B4BAk4kJAJOHBw8joPkAsTljBAUQtwcBYEVFI6qnCIVFlwCA/+eAoPO3BYBAAUaThQUARUWXAID/54Cg9Lf3AGARR5jLNwUCAJcAgP/ngODztxcJYIhfgUU3ioNAcYlhFRM1FQCXAID/54BgnkFmkwf2/xMHABCFZrcFAAEBRbc7hEATCgoBDWuXAID/54BglJOLC8FSm4Onygj134OkygiFRyOmCggjAvECg8cUAAlHIxPhAqMC8QIC1E1HY4HnCFFHY4/nBilHY57nAIPHNAADxyQAogfZjxFHY5XnAJxEnEM+1OUxoUVIEBU5g8Y0AIPHJACiBt2OkWfBB2P11wQTBbANZT4TBcANTT4TBeAOdTZtOX05Qbe3BYBAAUaThQUEFUWXAID/54Cg5bcHAGDYRxMFAAITZxcQ2Mcxt8lHIxPxAkW3g8cUAFFHY2f3AgVHY2b3AAFJEwTwDzGk+ReT9/cPSUfjaPf+NzeEQIoHEwdHu7qXnEOChxOHBwMTd/cPEUbjaeb8k4f3ApP39w8NR2Nv9wQ3N4RAigcTBwfAupecQ4KHkwdAAmOX9g4C1B1EAUUhNgFFLT4JOQE5oUVIEH0UqT519AFJAURxqonqcBCBRQFFl/B//+eAwHUBxQVEAUlRotFFaBAVPgFE1b8FROX6l/B//+eA4HkzNKAAzbehR+Oe9vwDqYQAwESzZ4kA0gfx9+/wf4oimXHxGcQzBYlAkxcFAcGDgetBbGNhjAIV6DM0gABttzGBl/B//+eAYHcV7RMEBIATBASAwb8zBYlAQYGX8H//54AAdgXlMwSEQem3MwWJQDGBl/B//+eAYHQB7RMEBIATBASAVb8TBFADRb8TBGADbbcTBHADVbehR+OK9vIBSRMEAAzpoMFHzb/BRwVE45328sxEiERRPKm3k/e2/0FH45/n/JhIkWdj4eck0UeIRMxIAUZjk/YAkEzv8H+DKoQht5P3tv9BR+Ob5/qcSBFnY233INhEiETMSDOJ5wLRRwFGY5P2AJBM7/CfgLeHg0CThwcBDWcjrAcAupcqhCOkJ7HZtbeHg0CThwcBA8cHAGMMBxaYRMEWEwQADGMT1wDAS4FHEwbwDmPO1wSDx1QAA8dEAAFJogfZjwPHZABCB12Pg8d0AOIH2Y9jFPYaE3X0D1kyE3X5D0EyoTzjHwTYg8cUAElHY2H3GglH43f32PUXk/f3Dz1H42H32IoH3pecQ4KHM4f0AANHhwGFBzmOYb+3h4NAk4cHAQPHBwBtx9hHYxsHFMBLI4AHADG94UdjkPYC3EyYTNRIkEjMRIhEl/B//+eAQF8qiTM0oABBtwFJBUStv5FHBUTjl/bet5YAYLhK5Xf9FwVmfY9Rj4hEuMq3lgBg+EKBRX2PUY/4wreWAGD4Sn2PUY/4yreWAGC4QvmP0Y+8wpfwf//ngIBhTbuT9/YA45wH5BPcRgAThIQAAUn9XON8iddIRJfwf//ngABGHERYQBBAfY9jh5cBFEKTx/f/9Y9djxjCBQlBBNm/kUcZvcFHBUTjn/bUnETYSCOm+QAjpOkAobsDp4kAE4YG/xHnAc4BSRMEYAzBtYOnyQBj5scGjYrjkgbeg6bJAIFFgUdj68cA44IF0J2OPpcjptkAI6TpANW5s4X0AIhNswX3AJEHiMGFRem/oUcFROOb9s4DpMkAGcATBIAMI6YJACOkCQANuwFJEwQgDLm9EwQQDKG9AUkTBIAMgb0BSRMEkAyhtRMHIA1jiOcGEwdADeOT576DxTQAg8ckABOFhAGiBd2NwRXv8O/g8bYJZRMFBXEDqcQAgESX8H//54AANrcHAGDYS7cGAAHBFpNXRwESB3WPvYvZj7OHJwMBRbPVhwKX8H//54AgNxMFgD6X8H//54CgMkG21EiQSMxEiETv8H+Fjb6DxTQAg8ckABOFhAGiBd2NwRXv8K/iqb6DxzQAA8ckAKIH2Y8TjQf/gyfKAIHnkzddAJ3Ltz2EQDeJg0C3DINA4QQFRJONDbsTCQkBE4wMAWMHDQCDJ8oAmcNjTIAAY1UECJMHcAwZoJMHkAwjKvoAAbYDKIuwA6cNAGrQMzgNAQYIswfpQAUIOsY+1kLE7/BvwTJHIkg3hYNApoV8EOKGEBATBYUCl/B//+eAQDKCVwMni7CDpQ0AMw39QB2PvpSyVyMk67AqhL6VI6C9AOF3s4WFQa6XkcMl/ROFDAHv8O/VI6CNAa234xQEqIMnygDjgAeokweADJW/nETjmgem7/Dv8gllEwUFcZfwf//ngIAg7/AP3Zfwf//ngMAkibzAROMHBKTv8I/wEwWAPpfwf//ngEAe7/DP2gKUFbzv8E/a9lBmVNZURlm2WSZalloGW/ZLZkzWTEZNtk0JYYKAAAA=",
                    "text_start": 1082130432,
                    "data": "EACDQD4KgECoCoBANguAQAoMgEByDIBAIAyAQDAJgEDGC4BABgyAQFILgEDgCIBAeguAQOAIgEAcCoBAZgqAQKgKgEA2C4BALgqAQFgJgECMCYBAKgqAQGwOgECoCoBALg2AQCgOgECeCIBATg6AQJ4IgECeCIBAngiAQJ4IgECeCIBAngiAQJ4IgECeCIBA1AyAQJ4IgEBGDYBAKA6AQA==",
                    "data_start": 1082403760,
                    "bss_start": 1082327040
                }
            },
            "esp32p4": {
                "mac_efuse_reg": 0x5012D044,
                "stub":
                {
                    "entry": 1341459336,
                    "text": "QRG3Jw1QIsQmwkrAEUcGxrcE9k/Yyz6JM4TnAJOEBAAcQJGLmeeyQCJEkkQCSUEBgoADJQkAnEATdfUPgpfNtwERt6cMUE7Gg6mHAErINwn2TybKUsQGziLMk4THAT6KEwkJAIBAE3T0PxnIAyUKAIMnCQB9FBN19Q+Cl2X43bfyQGJEt6cMUCOoNwHSREJJskkiSgVhgoCTBwAMkEEqh2MY9QCFRwXGI6AFAHlVgoCFRmMH1gAJRWMNpgB9VYKAQgWTB7ANQYVjE/cCiUecwfW3EwbADWMVxwCUwT6FgoCTB9AN4xz3/JTBEwWwDYKAtzX3T0ERk4VFvwbGcT9jTQUEtzf3T5OHx7YDpwcIg9ZHCBOGFgAjkscINpcjAKcAA9dHCJFnk4cHBGMa9wI3t/ZPEwfHtqFnupcDpgcIt/b2T5OGxrpjH+YAI6bHCCOg1wgjkgcIIaD5V+MK9fyyQEEBgoAjptcII6DnCN23N9cIUBMHRwUcQ52L9f83xwhQEwdHBRxDnYv1/4KAQREGxvk/N9cIULcGAAgjJgcCkwfHAhTDFEP9/ohDskATRfX/BYlBAYKAQREGxsk/fd231whQNwcAQJjDmEN9/7JAQQGCgDlxItwm2krYUtRW0gbeTtaqhC6JMoRBSpcAy//ngODyhUpjS4AA8lBiVNJUQlmyWSJaklohYYKAooljU4oAwUmTlzkAIUg+xErCJocCyFbGAsCBSJMHAALChjFGkUUFRZcAzP/ngCB7MwQ0QU6ZzpRNvzlxItwm2krYUtRW0gbeTtaqhC6JMoSTCgAClwDL/+eAoOsFSmNLgADyUGJU0lRCWbJZIlqSWiFhgoAlP6KJY9SKAJMJAAKTlzkAyogmhz7AAUiTBwACoUZJRpFFBUVSyFLGAsQCwpcAzP/ngKBzlwDL/+eAYOZOmc6UMwQ0QV23eXEi1DeE9k8TBMQFStADKQQBBtYm0mMCCQp9NVnNvUeBRGPWJwEERP2Mk7QUANE1rT23B/ZPg8dHAMHPlwDL/+eAgOF9NRhEBUUqyCrGAsQCwgLAMge3BwABgUgBSIXIY1H3AuFHoUYTBoANlUWXAMz/54Aga5cAy//ngODdQUc9oJMHAAKhRhMGwA3Ft2Nc9wLhR6FGEwYAApVFlwDM/+eAQGiXAMv/54AA2wVHHEiZjxzIHES6lxzEslAiVJJUAllFYYKAkwcAAqFGEwYQAum3HEQ3BwABuoayB5nAtwaAAH0X+Y831whQXMMUwxxD/f/N3Gm3AREGziLMJsrxV2OS9QQ3BPZPtwT8TxMEBAADpUT9lwDL/+eAwE9jR6AA8kBiRNJEBWGCgAOlRP0FRmwAlwDL/+eAIE4cQANFwQCCl/m3/VfjnfX8cACJRQLGlwDL/+eAQE8yR7cH9k+ThwcAGeeURwVGY5TGACOG1wCYx323AREGzg07NwX0T2wAMRWXAMv/54Bg1KqHBUWd57JHk/cHID7GqTu31whQmEe3BkAANwX0T1WPmMeyRTEVlwDL/+eAwNEzNaAA8kAFYYKAQRG3h/ZPBsaTh8cFBUcjgOcAE9fFAJjHBWd9F8zDyMf5jTqVqpWxgQ1njMsjqgcAMzbAALqXI4bHsKU/GcETBVAMskBBAYKAWXGi1DeE9k+m0s7OLtaG1srQ0szWytrI3sbixObC6sBu3qqJEwTEBZcAy//ngODCslVERGPzlQCuhGOCBBwDKUQAJpkTWckAHEhjVfAAHERjX/kGrTF93bcH9k+Dx0cAAylEAGOFBxiz5yQBvYvF65cAy//ngGC+t8cIUCOiBzSXAMv/54DgwCaKUeU3ywhQt8sIUDfMCFC3zAhQkw3wAxMLCzSTiwswEwyMNJOMzDSFShN1+QMR7RMNAARj700B/Uczs0cBEx1DAEENOaAlM6W/k3f5AUFN5deTV11AIyD7AGqGzoVelZcAy//ngGDLIyAsASOgXAHFPrfGCFBhZ4FHk4aGNQlGEwcHaoxCY47FAGOa5wCXAMv/54BAtJMHQAxcyGmohQfVt+OG5/4+1pcAy//ngKCxN8cIULJXIyhXNZMGhzVhZw1GEwcHaoxCY4bFAOOB5/yFB9W/443n+pcAy//ngKCuIeWTFz0A/Rc+wEqHkwcAAlbIVsYCxALCgUgBSKFGSUaRRQVFlwDM/+eAoDi3xwhQI6pXNTMKqkHqmWqZ4xcK8JcAy//ngCCqKtaXAMv/54CAqjJVLfFcQLZQBlmml1zAXET2SWZKhY9cxCZUllTWSkZLtksmTJZMBk3yXWVhFwPL/2cAQ6cmhs6FSoWXAMv/54CgpcG3tlAmVJZUBln2SWZK1kpGS7ZLJkyWTAZN8l1lYYKAAREizDeE9k8TBMQFjWeil4PHx7AGzibKSshOxlLEVsJawJnLYkTyQNJEQkmySSJKkkoCSwVhfbNERGPzlQCuhKXAAylEACqKJpkTWckAHEhjVfAAHERjX/kEoTR93bcH9k+Dx0cAgypEANnDk/n6DxMJABAzCTlBlwDL/+eAYJtj/CQDJobShVaFwTyXAMv/54AgmlxAppdcwFxEhY9cxPJAYkTSREJJskkiSpJKAksFYYKAHTZhv5OJCfBKhtKFVoWmmVk8k9mJAAFLMwVZAbMFKgFjZTsBM4YkQX23EwYAEAULnTwTCQkQE3v7D/m/JobShVaFlwDL/+eAQJcTdfUPSdmTB0AMXMhpt0ERBsaXAMv/54CgiwNFhQGyQGkVEzUVAEEBgoBBEQbGlwDL/+eA4IkDRYUBskBtFRM1FQBBAYKAQREixDcE9k8TBAQAtwf8TxBIA6VH/ZMFRAEGxpcAy//ngGAIskAjKAQAIkRBAYKAQREixAbGKoR1NxXFtwf2T5OHBwCYS5MGFwCUy7qXI4qHABMEBPQBxBMHF/wF4yJEskBBAXG/jTcRzTcnDVARBxxDiYv137cnDVCAw7JAIkRBAYKAIoUiRLJAQQEX88r/ZwDjeUERBsYTBwAMYxrlABMFsA1xNxMFwA2yQEEBSbcTB7AN4xvl/qU/EwXQDfW3QREixCbCBsYqhLMEtQBjF5QAskAiRJJEQQGCgANFBAAFBE0/7bd1cSLFJsPO3tLc1toGx0rBEwEBgBMBAYCqhDcK9k8oCC6EhWqXAMv/54CAyhMKCgCTCQEHFeQoACwIlwDL/+eAoMkoAMFFUT8BRYViFpG6QCpEmkQKSfZZZlrWWklhgoAiiWPzigAFaYNHSgBKhs6FJoWRz+/wv4RKhs6FKAiXAMv/54AgxcqUMwQkQWW3l/DK/+eAYHsTdfUPed0TBTAGbbcTBQAMVbVBEQbGiT0BybcH9k+ThwcAnEuRw7k9FTUBybJAtycNUAVH2MNBAYKAskBBARfzyv9nAMNoNXEizU7HUsVaweLcBs8my0rJVsPe3hMBAYATAQGAgBiqiS6KMos2jCMqBPjdOznBNwUCAJcAy//ngAC7twf8TwOlR/2XAMv/54AA7IVnY+9nESgItwr2T5cAy//ngIC5AUmTigoAgytE+WNmeQ1j6ksF0aBJO5MHAAIZwbcHAgA+hZcAy//ngCC2ybezBCpBY3ObANqEg8dKACaGooVOhYXL7/AP9AU3poUihYk9IT8mhqKFKAiXAMv/54Dgs6aZJpljfkkBswd5QePhh/0BqJfwyv/ngIBpE3X1D2nV/TWBRCMsBPj5W6MJBPgTBTEAl/DK/+eAAFh1+QNFNPksAO/wj9qTFwUBY8IHApO3RACRz4Vnk4cHB6aXipeThweAk4cHgCOKp/iFBH2/4x51+5FH44r08igALAiXAMv/54Dgq1E1wUUoAF07tT3ZOQ3Ntwf8TwOlR/2XAMv/54CA2jcFAgCXAMv/54BAqIViFpH6QGpE2kRKSbpJKkqaSgpL9ltmXA1hgoC9OZMHAAIZwbcHAgA+hfm3t1dBSTVxk4f3hAFFBs8izSbLSslOx1LFVsNawd7e4tzm2urY7tY+3pfwyv/ngEBRPTkFxTdH2FC3ZxFQEwcXqpjPI6AHACOsBwCY09RPNwYEANGO1M8joAcCtwf2Tzc390+ThwcAEwfHvyGgI6AHAJEH4+3n/mU7kUVoGO0xRTtVO7e39k+Th8e2oWq+miOg+gi3CfZPtwf1T5OJCQCThwcPI6D5ANU2YwMFGjcE/E8DJUT9E4aJAIlFlwDL/+eAYMy3Vw5Qk4fHFZhDtwYgAIVFVY+Yw7dnDVATBxACI6rnFkVFlwDL/+eAAJS3FcBPAUaThUWXRUWXAMv/54AAlTcFAgCXAMv/54DAlAMlRP23BfVPk4WlO5cAy//ngADGAyVE/ZcAy//ngEDEAyVE/ZcAy//ngMDCtwcAUJhHE2cXAJjHtwcOUIhfgUU3ivZPcYlhFRM1FQCX8Mr/54CAUOFHBUU+xPwAKsY+woFIAUiBRwFHoUYTBvAJkUUCyALAlwDM/+eAwM2DR+EEQWaFZhOHd/6Tt5cDEzd3AZO3FwDZjyOC+QATBwAQkwf2/7cFAAQBRTcMEVATCsoFDWuX8Mr/54AgQiEMUpuDp8oIY4UHDoOkygiFRyOmCggjAvEEg8cUAAlHIxPhBKMC8QSCxE1HY4/nEFFHY43nEClHY57nAIPHNAADxyQAogfZjxFHY5XnAJxEnEO+xBE5oUXIAJk2g8Y0AIPHJACiBt2OkWfBB2Pz1w4TBbANcTwTBcANWTwTBeAOQTzdNu02vb8FNCnBt2cNUBMHEAK4z4VFRUWX8Mr/54BAfLcF9U8BRpOFBQBFRZfwyv/ngEB9tycNUBFHmMs3BQIAl/DK/+eAgHxVvbcF9U8BRpOFBQQVRZfwyv/ngKB6t6cMUNhHEwUAAhNnFxDYx8m/g8fJAOOHB/A3BQIAI4YJAJfwyv/ngEB4CWUTBQVxl/DK/+eA4B2XAMv/54BgtoMnDAA3BQCA7ZsjIPwAlwDL/+eAgKqXAMv/54DArgFFl/DK/+eAoCB1vclHIxPxBBG3g8cUAFFHY2f3AgVHY2b3AAFJEwTwD9mk+ReT9/cPSUfjaPf+Nzf3T4oHEwcHwLqXnEOChxOHBwMTd/cPEUbjaeb8k4f3ApP39w8NR2Ng9wY3N/dPigcTB8fEupecQ4KHkwdAAmOT9hqCxB1EAUXv8B+VAUV9MkU0eTyhRcgAfRT5Mm30AUkBRJGsierwAIFFAUWX8Mr/54CgGAHFBUQBSTWs0UXoAGUyAUTVvwVE5fqX8Mr/54DAHTM0oADNt6FH4572/AOphADARLNniQDSB/H37/BvzHnxIpmFTBnEMweJQJMXBwHBg6nvQW2FTMF9Y2eNCoVMTcCDx0kAMweJQGOKBw461u/wD6GX8Mr/54DgFjJXZshmxgLEAsICwIFIAUiTBwACoUYTBhAClUUFRZcAzP/ngEChEwQEgBMEBIBdv4PHSQChwzrW7/DPnJfwyv/ngKASMldmyGbGAsQCwgLAgUgBSJMHAAKhRhMGEAKVRQVFlwDM/+eAAJ0TBASAEwQEgKG/E1XHAJfwyv/ngCASbdUTBFADMzSAAAm3g8dJADMHiUCNzzrW7/DPlpfwyv/ngKAMMldmyGbGAsQCwgLAgUgBSJMHAAKhRhMGwA2VRQVFlwDM/+eAAJdulAm/E1UHAZfwyv/ngMAMZdkTBGADXbcTVccAl/DK/+eAQAsF3Um/oUfjj/bmAUkTBAAM8aDBR82/wUcFROOS9ujMRIhE7/A/hUm9k/e2/0FH457n/JhIkWdj7Ock0UeIRMxIAUZjk/YAkEzv8O+5KoSBvZP3tv9BR+Oa5/qcSBFnY2j3IthEiETMSDOJ5wLRRwFGY5P2AJBM7/APt7eH9k+Th8cFDWcjrAcAupcqhCOkJ7E5tbeH9k+Th8cFA8cHAGMHBxiYRMEWEwQADGMT1wDAS4FHEwbwDmPF1waDx1QAA8dEAAFJogfZjwPHZABCB12Pg8d0AOIH2Y9jH/YaE3X0D+/wL/QTdfkP7/Cv8+/wv4LjEQTEg8cUAElHY2n3GglH43n3wvUXk/f3Dz1H42P3wjc390+KBxMHx8W6l5xDgoczh/QAA0eHAYUHOY5pt7eH9k+Th8cFA8cHAG3L2EdjHwcUwEsjgAcAmbvhR2OQ9gLcTJhM1EiQSMxEiESX8Mr/54DA9iqJMzSgAI2/AUkFRLW3kUcFROOU9tK3Fg5Q+F7ld/0XBWZ9j1GPiET43rcWDlCThgYImEKBRX2PUY+YwrcWDlCThkYImEJ9j1GPmMK3Fg5QuF75j9GPvN6X8Mr/54DA+NWxk/f2AOOQB+ST3EYAE4SEAAFJfV3jdZnLSESX8Mr/54DA2xxEWEAQQH2PY4enARRCk8f3//WPXY8YwgUJQQTZv5FH/bvBRwVE45j2yJxE2EgjrPkEI6rpBGmxA6dJBROGBv8R5wHOAUkTBGAMbbWDp4kFY+bHBo2K45YG3IOmiQWBRYFHY+vHAOOLBcKdjj6XI6zZBCOq6QQdsbOF9ACITbMF9wCRB4jBhUXpv6FHBUTjlPbCA6SJBRnAEwSADCOsCQQjqgkEMbMBSRMEIAyhtRMEEAyJtQFJEwSADC29AUkTBJAMDb0TByANY4znBhMHQA3jneemg8U0AIPHJAAThYQBogXdjcEV7/APloW0A6nEAIBE7/CPyeMaBaQJZRMFBXGX8Mr/54BAy7enDFDcSzcHAAFBF5PVRwGSB/mPvYndjbOFJQMBRbPVhQKX8Mr/54CgzBMFgD6X8Mr/54DgxzG01EiQSMxEiETv8A/i/bqDxTQAg8ckABOFhAGiBd2NwRXv8C+w3bKDxzQAA8ckAKIH2Y+TjQf/gyfKAIHnk7ddAJ3Ltzj3TzeJ9k83DfZP4QQFRJOLyL8TCckFkwzNBWOHDQCDJ8oAmcNjTIAAY1UECJMHcAwZoJMHkAwjKvoAcbIDKIuwg6cLAO7AM7gNAQYIswf5QAUIvsZC1u/gP+YDpwsAMlg3hfZPpoX8AOaGkAATBUUHl/DK/+eAwMeGRwMni7CDpQsAs439QB2PvpS2RyMk67AqhL6VI6C7AOF3s4WVQa6XkcMl/RMFzQXv8G+jI6CbAa234xoEkIMnygDjhgeQkweADJW/nETjkAeQ7/BvzgllEwUFcZfwyv/ngMC1l/DK/+eAwLrNsMBE4w8EjO/wT8wTBYA+l/DK/+eAwLMClOGw+kBqRNpESkm6SSpKmkoKS/ZbZlzWXEZdtl0NYYKAAAA=",
                    "text_start": 1341456384,
                    "data": "XAD2T8gQ9U8yEfVPzhH1T6oS9U8SE/VPwBL1TwAP9U9mEvVPphL1T+oR9U+wDvVPEhL1T7AO9U+kEPVP8BD1TzIR9U/OEfVPthD1TyoP9U9eD/VPshD1TwwV9U8yEfVP1hP1T9AU9U/SDfVP8hT1T9IN9U/SDfVP0g31T9IN9U/SDfVP0g31T9IN9U/SDfVPdBP1T9IN9U/uE/VP0BT1Tw==",
                    "data_start": 1341598716,
                    "bss_start": 1341521920
                }
            },
            "esp32p4rc1": {
                "mac_efuse_reg": 0x5012D044,
                "stub":
                {
                    "entry": 1341197206,
                    "text": "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",
                    "text_start": 1341194240,
                    "data": "XAD1T6wQ8U8WEfFPshHxT44S8U/2EvFPpBLxTwQP8U9KEvFPihLxT84R8U+0DvFP9hHxT7QO8U+IEPFP1BDxTxYR8U+yEfFPmhDxTy4P8U9iD/FPlhDxT/AU8U8WEfFPuhPxT7QU8U/WDfFP1hTxT9YN8U/WDfFP1g3xT9YN8U/WDfFP1g3xT9YN8U/WDfFPWBPxT9YN8U/SE/FPtBTxTw==",
                    "data_start": 1341533180,
                    "bss_start": 1341456384
                }
            }
        }
    }
};

/* CommonJS export for Node.js */
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ChipDescriptions;
}

/* For browser environments, ChipDescriptions is already available globally from this script */


    </script>
    <script>
/* Inlined from flasher.js */
/**
 * ESP32 Bootloader Command Codes
 * Commands for communication with ESP32 ROM bootloader and stub loader
 */
const FLASH_BEGIN = 0x02;
const FLASH_DATA = 0x03;
const FLASH_END = 0x04;
const MEM_BEGIN = 0x05;
const MEM_END = 0x06;
const MEM_DATA = 0x07;
const SYNC = 0x08;
const WRITE_REG = 0x09;
const READ_REG = 0x0a;
const SPI_SET_PARAMS = 0x0b;
const SPI_ATTACH = 0x0d;
const CHANGE_BAUDRATE = 0x0f;
const FLASH_DEFL_BEGIN = 0x10;
const FLASH_DEFL_DATA = 0x11;
const FLASH_DEFL_END = 0x12;
const SPI_FLASH_MD5 = 0x13;
const GET_SECURITY_INFO = 0x14;
const ERASE_FLASH = 0xd0;
const ERASE_REGION = 0xd1;
const READ_FLASH = 0xd2;
const RUN_USER_CODE = 0xd3;

/**
 * IMPORTANT: For browser usage, chips.js must be loaded BEFORE flasher.js
 * 
 * This will make ChipDescriptions available globally for flasher.js to use.
 * For Node.js, flasher.js will automatically require('./chips.js')
 */

/* Resolve ChipDescriptions for both browser and Node environments */
const ChipDescriptionsClass = typeof ChipDescriptions !== 'undefined'
    ? ChipDescriptions
    : (typeof require !== 'undefined' ? require('./chips.js') : null);

/* ESP32 Reset Reason Codes (from ESP-IDF esp_system.h) */
const RESET_REASON_MAP = {
    0: { name: 'NO_MEAN', desc: 'No reset reason' },
    1: { name: 'POWERON_RESET', desc: 'Vbat power on reset' },
    3: { name: 'RTC_SW_SYS_RESET', desc: 'Software reset digital core' },
    5: { name: 'DEEPSLEEP_RESET', desc: 'Deep Sleep reset digital core' },
    7: { name: 'TG0WDT_SYS_RESET', desc: 'Timer Group0 Watch dog reset digital core' },
    8: { name: 'TG1WDT_SYS_RESET', desc: 'Timer Group1 Watch dog reset digital core' },
    9: { name: 'RTCWDT_SYS_RESET', desc: 'RTC Watch dog Reset digital core' },
    10: { name: 'INTRUSION_RESET', desc: 'Intrusion tested to reset CPU' },
    11: { name: 'TG0WDT_CPU_RESET', desc: 'Timer Group0 reset CPU' },
    12: { name: 'RTC_SW_CPU_RESET', desc: 'Software reset CPU' },
    13: { name: 'RTCWDT_CPU_RESET', desc: 'RTC Watch dog Reset CPU' },
    15: { name: 'RTCWDT_BROWN_OUT_RESET', desc: 'Reset when the vdd voltage is not stable' },
    16: { name: 'RTCWDT_RTC_RESET', desc: 'RTC Watch dog reset digital core and rtc module' },
    17: { name: 'TG1WDT_CPU_RESET', desc: 'Timer Group1 reset CPU' },
    18: { name: 'SUPER_WDT_RESET', desc: 'Super watchdog reset digital core and rtc module' },
    19: { name: 'GLITCH_RTC_RESET', desc: 'Glitch reset digital core and rtc module' },
    20: { name: 'EFUSE_RESET', desc: 'eFuse reset digital core' },
    21: { name: 'USB_UART_CHIP_RESET', desc: 'USB UART reset digital core' },
    22: { name: 'USB_JTAG_CHIP_RESET', desc: 'USB JTAG reset digital core' },
    23: { name: 'POWER_GLITCH_RESET', desc: 'Power glitch reset digital core and rtc module' }
};

const CHIP_ID_MAP = {
    0x0000: 'esp32',
    0x0002: 'esp32s2',
    0x0005: 'esp32c3',
    0x0009: 'esp32s3',
    0x000C: 'esp32c2',
    0x000D: 'esp32c6',
    0x0010: 'esp32h2',
    0x0012: 'esp32p4',
    0x0017: 'esp32c5',
    0x0014: 'esp32c61',
    0x0019: 'esp32h21',
    0x001C: 'esp32h4',
    0x0020: 'esp32s31',
    0xFFFF: 'Invalid'
};

/**
 * SLIP Protocol Layer Handler
 * Implements Serial Line IP (RFC 1055) encoding/decoding for packet framing
 */
class SlipLayer {
    /**
     * Initialize SLIP layer with empty buffer
     */
    constructor() {
        this.buffer = [];
        this.escaping = false;
        this.verbose = true;
        this.logPackets = false;
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    /**
     * Log SLIP layer data with color coding
     * @param {Uint8Array} data - Data to log
     * @param {string} type - 'ENCODE' or 'DECODE'
     * @param {string} label - Description label
     */
    logSlipData(data, type, label) {
        if (!this.verbose) return;

        this._preSyncState = 'idle';
        const isEncode = type === 'ENCODE'; const color = isEncode ? 'color: #FFC107; font-weight: bold' : 'color: #9C27B0; font-weight: bold';

        const bgColor = isEncode ? 'background: #F57F17; color: #000' : 'background: #6A1B9A; color: #fff';
        const symbol = isEncode ? 'â–¶' : 'â—€';

        const maxBytes = 128;
        const bytesToShow = Math.min(data.length, maxBytes);
        const truncated = data.length > maxBytes;

        let hexStr = '';
        let asciiStr = '';
        let lines = [];

        for (let i = 0; i < bytesToShow; i++) {
            const byte = data[i];
            hexStr += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
            asciiStr += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';

            if ((i + 1) % 16 === 0 || i === bytesToShow - 1) {
                const hexPadding = ' '.repeat(Math.max(0, (16 - ((i % 16) + 1)) * 3));
                lines.push(`    ${hexStr}${hexPadding} | ${asciiStr}`);
                hexStr = '';
                asciiStr = '';
            }
        }

        if (this.logPackets) {
            const truncMsg = truncated ? ` (showing ${bytesToShow}/${data.length} bytes)` : '';
            this.logDebug(`${symbol} SLIP ${type} ${label} [${data.length} bytes]${truncMsg}`);
            lines.forEach(line => this.logDebug(line));
        }
    }

    /**
     * Encode data using SLIP framing
     * Wraps packet with SLIP_END delimiters and escapes special bytes
     * @param {Uint8Array} packet - Raw packet data
     * @returns {Uint8Array} SLIP-framed packet with delimiters
     */
    encode(packet) {
        const SLIP_END = 0xC0;
        const SLIP_ESC = 0xDB;
        const SLIP_ESC_END = 0xDC;
        const SLIP_ESC_ESC = 0xDD;

        if (this.logPackets) {
            this.logSlipData(packet, 'ENCODE', 'Payload before framing');
        }

        let slipFrame = [SLIP_END];

        for (let byte of packet) {
            if (byte === SLIP_END) {
                slipFrame.push(SLIP_ESC, SLIP_ESC_END);
            } else if (byte === SLIP_ESC) {
                slipFrame.push(SLIP_ESC, SLIP_ESC_ESC);
            } else {
                slipFrame.push(byte);
            }
        }

        slipFrame.push(SLIP_END);
        const result = new Uint8Array(slipFrame);

        return result;
    }

    /**
     * Decode SLIP-framed packet stream
     * Extracts complete packets from framed data, handling escape sequences
     * @param {Uint8Array|ArrayLike} value - SLIP-encoded bytes
     * @returns {Uint8Array[]} Array of decoded complete packets
     */
    decode(value) {
        const SLIP_END = 0xC0;
        const SLIP_ESC = 0xDB;
        const SLIP_ESC_END = 0xDC;
        const SLIP_ESC_ESC = 0xDD;

        let outputPackets = [];

        for (let byte of value) {
            if (byte === SLIP_END) {
                if (this.buffer.length > 0) {
                    const packet = new Uint8Array(this.buffer);
                    outputPackets.push(packet);
                    this.buffer = [];
                }
            } else if (this.escaping) {
                if (byte === SLIP_ESC_END) {
                    this.buffer.push(0xC0);
                } else if (byte === SLIP_ESC_ESC) {
                    this.buffer.push(0xDB);
                }
                this.escaping = false;
            } else if (byte === SLIP_ESC) {
                this.escaping = true;
            } else {
                this.buffer.push(byte);
            }
        }

        if (this.logPackets) {
            // Log decoded packets
            for (let i = 0; i < outputPackets.length; i++) {
                const label = outputPackets.length > 1 ? `Decoded packet ${i + 1}/${outputPackets.length}` : 'Decoded packet';
                this.logSlipData(outputPackets[i], 'DECODE', label);
            }
        }

        return outputPackets;
    }
}

/**
 * WebUSBSerial - Web Serial API-like wrapper for WebUSB
 * Provides a familiar interface for serial communication over USB
 */
class WebUSBSerial {
    constructor() {
        this.device = null;
        this.interfaceNumber = null;
        this.endpointIn = null;
        this.endpointOut = null;
        this.controlInterface = null;
        this.readableStream = null;
        this.writableStream = null;
        this._reader = null;
        this._writer = null;
        this._readLoopRunning = false;
        this._usbDisconnectHandler = null;
        this._eventListeners = {
            'close': [],
            'disconnect': []
        };
        this.logger = null; /* optional {info, error} callbacks for UI logging */
        this.maxTransferSize = 0x10000;
    }

    /**
     * Request USB device (mimics navigator.serial.requestPort())
     * @returns {Promise<WebUSBSerial>} This instance
     */
    static async requestPort() {
        const filters = [
            { vendorId: 0x303A }, // Espressif
            { vendorId: 0x0403 }, // FTDI
            { vendorId: 0x1A86 }, // CH340
            { vendorId: 0x10C4 }, // CP210x
            { vendorId: 0x067B }  // PL2303
        ];

        const device = await navigator.usb.requestDevice({ filters });
        const port = new WebUSBSerial();
        port.device = device;
        return port;
    }

    /**
     * Open the USB device (mimics port.open())
     * @param {Object} options - {baudRate: number}
     * @returns {Promise<void>}
     */
    async open(options = {}) {
        if (!this.device) {
            throw new Error('No device selected');
        }

        /* If already open (e.g., prior attempt), close to avoid stale claims */
        if (this.device.opened) {
            try { await this.device.close(); } catch (e) { }
        }

        /* Best-effort reset before attempting to open (helps if host kept a stale claim) */
        try { if (this.device.reset) { await this.device.reset(); } } catch (e) { }

        const attemptOpenAndClaim = async () => {
            await this.device.open();
            try {
                /* Ensure configuration 1 is selected; some hosts keep a different active config */
                const currentCfg = this.device.configuration ? this.device.configuration.configurationValue : null;
                if (!currentCfg || currentCfg !== 1) {
                    await this.device.selectConfiguration(1);
                }
            } catch (e) { /* ignore config select errors */ }

            const config = this.device.configuration;

            /* Try to claim CDC control interface FIRST on Android/CH34x to unblock data iface claim */
            const preControlIface = config.interfaces.find(i => i.alternates && i.alternates[0] && i.alternates[0].interfaceClass === 0x02);
            if (preControlIface) {
                try {
                    await this.device.claimInterface(preControlIface.interfaceNumber);
                    /* Ensure alt setting 0 is active */
                    try { await this.device.selectAlternateInterface(preControlIface.interfaceNumber, 0); } catch (e) { }
                    this.controlInterface = preControlIface.interfaceNumber;
                    this.logMessage(`[WebUSB] Pre-claimed CDC control iface ${preControlIface.interfaceNumber}`);
                } catch (e) {
                    this.logError(`[WebUSB] Could not pre-claim CDC control iface ${preControlIface.interfaceNumber}: ${e && e.message ? e.message : e}`);
                }
            }

            /* Collect all bulk IN/OUT interfaces and try preferred ones first (CDC > vendor > other)
               Rationale: Espressif composite devices expose CDC data on iface 1 (class 0x0A) and JTAG/debug on vendor iface 2.
               Selecting CDC first avoids landing on a non-UART function that won't speak the ROM bootloader. */
            const candidates = [];
            for (const iface of config.interfaces) {
                const alt = iface.alternates[0];
                let hasIn = false, hasOut = false;
                for (const ep of alt.endpoints) {
                    if (ep.type === 'bulk' && ep.direction === 'in') hasIn = true;
                    if (ep.type === 'bulk' && ep.direction === 'out') hasOut = true;
                }
                if (hasIn && hasOut) {
                    let score = 2; /* default */
                    if (alt.interfaceClass === 0x0a) score = 0; /* CDC data first */
                    else if (alt.interfaceClass === 0xff) score = 1; /* vendor-specific next */
                    candidates.push({ iface, score });
                }
            }

            if (!candidates.length) {
                await this._dumpDeviceDetails('No suitable USB interface found');
                throw new Error('No suitable USB interface found');
            }

            candidates.sort((a, b) => a.score - b.score);
            let lastErr = null;
            for (const cand of candidates) {
                try {
                    /* Ensure alt setting 0 before claiming */
                    try { await this.device.selectAlternateInterface(cand.iface.interfaceNumber, 0); } catch (e) { }
                    await this.device.claimInterface(cand.iface.interfaceNumber);
                    this.interfaceNumber = cand.iface.interfaceNumber;

                    /* Get endpoints */
                    const alt = cand.iface.alternates[0];
                    for (const ep of alt.endpoints) {
                        if (ep.type === 'bulk' && ep.direction === 'in') {
                            this.endpointIn = ep.endpointNumber;
                        } else if (ep.type === 'bulk' && ep.direction === 'out') {
                            this.endpointOut = ep.endpointNumber;
                        }
                    }
                    /* Adopt endpoint packet size as transfer length (Android prefers max-packet) */
                    try {
                        const inEp = alt.endpoints.find(ep => ep.type === 'bulk' && ep.direction === 'in');
                        if (inEp && inEp.packetSize) {
                            this.maxTransferSize = Math.min(inEp.packetSize, 64);
                        }
                    } catch (e) { }
                    this.logMessage(`[WebUSB] Claimed iface ${cand.iface.interfaceNumber} (class=${alt.interfaceClass}) with IN=${this.endpointIn} OUT=${this.endpointOut}`);
                    return config;
                } catch (claimErr) {
                    lastErr = claimErr;
                    this.logError(`[WebUSB] claim failed on iface ${cand.iface.interfaceNumber} (class=${cand.iface.alternates[0].interfaceClass}): ${claimErr && claimErr.message ? claimErr.message : claimErr}`);
                }
            }

            await this._dumpDeviceDetails('All candidate interfaces failed to claim', lastErr);
            this.logMessage('[WebUSB] If you are on Windows and see repeat claim failures, ensure the interface is bound to WinUSB (e.g., via Zadig) and close any app using it.');
            throw lastErr || new Error('Unable to claim any USB interface');
        };

        let config;
        try {
            config = await attemptOpenAndClaim();
        } catch (err) {
            console.warn('[WebUSBSerial-flasher] open/claim failed:', err.message);
            await this._dumpDeviceDetails('open/claim failed (first attempt)', err);
            /* Retry once after a best-effort device reset/close to clear stale claims (common on Android) */
            console.warn('[WebUSBSerial-flasher] claimInterface failed, retrying after reset/close:', err.message);
            try { if (this.device.reset) { await this.device.reset(); } } catch (e) { }
            try { await this.device.close(); } catch (e) { }
            try {
                config = await attemptOpenAndClaim();
            } catch (err2) {
                await this._dumpDeviceDetails('claimInterface failed (retry)', err2);
                throw new Error(`Unable to claim USB interface. This can happen if another app has the device open or Android retained a stale claim. Unplug/replug the device, close other apps, and retry. Original: ${err2.message}`);
            }
        }

        /* Control iface may already be claimed in attemptOpenAndClaim; avoid double-claim */
        if (this.controlInterface == null) {
            const controlIface = config.interfaces.find(i =>
                i.alternates[0].interfaceClass === 0x02 &&
                i.interfaceNumber !== this.interfaceNumber
            );

            if (controlIface) {
                try {
                    await this.device.claimInterface(controlIface.interfaceNumber);
                    try { await this.device.selectAlternateInterface(controlIface.interfaceNumber, 0); } catch (e) { }
                    this.controlInterface = controlIface.interfaceNumber;
                } catch (e) {
                    /* Use data interface for control if claim fails */
                    this.controlInterface = this.interfaceNumber;
                }
            } else {
                this.controlInterface = this.interfaceNumber;
            }
        }

        // Set line coding
        const baudRate = options.baudRate || 115200;
        try {
            const lineCoding = new Uint8Array([
                baudRate & 0xFF,
                (baudRate >> 8) & 0xFF,
                (baudRate >> 16) & 0xFF,
                (baudRate >> 24) & 0xFF,
                0x00, // 1 stop bit
                0x00, // No parity
                0x08  // 8 data bits
            ]);

            await this.device.controlTransferOut({
                requestType: 'class',
                recipient: 'interface',
                request: 0x20, // SET_LINE_CODING
                value: 0,
                index: this.controlInterface
            }, lineCoding);
        } catch (e) {
            console.warn('Could not set line coding:', e.message);
        }

        // Assert DTR/RTS
        try {
            await this.device.controlTransferOut({
                requestType: 'class',
                recipient: 'interface',
                request: 0x22, // SET_CONTROL_LINE_STATE
                value: 0x03, // DTR=1, RTS=1
                index: this.controlInterface
            });
        } catch (e) {
            console.warn('Could not set control lines:', e.message);
        }

        // Create streams
        this._createStreams();

        // Setup disconnect handler
        this.logDebug('[WebUSBSerial-flasher] Setting up USB disconnect handler');
        this._usbDisconnectHandler = (event) => {
            this.logDebug('[WebUSBSerial-flasher] USB disconnect event fired, device:', event.device.productId);
            if (event.device === this.device) {
                this.logDebug('[WebUSBSerial-flasher] Device matches, firing close event');
                // Fire 'close' event to mimic Web Serial behavior
                this._fireEvent('close');
                this._cleanup();
            } else {
                this.logDebug('[WebUSBSerial-flasher] Device mismatch - different device disconnected');
            }
        };
        navigator.usb.addEventListener('disconnect', this._usbDisconnectHandler);
        this.logDebug('[WebUSBSerial-flasher] Disconnect handler registered with navigator.usb');
    }

    /**
     * Close the device (mimics port.close())
     * @returns {Promise<void>}
     */
    async close() {
        this._cleanup();
        if (this.device) {
            try {
                if (this.interfaceNumber !== null) {
                    await this.device.releaseInterface(this.interfaceNumber);
                }
                if (this.controlInterface !== null && this.controlInterface !== this.interfaceNumber) {
                    await this.device.releaseInterface(this.controlInterface);
                }
                await this.device.close();
            } catch (e) {
                // Ignore errors if device already disconnected
                if (!e.message || !e.message.includes('disconnected')) {
                    console.warn('Error closing device:', e.message || e);
                }
            }
            this.device = null;
        }
    }

    /* Dump detailed device info for diagnostics */
    async _dumpDeviceDetails(label, err) {
        try {
            if (!this.device) {
                this.logMessage(`[WebUSB] ${label}: no device set`);
                return;
            }
            const d = this.device;
            const lines = [];
            lines.push(`[WebUSB] ${label}: ${err && err.message ? err.message : err || ''}`);
            lines.push(`[WebUSB] Basic: opened=${d.opened} vid=0x${(d.vendorId || 0).toString(16).padStart(4, '0')} pid=0x${(d.productId || 0).toString(16).padStart(4, '0')}`);
            lines.push(`[WebUSB] Strings: product="${d.productName || 'n/a'}" manufacturer="${d.manufacturerName || 'n/a'}" serial="${d.serialNumber || 'n/a'}"`);
            const cfg = d.configuration;
            if (!cfg) {
                lines.push('[WebUSB] No active configuration');
                this.logMessage(lines.join('\n'));
                return;
            }
            lines.push(`[WebUSB] Active config: value=${cfg.configurationValue} interfaces=${cfg.interfaces.length}`);
            for (const iface of cfg.interfaces) {
                const alt = iface.alternates[0];
                lines.push(`[WebUSB]  iface ${iface.interfaceNumber}: class=${alt.interfaceClass} subclass=${alt.interfaceSubclass} proto=${alt.interfaceProtocol} eps=${alt.endpoints.length}`);
                for (const ep of alt.endpoints) {
                    lines.push(`[WebUSB]    ep ${ep.endpointNumber}: dir=${ep.direction} type=${ep.type} packetSize=${ep.packetSize}`);
                }
            }
            this.logMessage(lines.join('\n'));
        } catch (dumpErr) {
            this.logError(`[WebUSB] Failed to dump device details: ${dumpErr && dumpErr.message ? dumpErr.message : dumpErr}`);
        }
    }

    /**
     * Get device info (mimics port.getInfo())
     * @returns {Object} {usbVendorId, usbProductId}
     */
    getInfo() {
        if (!this.device) {
            return {};
        }
        return {
            usbVendorId: this.device.vendorId,
            usbProductId: this.device.productId
        };
    }

    /**
     * Set DTR/RTS signals (mimics port.setSignals())
     * @param {Object} signals - {dataTerminalReady, requestToSend}
     * @returns {Promise<void>}
     */
    async setSignals(signals) {
        if (!this.device) {
            throw new Error('Device not open');
        }

        var value = 0;
        value |= signals.dataTerminalReady ? 1 : 0;
        value |= signals.requestToSend ? 2 : 0;

        return this.device.controlTransferOut({
            requestType: 'class',
            recipient: 'interface',
            request: 0x22, /* CDC_SET_CONTROL_LINE_STATE */
            value: value,
            index: this.controlInterface
        });
    }

    /**
     * Get readable stream
     */
    get readable() {
        return this.readableStream;
    }

    /**
     * Get writable stream
     */
    get writable() {
        return this.writableStream;
    }

    /**
     * Create ReadableStream and WritableStream
     * @private
     */
    _createStreams() {
        // ReadableStream for incoming data
        this.readableStream = new ReadableStream({
            start: async (controller) => {
                this._readLoopRunning = true;

                try {
                    while (this._readLoopRunning && this.device) {
                        try {
                            /* Request one max-packet worth; large sizes can stall on some Android stacks */
                            const result = await this.device.transferIn(this.endpointIn, this.maxTransferSize);

                            if (result.status === 'ok') {
                                controller.enqueue(new Uint8Array(result.data.buffer, result.data.byteOffset, result.data.byteLength));
                                continue;
                            } else if (result.status === 'stall') {
                                await this.device.clearHalt('in', this.endpointIn);
                                await new Promise(r => setTimeout(r, 1));
                                continue;
                            } else {
                                console.warn('USB transferIn returned status:', result.status);
                            }
                            /* No data or zero-length transfer: immediately loop */
                            await new Promise(r => setTimeout(r, 1));
                        } catch (error) {
                            if (error.message && (error.message.includes('device unavailable') ||
                                error.message.includes('device has been lost') ||
                                error.message.includes('device was disconnected') ||
                                error.message.includes('No device selected'))) {
                                break;
                            }
                            if (error.message && (error.message.includes('transfer was cancelled') ||
                                error.message.includes('transfer error has occurred'))) {
                                continue;
                            }
                            /* Log other errors but continue */
                            console.warn('USB read error:', error.message);
                        }
                    }
                } catch (error) {
                    controller.error(error);
                } finally {
                    controller.close();
                }
            },
            cancel: () => {
                console.log('[WebUSBSerial-flasher] Read loop canceled');
                this._readLoopRunning = false;
            }
        });

        // WritableStream for outgoing data
        this.writableStream = new WritableStream({
            write: async (chunk) => {
                if (!this.device) {
                    throw new Error('Device not open');
                }
                await this.device.transferOut(this.endpointOut, chunk);
            }
        });
    }

    /**
     * Cleanup resources
     * @private
     */
    _cleanup() {
        console.log('[WebUSBSerial-flasher] Cleanup called');
        this._readLoopRunning = false;
        if (this._usbDisconnectHandler) {
            navigator.usb.removeEventListener('disconnect', this._usbDisconnectHandler);
            this._usbDisconnectHandler = null;
            console.log('[WebUSBSerial-flasher] Disconnect handler unregistered');
        }
    }

    /**
     * Fire event to all registered listeners
     * @private
     */
    _fireEvent(type) {
        const listeners = this._eventListeners[type] || [];
        console.log(`[WebUSBSerial-flasher] Firing '${type}' event to ${listeners.length} listener(s)`);
        listeners.forEach(listener => {
            try {
                listener();
            } catch (e) {
                console.error(`Error in ${type} event listener:`, e);
            }
        });
    }

    /**
     * Add event listener (mimics addEventListener for 'close' and 'disconnect')
     * @param {string} type - Event type
     * @param {Function} listener - Event handler
     */
    addEventListener(type, listener) {
        if (this._eventListeners[type]) {
            this._eventListeners[type].push(listener);
            console.log(`[WebUSBSerial-flasher] addEventListener('${type}') - now have ${this._eventListeners[type].length} listener(s)`);
        } else {
            console.log(`[WebUSBSerial-flasher] addEventListener('${type}') - unknown event type`);
        }
    }

    /**
     * Remove event listener
     * @param {string} type - Event type
     * @param {Function} listener - Event handler
     */
    removeEventListener(type, listener) {
        if (this._eventListeners[type]) {
            const index = this._eventListeners[type].indexOf(listener);
            if (index !== -1) {
                this._eventListeners[type].splice(index, 1);
            }
        }
    }
}

/**
 * ESP32 Bootloader Communication Handler
 * Manages serial communication with ESP32 devices using bootloader protocol
 * Supports reading/writing flash, downloading code to RAM, and firmware verification
 * @class ESPFlasher
 */
class ESPFlasher {

    /**
     * Initialize ESP32 flasher instance
     * Creates new instance with default configuration and empty state
     */
    constructor(options = {}) {
        this.devMode = options.devMode || false;
        this.logDebug = options.logDebug || ((msg) => { });
        this.logError = options.logError || ((msg) => { });
        this.logWarning = options.logWarning || ((msg) => { });
        this.logMessage = options.logMessage || ((msg) => { });
        this.logPackets = options.logPackets || false;

        /*
        Technical Limitation:
            Web Serial cannot change the baud rate without reopening the port, which may reset the device.
            Therefore, this tool keeps a single baud rate from start to end.
            ESP32 ROM prints its reset messages at 115200 baud.
            
            When using a USB-UART adapter with RX/TX wiring:
            - Use 115200 to see ROM reset messages (slower link), or
            - Use a higher baud (e.g., 921600) for speed but you will not see reset messages.

            This does not apply to native USB/JTAG interfaces of course.

            Normal ESP32 needs 115200 or 250000 for any operation.
        */
        this.initialBaudRate = options.initialBaudRate || 921600;



        this.chip_magic_addr = 0x40001000;
        this.chip_descriptions = new ChipDescriptionsClass().chip_descriptions;
        this.port = null;
        this.currentAddress = 0x0000;
        this.current_chip = "none";
        this.stubLoaded = false;
        this.responseHandlers = new Map();
        this.buffer = [];
        this.escaping = false;
        this.slipLayer = new SlipLayer();
        this.synced = false;
        this.consoleBuffer = '';
        this._preSyncState = 'idle';
        this.reader = null;
        this.dtrState = true;
        this.rtsState = true;

        /* Command execution lock to prevent concurrent command execution */
        this._commandLock = Promise.resolve();

        /* Persistent writer + queued writes to avoid WritableStream lock contention */
        this._activeWriter = null;
        this._writeChain = Promise.resolve();
    }

    /**
     * Ensure a single persistent WritableStreamDefaultWriter exists
     * @private
     */
    async _ensureWriter() {
        if (!this.port || !this.port.writable) {
            throw new Error('Port is not writable.');
        }
        if (!this._activeWriter) {
            this._activeWriter = this.port.writable.getWriter();
        }
        return this._activeWriter;
    }

    /**
     * Queue a write on the persistent writer to serialize all writes
     * @private
     */
    async _writeFrame(frame) {
        this._writeChain = this._writeChain.then(async () => {
            const writer = await this._ensureWriter();
            this.logSerialData(frame, true);
            await writer.write(frame);
        });
        return this._writeChain;
    }

    /**
     * Release the persistent writer if held
     * @private
     */
    _releaseWriter() {
        if (this._activeWriter) {
            try { this._activeWriter.releaseLock(); } catch (e) { }
            this._activeWriter = null;
        }
    }

    /**
     * Format bytes as colored hex dump for console
     * @param {Uint8Array} data - Data to format
     * @param {string} isTx - 'TX' or 'RX'
     * @param {number} maxBytes - Maximum bytes to show (default: 256)
     */
    logSerialData(data, isTx, maxBytes = 256) {
        if (!this.logPackets) return;

        const arrow = isTx ? 'â†’' : 'â†';

        const bytesToShow = Math.min(data.length, maxBytes);
        const truncated = data.length > maxBytes;

        // Format hex string with spaces every 2 bytes and newline every 16 bytes
        let hexStr = '';
        let asciiStr = '';
        let lines = [];

        for (let i = 0; i < bytesToShow; i++) {
            const byte = data[i];
            hexStr += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
            asciiStr += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';

            if ((i + 1) % 16 === 0 || i === bytesToShow - 1) {
                // Pad hex string to align ASCII
                const hexPadding = ' '.repeat(Math.max(0, (16 - ((i % 16) + 1)) * 3));
                lines.push(`  ${hexStr}${hexPadding} | ${asciiStr}`);
                hexStr = '';
                asciiStr = '';
            }
        }
        if (this.logPackets) {
            const truncMsg = truncated ? ` (showing ${bytesToShow}/${data.length} bytes)` : '';
            this.logDebug(`${arrow} ${isTx} [${data.length} bytes]${truncMsg}`);
            lines.forEach(line => this.logDebug(line));
        }
    }

    /**
     * Open serial port and start reading packets
     * @async
     * @returns {Promise<void>}
     * @throws {Error} If port request fails
     */
    async openPort() {
        /* Require Web Serial API (available in Chrome/Edge) */
        if (typeof navigator === 'undefined' || !navigator.serial) {
            throw new Error('Web Serial API not available. Please use Chrome or Edge.');
        }

        const port = await navigator.serial.requestPort();
        return this.openPortWithPort(port);
    }

    /**
     * Open a provided serial port (Web Serial or WebUSB)
     * @async
     * @param {SerialPort|WebUSBSerial} port - Port instance to open
     * @returns {Promise<void>}
     * @throws {Error} If connection fails
     */
    async openPortWithPort(port) {
        return new Promise(async (resolve, reject) => {

            /* Open the port */
            try {
                this.port = port;

                /* If WebUSBSerial, provide logger callbacks so low-level dumps reach UI log */
                if (this.port instanceof WebUSBSerial) {
                    this.port.logger = {
                        info: (msg) => { this.logDebug && this.logDebug(msg); },
                        error: (msg) => { this.logError && this.logError(msg); }
                    };
                }

                await this.port.open({ baudRate: this.initialBaudRate });

                /* Get and log VID/PID information */
                const portInfo = this.port.getInfo();
                if (portInfo.usbVendorId !== undefined && portInfo.usbProductId !== undefined) {
                    const vid = portInfo.usbVendorId;
                    const pid = portInfo.usbProductId;
                    this.logDebug(`Device: VID=0x${vid.toString(16).padStart(4, '0').toUpperCase()}, PID=0x${pid.toString(16).padStart(4, '0').toUpperCase()}`);

                    /* Check for Espressif USB JTAG device */
                    if (vid === 0x303A) {
                        this.logDebug('Detected Espressif USB JTAG device - high baud rates supported, bootloader messages will be visible');
                        this.isEspressifUsbJtag = true;
                    } else {
                        this.isEspressifUsbJtag = false;
                    }
                } else {
                    this.logDebug('Device: VID/PID information not available (may not be a USB device)');
                    this.isEspressifUsbJtag = false;
                }
            } catch (error) {
                reject(error);
                return;
            }


            // Register for device lost (Web Serial API)
            if (navigator.serial) {
                navigator.serial.addEventListener('disconnect', (event) => {
                    if (event.target === this.port) {
                        this.logError(`The device was disconnected`);
                        this.disconnect();
                    }
                });
            }

            // Register for port closing
            if (this.port.addEventListener) {
                this.port.addEventListener('close', () => {
                    if (!this._disconnecting) {
                        this.logError('Device disconnected unexpectedly');
                    }
                });
            }

            resolve();

            /* Set up reading from the port */
            this.reader = this.port.readable.getReader();

            this.startRxLoop();
        });
    }

    async startRxLoop() {
        try {
            while (true) {
                if (typeof performance !== 'undefined' && performance.mark && performance.measure) {
                    performance.mark('esp32_flasher_receive_start');
                }
                const { value, done } = await this.reader.read();
                if (typeof performance !== 'undefined' && performance.mark && performance.measure) {
                    performance.mark('esp32_flasher_receive_end');
                    try {
                        performance.measure('esp32_flasher_receive', 'esp32_flasher_receive_start', 'esp32_flasher_receive_end');
                    } catch (measureErr) {
                    }
                }
                if (done) {
                    this.logDebug('Reader has been canceled');
                    break;
                }
                if (value) {
                    this.logSerialData(value, false);
                    this.parseResetMessages(value);
                    const packets = this.slipLayer.decode(value);
                    for (let packet of packets) {
                        await this.processPacket(packet);
                    }
                }
            }
        } catch (err) {
            // Handle cancellation
        } finally {
            if (this.reader) {
                this.reader.releaseLock();
                this.reader = null;
            }
        }
    }

    /**
     * Reopen the existing serial port with a new baud rate
     * Closes the current reader and port, then opens the same port at `baudRate`
     * and restarts the RX loop without re-requesting the device.
     * @async
     * @param {number} baudRate - New baud rate to use
     * @returns {Promise<void>}
     * @throws {Error} If port is not selected/openable
     */
    async reopenPort(baudRate) {
        if (!this.port) {
            throw new Error('No port selected. Call openPort() first to choose a device.');
        }

        /* Stop existing reader if any */
        if (this.reader) {
            try {
                await this.reader.cancel();
            } catch (error) {
                /* Ignore cancellation errors */
            }
            try {
                this.reader.releaseLock();
            } catch (e) {
                /* Ignore release errors */
            }
            this.reader = null;
        }

        /* Wait for pending writes and release writer before closing */
        try {
            await this._writeChain;
        } catch (e) { /* Ignore pending write errors on reopen */ }
        this._releaseWriter();

        /* Close and reopen the same port with new baud */
        try {
            await this.port.close();
        } catch (error) {
            /* Ignore close errors, we will try to open regardless */
        }

        const newBaud = baudRate || this.initialBaudRate;
        this.initialBaudRate = newBaud;
        await this.port.open({ baudRate: newBaud });

        /* Restart RX loop (do not re-register global listeners to avoid duplicates) */
        this.reader = this.port.readable.getReader();

        this.startRxLoop();
    }

    parseResetMessages(data) {
        /*
        ESP32
            ets Jun  8 2016 00:22:57

            rst:0x1 (POWERON_RESET),boot:0x1 (DOWNLOAD_BOOT(UART0/UART1/SDIO_FEI_REO_V2))
            waiting for download
           
        ESP32-S3 (normal)     
            ESP-ROM:esp32s3-20210327
            Build:Mar 27 2021
            rst:0x1 (POWERON),boot:0x0 (DOWNLOAD(USB/UART0))
            waiting for download

        ESP32-C3 (secure)
            ESP-ROM:esp32c3-api1-20210207
            Build:Feb  7 2021
            rst:0x15 (USB_UART_CHIP_RESET),boot:0x5 (DOWNLOAD(USB/UART0/1))
            Saved PC:0x4004d1f8
            wait uart download(secure mode)

        ESP32-C3 (normal)
            ESP-ROM:esp32c3-api1-20210207
            Build:Feb  7 2021
            rst:0x15 (USB_UART_CHIP_RESET),boot:0x7 (DOWNLOAD(USB/UART0/1))
            Saved PC:0x4004c0d4
            waiting for download

        */


        /* Only care about pre-sync console chatter */
        if (!data || !data.length) {
            return;
        }

        /* Accumulate printable ASCII and newlines */
        let chunk = '';
        for (let i = 0; i < data.length; i++) {
            const b = data[i];
            if (b === 10 || b === 13) {
                chunk += '\n';
            } else if (b >= 32 && b <= 126) {
                chunk += String.fromCharCode(b);
            }
        }

        if (!chunk.length) {
            return;
        }

        this.consoleBuffer = (this.consoleBuffer || '') + chunk;

        let newlineIdx = this.consoleBuffer.indexOf('\n');
        while (newlineIdx !== -1) {
            const line = this.consoleBuffer.slice(0, newlineIdx).trim();
            this.consoleBuffer = this.consoleBuffer.slice(newlineIdx + 1);
            if (line.length) {
                // Only print device messages if not yet synced
                if (!this.synced) {
                    this.logDebug(`[Device] ${line}`);
                }

                const lower = line.toLowerCase();
                const rstBootMatch = line.match(/rst:0x([0-9a-f]+)/i);
                const bootMatch = line.match(/boot:0x([0-9a-f]+)/i);

                if (rstBootMatch && bootMatch) {
                    const rst = parseInt(rstBootMatch[1], 16);
                    const boot = parseInt(bootMatch[1], 16);
                    const rstInfo = RESET_REASON_MAP[rst] || { name: 'UNKNOWN', desc: `Unknown reset reason 0x${rst.toString(16)}` };
                    this.deviceStateCallback && this.deviceStateCallback('reboot', { rst, rstName: rstInfo.name, rstDesc: rstInfo.desc, boot });
                    /* Enable mode detection after reboot line */
                    this._preSyncState = 'seen_reboot';
                }

                /* State machine: after reboot line, accept one mode line */
                if (this._preSyncState === 'seen_reboot') {
                    if (lower.includes('(secure mode)')) {
                        this.deviceStateCallback && this.deviceStateCallback('secure');
                        this._preSyncState = 'idle';
                    } else if (lower.includes('waiting for download') || lower.includes('wait uart download')) {
                        this.deviceStateCallback && this.deviceStateCallback('download');
                        this._preSyncState = 'idle';
                    }
                }

            }
            newlineIdx = this.consoleBuffer.indexOf('\n');
        }
    }

    /**
     * Read 32-bit value from chip register
     * @async
     * @param {number} addr - Register address
     * @returns {Promise<number>} Register value
     */
    async readReg(addr) {
        return this.executeCommand(this.buildCommandPacketU32(READ_REG, addr),
            async (resolve, reject, responsePacket) => {
                if (responsePacket) {
                    resolve(responsePacket.value);
                } else {
                    reject('Failed to read register');
                }
            });
    }


    /**
     * Detect if stub loader is running on device
     * @async
     * @returns {Promise<boolean>} True if stub loader active, false if ROM bootloader
     * @throws {Error} If detection fails
     * @description Distinguishes stub loader from ROM bootloader by magic address response size
     */
    async isStubLoader() {
        return this.executeCommand(this.buildCommandPacketU32(READ_REG, this.chip_magic_addr),
            async (resolve, reject, responsePacket) => {
                if (responsePacket && responsePacket.data) {
                    if (responsePacket.data.length == 2) {
                        resolve(true);
                    }
                    if (responsePacket.data.length == 4) {
                        resolve(false);
                    }
                    reject('Unexpected length');
                } else {
                    reject('Failed to read register');
                }
            });
    }

    /**
     * Execute command on device
     * @async
     * @param {Object} packet - Command packet from buildCommandPacket
     * @param {Function} packetResponseCbr - Response handler(resolve, reject, responsePacket)
     * @param {Function} [rawDataCbr] - Raw data handler
     * @param {number} [timeout=500] - Timeout in milliseconds
     * @param {Function} [checkTimeoutCbr] - Optional timeout check returning boolean
     * @returns {Promise<*>} Result from callback
     * @throws {Error} On timeout or command failure
     */
    async executeCommand(packet, packetResponseCbr, rawDataCbr, timeout = 500, checkTimeoutCbr = null) {
        /*
         Serialize command execution properly:
         - Do NOT create the command promise before acquiring the logical lock.
           Creating it early can start the async work and contend for the writable stream.
         - Instead, chain the creation to the existing lock so only one writer is active.
        */
        const run = () => this._executeCommandUnlocked(packet, packetResponseCbr, rawDataCbr, timeout, checkTimeoutCbr);
        this._commandLock = this._commandLock.then(run, run);
        return this._commandLock;
    }

    /**
     * Internal command execution (unlocked)
     * @async
     * @private
     */
    async _executeCommandUnlocked(packet, packetResponseCbr, rawDataCbr, timeout = 500, checkTimeoutCbr = null) {
        if (!this.port || !this.port.writable) {
            throw new Error("Port is not writable.");
        }

        if (this.devMode) {
            this.dumpPacket(this.parsePacket(packet.payload));
        }

        return new Promise(async (resolve, reject) => {
            /* Set timeout handler */
            let timeoutHandle = null;

            const scheduleTimeout = () => {
                timeoutHandle = setTimeout(() => {
                    if (checkTimeoutCbr) {
                        if (checkTimeoutCbr()) {
                            safeReject(new Error(`Timeout in command ${packet.command}`));
                        } else {
                            scheduleTimeout();
                        }
                    } else {
                        safeReject(new Error(`Timeout after ${timeout} ms waiting for response to command ${packet.command}`));
                    }
                }, timeout);
            };

            const safeResolve = (value) => { clearTimeout(timeoutHandle); return resolve(value); };
            const safeReject = (err) => { clearTimeout(timeoutHandle); return reject(err); };


            /* Register response handlers */
            this.responseHandlers.clear();

            /* decide which callbacks to register */
            if (rawDataCbr) {
                /* this command seems to have have normal response then raw data */
                this.responseHandlers.set(packet.command, async (response) => {
                    if (packetResponseCbr) {
                        return packetResponseCbr(safeResolve, safeReject, response);
                    }
                });
                this.responseHandlers.set(-1, async (response) => {
                    return rawDataCbr(safeResolve, safeReject, response);
                });
            } else {
                /* only normal response */
                this.responseHandlers.set(packet.command, async (response) => {
                    if (packetResponseCbr) {
                        return packetResponseCbr(safeResolve, safeReject, response);
                    }
                });
            }

            /* Send the packet with proper error handling */
            try {
                scheduleTimeout();
                if (typeof performance !== 'undefined' && performance.mark) {
                    performance.mark('esp32_flasher_send_start');
                }

                await this._writeFrame(this.slipLayer.encode(packet.payload));

                if (typeof performance !== 'undefined' && performance.mark && performance.measure) {
                    performance.mark('esp32_flasher_send_end');
                    try {
                        performance.measure('esp32_flasher_send', 'esp32_flasher_send_start', 'esp32_flasher_send_end');
                        performance.measure('esp32_flasher_latency', 'esp32_flasher_receive_end', 'esp32_flasher_send_start');
                        /* measured ~50-100us latency on USB-JTAG for register read flooding */
                    } catch (measureErr) {
                    }
                }
            } catch (error) {
                clearTimeout(timeoutHandle);
                reject(error);
            }
        });
    }

    /**
     * Disconnect from serial port
     * @async
     * @returns {Promise<void>}
     */
    async disconnect() {
        if (this._disconnecting) {
            return;
        }
        this._disconnecting = true;

        navigator.serial.removeEventListener('disconnect', this.disconnect);

        if (this.reader) {
            try {
                await this.reader.cancel();
            } catch (error) {
                this.logError('Error cancelling reader:', error);
            }
        }

        /* Release persistent writer before closing port */
        this._releaseWriter();

        if (this.port) {
            try {
                this.port.removeEventListener('close', this.disconnect);
                await this.port.close();
            } catch (error) {
                //this.logError('Error during disconnect:', error);
            }
            this.port = null;
        }

        this.synced = false;
        this.consoleBuffer = '';
        this._preSyncState = 'idle';
        this._disconnecting = false;

        this.disconnected && this.disconnected();
    }

    async setDtr(value) {
        try {
            this.dtrState = value;
            await this.port.setSignals({
                dataTerminalReady: value,
                requestToSend: this.rtsState,
            });
            return true;
        } catch (error) {
            console.error(`Could not set DTR: ${error}.`);
            return false;
        }
    }

    async setRts(value) {
        try {
            this.rtsState = value;
            await this.port.setSignals({
                dataTerminalReady: this.dtrState,
                requestToSend: value,
            });
            return true;
        } catch (error) {
            console.error(`Could not set RTS: ${error}.`);
            return false;
        }
    }

    async setDtrRts(dtr, rts) {
        if (!this.port) {
            this.logError("Port is not open. Cannot set signals.");
            return false;
        }

        this.dtrState = dtr;
        this.rtsState = rts;

        try {
            await this.port.setSignals({
                dataTerminalReady: dtr,
                requestToSend: rts,
            });
            return true;
        } catch (error) {
            this.logError(`Could not set signals: ${error}.`);
            return false;
        }
    }

    async setSignals(signals) {
        if (!this.port) {
            this.logError("Port is not open. Cannot set signals.");
            return false;
        }

        if (signals.dataTerminalReady !== undefined) {
            this.dtrState = signals.dataTerminalReady;
        }
        if (signals.requestToSend !== undefined) {
            this.rtsState = signals.requestToSend;
        }

        try {
            await this.setDtr(this.dtrState);
            await this.setRts(this.rtsState);
            return true;
        } catch (error) {
            this.logError(`Could not set signals: ${error}.`);
            return false;
        }
    }

    /**
     * Attempts to put the ESP device into bootloader mode using RTS/DTR signals.
     * Relies on the common DTR=EN, RTS=GPIO0 circuit. May not work on all boards.
     * @returns {Promise<boolean>} True if the sequence was sent, false if an error occurred (e.g., signals not supported).
     */
    async hardReset(bootloader = true) {
        if (!this.port) {
            this.logError("Port is not open. Cannot set signals.");
            return false;
        }

        this.synced = false;
        this.consoleBuffer = '';
        this._preSyncState = 'idle';

        this.logDebug("Automatic bootloader reset sequence...");

        try {

            if (this.isEspressifUsbJtag) {
                /* Native USB/JTAG interface - use the method described in ESP32-S3 Table 33.4-3. Reset SoC into Download Mode.
                   This procedure assumes the Windows CDC driver toggles DRT only when RTS is set explicitly. */

                /* set to known state first, but causes an extra reset usually */
                await this.setDtr(false);
                await this.setRts(false);

                if (bootloader) {
                    await this.setDtr(true);
                    await this.setRts(false);
                    await this.setRts(true);
                    await this.setDtr(false);
                }

                await this.setRts(false);
                await this.setRts(true);
            } else {
                /* high/low vs. asserted/deasserted logic is a bit pain here:
                   EN pin (RTS) - active low - to reset, pull low (EN high means RTS=false)
                   IO0 pin (DTR) - active low - to enter bootloader, pull low (IO0 high means DTR=false)
                */
                const setPins = async ({ io0PinHigh, enPinHigh }) => {
                    const io0Level = io0PinHigh ? false : true;
                    const enLevel = enPinHigh ? false : true;
                    await this.setSignals({ requestToSend: enLevel, dataTerminalReady: io0Level });
                };

                await setPins({ io0PinHigh: true, enPinHigh: true });
                await setPins({ io0PinHigh: false, enPinHigh: false });
                await setPins({ io0PinHigh: true, enPinHigh: false });
                await new Promise(r => setTimeout(r, 50));
                await setPins({ io0PinHigh: bootloader ? false : true, enPinHigh: true });
                await new Promise(r => setTimeout(r, 100));
                await setPins({ io0PinHigh: true, enPinHigh: true });
            }

            return true;
        } catch (error) {
            this.logError(`Could not set signals for automatic reset: ${error}. Please ensure device is in bootloader mode manually.`);
            return false;
        }
    }


    /**
     * Convert base64-encoded string to binary data
     * @param {string} base64 - Base64-encoded data string
     * @returns {Uint8Array} Decoded binary data
     * @description Decodes base64 string using native atob and converts to Uint8Array
     */
    base64ToByteArray(base64) {
        const binaryString = atob(base64);
        const byteArray = new Uint8Array(binaryString.length);
        for (let index = 0; index < binaryString.length; index++) {
            byteArray[index] = binaryString.charCodeAt(index);
        }
        return byteArray;
    }

    /**
     * Download binary payload to device RAM
     * @async
     * @param {number} address - Target RAM address
     * @param {string} payload - Base64-encoded binary data
     * @returns {Promise<void>}
     * @throws {Error} If download fails
     * @description Used for downloading stub loader and other code to RAM
     */
    async downloadMem(address, payload) {
        var binary = this.base64ToByteArray(payload);

        await this.executeCommand(this.buildCommandPacketU32(MEM_BEGIN, binary.length, 1, binary.length, address),
            async (resolve, reject, responsePacket) => {
                resolve();
            });
        await this.executeCommand(this.buildCommandPacketU32(MEM_DATA, binary.length, 0, 0, 0, binary),
            async (resolve, reject, responsePacket) => {
                resolve();
            });
    }

    /**
     * Synchronize with bootloader and detect chip type
     * @async
     * @returns {Promise<void>}
     * @throws {Error} If synchronization fails after all retries
     * @description Performs SYNC command with retry logic, then reads chip magic value
     *              to detect connected chip type (ESP32, ESP32-S3, etc.)
     */
    async sync() {
        const maxRetries = 4;
        const retryDelayMs = 100; /* Delay between retries (Android stacks can be slower) */
        const syncTimeoutMs = 300; /* Timeout for each individual sync attempt */
        let synchronized = false;

        this.logDebug(`Attempting to synchronize (${maxRetries} attempts)...`);

        const syncData = new Uint8Array([0x07, 0x07, 0x12, 0x20, ...Array(32).fill(0x55)]);
        const syncPacket = this.buildCommandPacket(SYNC, syncData);

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            this.logDebug(`Sync attempt ${attempt}...`);
            try {
                await this.executeCommand(
                    syncPacket,
                    async (resolve, reject, responsePacket) => {
                        // The ROM bootloader responds to SYNC with 0x08 0x00 status - check value maybe?
                        // For now, just receiving *any* response to SYNC is considered success here.
                        // If the command times out, the catch block below handles it.
                        resolve(); // Signal success for this attempt
                    },
                    null, // No default callback needed here
                    syncTimeoutMs // Use a specific timeout for sync
                );

                // If executeCommand resolved without throwing/rejecting:
                this.logDebug(`Synchronized successfully on attempt ${attempt}.`);
                synchronized = true;
                break; // Exit the retry loop on success

            } catch (error) {
                this.logDebug(`Sync attempt ${attempt} failed: ${error.message}`);
                if (attempt === maxRetries) {
                    this.logError(`Failed to synchronize after ${maxRetries} attempts.`);
                    // Throw an error to indicate overall failure of the sync process
                    throw new Error(`Failed to synchronize with device after ${maxRetries} attempts.`);
                }
                // Wait before the next retry
                await new Promise(resolve => setTimeout(resolve, retryDelayMs));
            }
        }

        // This part only runs if synchronized was set to true
        if (!synchronized) {
            // This should technically not be reached if the error is thrown above,
            // but adding as a safeguard.
            throw new Error("Synchronization failed (unexpected state).");
        }

        this.synced = true;

        // Read security information
        try {
            this.logDebug("Reading security information...");
            this.securityInfo = await this.getSecurityInfo();
            this.current_chip = CHIP_ID_MAP[this.securityInfo.chip_id_hex >>> 0] || "unknown";

            this.logDebug(`Security Info: Flags=${this.securityInfo.flags_hex}, Flash Crypt=${this.securityInfo.flash_crypt_cnt}, Chip ID=${this.securityInfo.chip_id_hex} (${this.current_chip}), ECO=${this.securityInfo.eco_version_hex}`);

            /* Log enabled security features */
            const enabledFlags = Object.entries(this.securityInfo.flags_decoded)
                .filter(([key, value]) => value)
                .map(([key, _]) => key);
            if (enabledFlags.length > 0) {
                this.logDebug(`  Enabled security features: ${enabledFlags.join(', ')}`);
            } else {
                this.logDebug(`  No security features enabled`);
            }

            if (this.securityInfo.flags_decoded.SECURE_BOOT_EN) {
                if (!this.securityInfo.flags_decoded.SECURE_DOWNLOAD_ENABLE) {
                    this.deviceStateCallback && this.deviceStateCallback('secure_boot');
                } else {
                    this.deviceStateCallback && this.deviceStateCallback('secure_download');
                }
            }

            /* if this command succeeded, we already have the chip type, so we can just return. only plain ESP32 doesn't have the security info command */
            return;
        } catch (error) {
            this.logDebug(`Failed to read security info: ${error.message}, maybe plain ESP32? Continuing to old chip detection...`);
        }

        // --- Chip Detection (Runs only after successful sync) ---
        this.logDebug("Reading chip magic value...");
        let currentValue;
        try {
            // Use a slightly longer timeout for register reads if needed
            currentValue = await this.readReg(this.chip_magic_addr);
        } catch (readError) {
            this.logError(`Failed to read magic value after sync: ${readError}`);
            throw new Error(`Successfully synced, but failed to read chip magic value: ${readError.message}`);
        }

        /* Function to check if the value matches any of the magic values */
        const isMagicValue = (stub, value) => {
            if (Array.isArray(stub.magic_value)) {
                return stub.magic_value.includes(value);
            } else {
                return stub.magic_value === value;
            }
        };

        let chipDetected = false;
        /* Iterate through each stub in the object */
        for (const desc in this.chip_descriptions) {
            if (this.chip_descriptions.hasOwnProperty(desc)) {
                const checkStub = this.chip_descriptions[desc];
                if (isMagicValue(checkStub, currentValue)) {
                    this.logDebug(`Detected Chip: ${desc} (Magic: 0x${currentValue.toString(16)})`);
                    this.current_chip = desc;
                    chipDetected = true;
                    break; // Found the chip
                }
            }
        }

        if (!chipDetected) {
            this.logError(`Synced, but chip magic value 0x${currentValue.toString(16)} is unknown.`);
            this.current_chip = "unknown"; // Mark as unknown
        }
    }

    /**
     * Read device MAC address from eFuses
     * @async
     * @returns {Promise<string>} MAC address as colon-separated hex string (e.g., "aa:bb:cc:dd:ee:ff")
     * @throws {Error} If register read fails
     * @description Reads MAC address from chip-specific eFuse registers
     */
    async readMac() {
        /* Read the MAC address registers */
        var chip = this.chip_descriptions[this.current_chip];
        if (!chip.mac_efuse_reg) {
            throw new Error(`MAC eFuse register not defined for chip ${this.current_chip}`);
        }
        const register1 = await this.readReg(chip.mac_efuse_reg);
        const register2 = await this.readReg(chip.mac_efuse_reg + 4);

        if (!register1 || !register2) {
            return;
        }

        const lower = (register1 >>> 0);
        const higher = (register2 >>> 0) & 0xFFFF;

        // Construct MAC address from register values
        const macBytes = new Uint8Array(6);
        macBytes[0] = (higher >> 8) & 0xFF;
        macBytes[1] = higher & 0xFF;
        macBytes[2] = (lower >> 24) & 0xFF;
        macBytes[3] = (lower >> 16) & 0xFF;
        macBytes[4] = (lower >> 8) & 0xFF;
        macBytes[5] = lower & 0xFF;

        function toHex(byte) {
            const hexString = byte.toString(16);
            return hexString.length === 1 ? '0' + hexString : hexString;
        }
        const mac = Array.from(macBytes)
            .map(byte => toHex(byte))
            .join(':');

        return mac;
    }

    /**
     * Read chip security information
     * @async
     * @returns {Promise<Object>} Security info object with flags, flash_crypt_cnt, key_purposes, chip_id, eco_version
     * @throws {Error} If read fails
     * @description Reads chip security configuration including encryption status and key purposes
     */
    async getSecurityInfo() {
        return this.executeCommand(
            this.buildCommandPacketU32(GET_SECURITY_INFO, 0),
            async (resolve, reject, responsePacket) => {
                if (responsePacket && responsePacket.data && responsePacket.data.length >= 20) {
                    const data = responsePacket.data;

                    /* Parse 32-bit flags (little-endian) */
                    const flags = (data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24)) >>> 0;

                    /* Decode security flags */
                    const decodedFlags = {
                        SECURE_BOOT_EN: !!(flags & (1 << 0)),
                        SECURE_BOOT_AGGRESSIVE_REVOKE: !!(flags & (1 << 1)),
                        SECURE_DOWNLOAD_ENABLE: !!(flags & (1 << 2)),
                        SECURE_BOOT_KEY_REVOKE0: !!(flags & (1 << 3)),
                        SECURE_BOOT_KEY_REVOKE1: !!(flags & (1 << 4)),
                        SECURE_BOOT_KEY_REVOKE2: !!(flags & (1 << 5)),
                        SOFT_DIS_JTAG: !!(flags & (1 << 6)),
                        HARD_DIS_JTAG: !!(flags & (1 << 7)),
                        DIS_USB: !!(flags & (1 << 8)),
                        DIS_DOWNLOAD_DCACHE: !!(flags & (1 << 9)),
                        DIS_DOWNLOAD_ICACHE: !!(flags & (1 << 10))
                    };

                    /* Parse 1 byte flash_crypt_cnt */
                    const flash_crypt_cnt = data[4];

                    /* Parse 7 bytes key_purposes */
                    const key_purposes = Array.from(data.slice(5, 12));

                    /* Parse 32-bit chip_id (little-endian) */
                    const chip_id = (data[12] | (data[13] << 8) | (data[14] << 16) | (data[15] << 24)) >>> 0;

                    /* Parse 32-bit eco_version (little-endian) */
                    const eco_version = (data[16] | (data[17] << 8) | (data[18] << 16) | (data[19] << 24)) >>> 0;

                    const securityInfo = {
                        flags: flags,
                        flags_hex: '0x' + flags.toString(16).toUpperCase().padStart(8, '0'),
                        flags_decoded: decodedFlags,
                        flash_crypt_cnt: flash_crypt_cnt,
                        key_purposes: key_purposes,
                        chip_id: chip_id,
                        chip_id_hex: '0x' + chip_id.toString(16).toUpperCase().padStart(8, '0'),
                        eco_version: eco_version,
                        eco_version_hex: '0x' + eco_version.toString(16).toUpperCase().padStart(8, '0')
                    };

                    resolve(securityInfo);
                } else {
                    reject('Invalid security info response');
                }
            },
            null,
            100
        );
    }

    /**
     * Test serial communication reliability
     * @async
     * @param {Function} [cbr] - Progress callback(percentComplete)
     * @returns {Promise<boolean>} True if test passed, false if failed
     * @description Performs 1-second stress test reading the same register repeatedly,
     *              verifying all reads return identical values
     */
    async testReliability(cbr) {

        var chip = this.chip_descriptions[this.current_chip];
        var reference = 0;

        try {
            reference = await this.executeCommand(this.buildCommandPacketU32(READ_REG, chip.mac_efuse_reg),
                async (resolve, reject, responsePacket) => {
                    if (responsePacket) {
                        resolve(responsePacket.value);
                    } else {
                        this.logError(`Test read failed`);
                        reject(`Test read failed`);
                    }
                });
        } catch (error) {
            this.logError(`Test read failed due to an error`, `${error.message}`);
            return false;
        }

        var duration = 1000;
        const endTime = Date.now() + duration;

        let totalReads = 0;
        let totalTime = 0;

        while (Date.now() < endTime) {
            try {
                const startTime = Date.now();

                var testread = await this.executeCommand(this.buildCommandPacketU32(READ_REG, chip.mac_efuse_reg),
                    async (resolve, reject, responsePacket) => {
                        if (responsePacket) {
                            resolve(responsePacket.value);
                        } else {
                            reject(`Test read failed`);
                        }
                    });

                const endTimeRead = Date.now();
                const readDuration = endTimeRead - startTime;

                totalTime += readDuration;
                totalReads++;

                /* Update the progress bar */
                const elapsed = Date.now() - (endTime - duration); // duration is the total time period (change to 30000 for 30 seconds)
                const progressPercentage = Math.min(100, (elapsed / duration) * 100); // Cap at 100%

                cbr && cbr(progressPercentage);

                /* Check if the read value differs from the reference */
                if (testread !== reference) {
                    this.logError(`Test read failed! Expected: 0x${reference.toString(16).padStart(8, '0')}, but got: 0x${testread.toString(16).padStart(8, '0')}`);
                    break;
                }
            } catch (error) {
                this.logError(`Test read failed due to an error`, `${error.message}`);
                return false;
            }
        }

        if (totalReads > 0) {
            const averageTime = totalTime / totalReads;
            this.logMessage(`Average read time: ${averageTime.toFixed(2)} ms over ${totalReads} reads.`);
        }

        return true;
    }

    /**
     * Download and execute stub loader on device
     * @async
     * @returns {Promise<boolean>} True if stub loaded successfully, false otherwise
     * @throws {Error} If stub loading or initialization fails
     * @description Downloads stub firmware to RAM and executes it.
     *              Stub provides additional capabilities like flash read/write and MD5.
     */
    async downloadStub() {
        var stub = this.chip_descriptions[this.current_chip].stub

        if (stub.data_start != undefined && stub.data != undefined) {
            await this.downloadMem(stub.data_start, stub.data);
        }
        await this.downloadMem(stub.text_start, stub.text);

        try {
            await this.executeCommand(this.buildCommandPacketU32(MEM_END, 0, stub.entry),
                async (resolve, reject, responsePacket) => {
                    this.logDebug("Final MEM_END ACK");
                },
                async (resolve, reject, rawData) => {
                    const decoder = new TextDecoder('utf-8');
                    const responseData = decoder.decode(rawData);

                    if (responseData == "OHAI") {
                        this.logDebug(`Stub loader executed successfully (received ${responseData})`);
                        this.stubLoaded = true;
                        resolve();
                    } else {
                        this.logError(`Unexpected stub response: ${responseData}`);
                        reject(`Unexpected response from stub: ${responseData}`);
                    }
                },
                3000 // Longer timeout for stub execution
            );
        } catch (error) {
            this.logDebug(error);
            this.logError("Failed to execute stub", "Is the device locked?");
            return false;
        }

        try {
            await this.executeCommand(this.buildCommandPacketU32(SPI_SET_PARAMS, 0, 0x800000, 64 * 1024, 4 * 1024, 256, 0xFFFF), async (resolve, reject, responsePacket) => {
                this.logDebug("SPI_SET_PARAMS configured");
                resolve();
            });
        } catch (error) {
            this.logError("Failed to configure SPI parameters", error.message);
            return false;
        }

        return true;
    }

    /**
     * Write data to flash memory
     * @async
     * @param {number} address - Target flash address
     * @param {Uint8Array} data - Binary data to write
     * @param {Function} [progressCallback] - Callback(bytesWritten, totalBytes)
     * @returns {Promise<void>}
     * @throws {Error} If write fails
     */
    async writeFlashPlain(address, data, progressCallback) {
        const MAX_PACKET_SIZE = 0x1000;
        const packets = Math.ceil(data.length / MAX_PACKET_SIZE);

        /* Send FLASH_BEGIN command with the total data size
           according to https://docs.espressif.com/projects/esptool/en/latest/esp32s3/advanced-topics/serial-protocol.html
           the ROM bootloader is also able to flash. unfortunately there are some issues with it.
           it doesn't respond anymore. use with stub only!
        */
        await this.executeCommand(
            this.buildCommandPacketU32(FLASH_BEGIN, data.length, packets,
                Math.min(MAX_PACKET_SIZE, data.length),
                address
            ),
            async (resolve) => {
                resolve();
            }
        );

        /* Split data into chunks and send FLASH_DATA commands */
        var seq = 0;
        for (let offset = 0; offset < data.length; offset += MAX_PACKET_SIZE) {
            const chunk = data.slice(offset, offset + MAX_PACKET_SIZE);

            /* Four 32-bit words: data size, sequence number, 0, 0, then data. Uses Checksum. */
            await this.executeCommand(
                this.buildCommandPacketU32(FLASH_DATA, chunk.length, seq++, 0, 0, chunk),
                async (resolve) => {
                    resolve();
                },
                null,
                5000
            );

            progressCallback && progressCallback(offset + chunk.length, data.length);
        }
    }

    /**
     * Read data from flash memory
     * @async
     * @param {number} address - Source flash address
     * @param {number} [totalLength=0x1000] - Number of bytes to read
     * @param {Function} [progressCallback] - Callback(bytesRead, totalBytes)
     * @returns {Promise<Uint8Array>} Read data (MD5 verified)
     * @throws {Error} If read fails or MD5 mismatch
     * 

       ESP32-C3
        [01:04:10] [DEBUG] ReadFlash timing: 262144 bytes in 22772ms
        [01:04:10] [DEBUG]   Data rate: 0.01 MB/s (11512 B/s)
        [01:04:10] [DEBUG]   Packet latency: min=348ms, max=358ms, avg=355.8ms
        [01:04:10] [DEBUG]   Packets received: 64

       ESP32-C6
        [01:05:00] [DEBUG] ReadFlash timing: 262144 bytes in 841ms
        [01:05:00] [DEBUG]   Data rate: 0.30 MB/s (311705 B/s)
        [01:05:00] [DEBUG]   Packet latency: min=13ms, max=14ms, avg=13.1ms
        [01:05:00] [DEBUG]   Packets received: 64

       ESP32-S3
        [01:06:29] [DEBUG] ReadFlash timing: 262144 bytes in 22762ms
        [01:06:29] [DEBUG]   Data rate: 0.01 MB/s (11517 B/s)
        [01:06:29] [DEBUG]   Packet latency: min=350ms, max=356ms, avg=355.6ms
        [01:06:29] [DEBUG]   Packets received: 64

     */
    async readFlashPlain(address, totalLength = 0x1000, cbr) {
        let blockSize = Math.min(totalLength, 0x1000);
        let maxInFlight = Math.min(totalLength, blockSize * 2);
        const packetCount = totalLength / blockSize;

        let packet = 0;
        let lastAckedLength = 0;
        var data = new Uint8Array(0);
        var lastDataTime = Date.now();

        /* Timing measurements */
        const readStartTime = Date.now();
        let packetLatencies = [];
        let lastPacketTime = readStartTime;
        let totalBytesReceived = 0;

        if (this.devMode) {
            this.logDebug(`[ReadFlashPlain] Starting ReadFlash:`, { address: `0x${address.toString(16)}`, length: totalLength, sectorSize: blockSize, packets: packetCount, maxInFlight: maxInFlight });
        }

        return this.executeCommand(
            this.buildCommandPacketU32(READ_FLASH, address, totalLength, blockSize, maxInFlight),
            async () => {
                packet = 0;
            },
            async (resolve, reject, rawData) => {
                const currentTime = Date.now();
                lastDataTime = currentTime;

                if (data.length == totalLength) {
                    if (rawData.length == 16) {
                        /* Calculate MD5 of received data */
                        const calculatedMD5 = this.calculateMD5(data);

                        /* Convert received MD5 bytes to hex string */
                        const receivedMD5 = Array.from(rawData)
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');

                        /* Compare MD5 hashes */
                        if (calculatedMD5.toLowerCase() === receivedMD5.toLowerCase()) {
                            /* Calculate and log timing statistics */
                            const totalTime = currentTime - readStartTime;
                            const dataRate = totalBytesReceived / (totalTime / 1000);
                            const avgLatency = packetLatencies.length > 0
                                ? packetLatencies.reduce((a, b) => a + b, 0) / packetLatencies.length
                                : 0;
                            const minLatency = packetLatencies.length > 0
                                ? Math.min(...packetLatencies)
                                : 0;
                            const maxLatency = packetLatencies.length > 0
                                ? Math.max(...packetLatencies)
                                : 0;

                            if (this.devMode) {
                                this.logDebug(`ReadFlash timing: ${totalBytesReceived} bytes in ${totalTime}ms`);
                                this.logDebug(`  Data rate: ${(dataRate / 1024 / 1024).toFixed(2)} MB/s (${dataRate.toFixed(0)} B/s)`);
                                this.logDebug(`  Packet latency: min=${minLatency}ms, max=${maxLatency}ms, avg=${avgLatency.toFixed(1)}ms`);
                                this.logDebug(`  Packets received: ${packetLatencies.length}`);
                            }

                            resolve(data);
                        } else {
                            const error = `MD5 mismatch! Expected: ${receivedMD5}, Got: ${calculatedMD5}`;
                            this.logError(error);
                            reject(new Error(error));
                        }
                    } else {
                        const error = `Unknown response length for MD5! Expected: 16, Got: ${rawData.length}`;
                        this.logError(error);
                        reject(new Error(error));
                    }
                } else {
                    /* Track packet latency */
                    const packetLatency = currentTime - lastPacketTime;
                    packetLatencies.push(packetLatency);
                    lastPacketTime = currentTime;
                    totalBytesReceived += rawData.length;

                    /* Append rawData to accumulated data */
                    const newData = new Uint8Array(data.length + rawData.length);
                    newData.set(data);
                    newData.set(rawData, data.length);
                    data = newData;
                    packet++;

                    /* Prepare response */
                    if (data.length >= (lastAckedLength + maxInFlight) || (data.length >= totalLength)) {

                        /* Encode and write response */
                        var resp = new Uint8Array(4);
                        resp[0] = (data.length >> 0) & 0xFF;
                        resp[1] = (data.length >> 8) & 0xFF;
                        resp[2] = (data.length >> 16) & 0xFF;
                        resp[3] = (data.length >> 24) & 0xFF;

                        await this._writeFrame(this.slipLayer.encode(resp));

                        /* move last acked length further */
                        lastAckedLength = Math.min(lastAckedLength + maxInFlight, totalLength);
                    }

                    /* Call progress callback */
                    if (cbr) {
                        cbr(data.length, totalLength);
                    }
                }
            },
            500,
            /* Timeout condition: if the last raw data callback was more than a second ago */
            () => {
                const timeSinceLastData = Date.now() - lastDataTime;
                const hasTimedOut = timeSinceLastData > 1000;
                if (hasTimedOut) {
                    this.logError(`[ReadFlashPlain] TIMEOUT CHECK: timeSinceLastData=${timeSinceLastData}ms, triggering timeout`);
                }
                return hasTimedOut;
            }
        );
    }

    /**
     * Calculate MD5 checksum of flash region
     * @async
     * @param {number} address - Start address
     * @param {number} length - Number of bytes
     * @returns {Promise<string>} MD5 hash (hex)
     * @throws {Error} If checksum fails
     */
    async checksumFlash(address, length) {
        return this.executeCommand(
            this.buildCommandPacketU32(SPI_FLASH_MD5, address, length, 0, 0),
            async (resolve, reject, responsePacket) => {
                /* MD5 response is in the data field */
                if (responsePacket && responsePacket.data) {
                    /* Convert data bytes to hex string */
                    const md5 = Array.from(responsePacket.data.slice(0, 16))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');
                    resolve(md5);
                } else {
                    reject('No MD5 data received');
                }
            },
            async (resolve, reject, rawData) => {
                /* Handle raw data response if it comes this way */
                const decoder = new TextDecoder('utf-8');
                const md5String = decoder.decode(rawData);
                resolve(md5String.trim());
            },
            1000 + length / 500 // Timeout based on length
        );
    }

    /**
     * Calculate local MD5 hash
     * @param {Uint8Array|string} data - Data to hash
     * @returns {string} MD5 hash (hex)
     */
    calculateMD5(data) {
        /* Create MD5 hash using the Md5 class */
        const md5 = new this.Md5();
        md5.update(data);
        return md5.hex();
    }

    /**
     * Read flash with comprehensive MD5 verification
     * @async
     * @param {number} address - Source address
     * @param {number} size - Number of bytes
     * @param {Function} [progressCallback] - Callback(read, total, stage)
     * @returns {Promise<Uint8Array>} Verified data
     * @throws {Error} If read/verification fails
     */
    async readFlash(address, size, progressCallback) {
        var blockSize = 64 * 0x1000;

        if (this.port instanceof WebUSBSerial) {
            blockSize = (this.port.maxTransferSize - 2) / 2; /* remove 2 bytes for SLIP overhead, divide by 2 because 0xC0 gets potentially escaped */
        }

        try {
            /* Step 1: Read data in blocks */
            this.logDebug(`ReadFlashSafe: Reading ${size} bytes in ${blockSize}-byte blocks...`);
            const allData = new Uint8Array(size);
            let offset = 0;

            while (offset < size) {
                const readSize = Math.min(blockSize, size - offset);
                let cbr = (read, readBlockSize) => {
                    progressCallback && progressCallback(offset + read, size, 'reading');
                }
                const blockData = await this.readFlashPlain(address + offset, readSize, cbr);

                /* Copy block to buffer */
                allData.set(blockData.slice(0, readSize), offset);
                offset += readSize;

                /* Call progress callback */
                progressCallback && progressCallback(offset, size, 'reading');

                if (this.devMode) {
                    this.logDebug(`ReadFlashSafe: Read ${offset}/${size} bytes (${Math.round((offset / size) * 100)}%)`);
                }
            }

            /* Step 2: Calculate MD5 of read data */
            progressCallback && progressCallback(size, size, 'calc MD5 of input');
            this.logDebug(`ReadFlashSafe: Calculating MD5 of read data...`);
            const actualMD5 = await this.calculateMD5(allData);
            this.logDebug(`Actual MD5: ${actualMD5}`);

            /* Step 3: Get expected MD5 from flash */
            progressCallback && progressCallback(size, size, 'calc MD5 onchip');

            this.logDebug(`ReadFlashSafe: Calculating expected MD5 for ${size} bytes at 0x${address.toString(16).padStart(8, '0')}...`);
            const expectedMD5 = await this.checksumFlash(address, size);
            this.logDebug(`Expected MD5: ${expectedMD5}`);

            /* Step 4: Compare MD5 hashes */
            if (expectedMD5.toLowerCase() !== actualMD5.toLowerCase()) {
                this.logError(`ReadFlashSafe FAILED: MD5 mismatch!`);
                this.logError(`  Expected: ${expectedMD5}`);
                this.logError(`  Actual:   ${actualMD5}`);
                throw new Error(`MD5 verification failed: expected ${expectedMD5}, got ${actualMD5}`);
            }

            this.logDebug(`ReadFlashSafe: MD5 verification passed âœ“`);
            return allData;

        } catch (error) {
            this.logError(`ReadFlashSafe failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * Write flash with MD5 verification
     * @async
     * @param {number} address - Target address
     * @param {Uint8Array} data - Data to write
     * @param {Function} [progressCbr] - Callback(written, total, stage)
     * @returns {Promise<Object>} {success: boolean, md5: string}
     * @throws {Error} If write/verification fails
     */
    async writeFlash(address, data, progressCbr) {
        try {
            /* Step 1: Write data to flash */
            this.logDebug(`WriteFlashSafe: Writing ${data.length} bytes to 0x${address.toString(16).padStart(8, '0')}...`);
            await this.writeFlashPlain(address, data, (offset, total) => {
                progressCbr && progressCbr(offset, total, 'Writing');
            });
            this.logDebug(`WriteFlashSafe: Write complete`);

            /* Step 2: Calculate MD5 of input data */
            progressCbr && progressCbr(data.length, data.length, 'Calculating MD5 of input');
            this.logDebug(`WriteFlashSafe: Calculating MD5 of ${data.length} bytes to write...`);
            const expectedMD5 = this.calculateMD5(data);
            this.logDebug(`Input data MD5: ${expectedMD5}`);

            /* Step 3: Get MD5 from device */
            progressCbr && progressCbr(data.length, data.length, 'Calculating MD5 on device');
            this.logDebug(`WriteFlashSafe: Calculating MD5 on device for verification...`);
            const deviceMD5 = await this.checksumFlash(address, data.length);
            this.logDebug(`Device MD5: ${deviceMD5}`);

            /* Step 4: Compare MD5 hashes */
            if (expectedMD5.toLowerCase() !== deviceMD5.toLowerCase()) {
                this.logError(`WriteFlashSafe FAILED: MD5 mismatch!`);
                this.logError(`  Expected: ${expectedMD5}`);
                this.logError(`  Device:   ${deviceMD5}`);
                throw new Error(`MD5 verification failed after write: expected ${expectedMD5}, got ${deviceMD5}`);
            }

            this.logDebug(`WriteFlashSafe: MD5 verification passed âœ“`);

            progressCbr && progressCbr(data.length, data.length, expectedMD5, 'Verified');

            return { success: true, md5: expectedMD5 };

        } catch (error) {
            this.logError(`WriteFlashSafe failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * Check if flash memory is erased
     * @async
     * @param {Function} [cbr] - Progress callback
     * @returns {Promise<void>}
     */
    async blankCheck(startAddress = 0x000000, endAddress = 0x800000, cbr = null) {
        const blockSize = 0x1000;

        let totalReads = 0;
        let totalTime = 0;
        let erasedBytesTotal = 0;
        let currentAddress = startAddress;

        while (currentAddress < endAddress) {

            try {
                const startTime = Date.now();
                var rawData = await this.readFlashPlain(currentAddress, blockSize);
                const endTimeRead = Date.now();
                const readDuration = endTimeRead - startTime;

                var erasedBytes = 0;
                for (var pos = 0; pos < rawData.length; pos++) {
                    if (rawData[pos] == 0xFF) {
                        erasedBytes++;
                    }
                }

                currentAddress += rawData.length;
                erasedBytesTotal += erasedBytes;
                totalTime += readDuration;
                totalReads++;

                cbr && cbr(currentAddress, startAddress, endAddress, blockSize, erasedBytes, erasedBytesTotal);
            } catch (error) {
                this.logError(`Read failed due to an error`, `${error.message}`);
                this.disconnect();
                break;
            }
        }

        if (totalReads > 0) {
            const averageTime = totalTime / totalReads;
            this.logDebug(`Average read time: ${averageTime.toFixed(2)} ms over ${totalReads} reads.`);
        }
    }

    /**
     * Write/Read stress test
     * @async
     * @param {number} address - Test address
     * @param {number} size - Test data size
     * @param {Function} [cbr] - Progress callback
     * @returns {Promise<Object>} Test result
     * @throws {Error} On critical failure
     */
    async writeReadTest(address, size, cbr) {
        try {
            /* Step 1: Read original data */
            this.logDebug(`Test: Reading original ${size} bytes from 0x${address.toString(16).padStart(8, '0')}...`);
            cbr && cbr('reading_original', 0, 3);
            const originalData = await this.readFlashPlain(address, size);
            this.logDebug(`Original data read complete`);

            /* Hexdump original data (first 64 bytes) */
            const dumpSize = Math.min(64, size);
            this.logDebug(`Original data hexdump (first ${dumpSize} bytes):`);
            for (let i = 0; i < dumpSize; i += 16) {
                const chunk = originalData.slice(i, i + 16);
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                const ascii = Array.from(chunk).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
                this.logDebug(`  ${(address + i).toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`);
            }

            /* Step 2: Generate random data */
            this.logDebug(`Test: Generating ${size} bytes of random data...`);
            cbr && cbr('generating_random', 1, 3);
            const randomData = new Uint8Array(size);
            for (let i = 0; i < size; i++) {
                randomData[i] = Math.floor(Math.random() * 256);
            }
            this.logDebug(`Random data generated`);

            /* Hexdump random data (first 64 bytes) */
            this.logDebug(`Random data hexdump (first ${dumpSize} bytes):`);
            for (let i = 0; i < dumpSize; i += 16) {
                const chunk = randomData.slice(i, i + 16);
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                const ascii = Array.from(chunk).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
                this.logDebug(`  ${(address + i).toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`);
            }

            /* Step 3: Write random data to flash */
            this.logDebug(`Test: Writing ${size} bytes to flash at 0x${address.toString(16).padStart(8, '0')}...`);
            cbr && cbr('writing', 2, 3);
            await this.writeFlashPlain(address, randomData, (offset, total) => {
                const percent = Math.round((offset / total) * 100);
                cbr && cbr('writing', 2, 3, percent);
            });
            this.logDebug(`Write complete`);

            /* Step 4: Read back the data */
            this.logDebug(`Test: Reading back ${size} bytes from 0x${address.toString(16).padStart(8, '0')}...`);
            cbr && cbr('reading_back', 3, 3);
            const readbackData = await this.readFlashPlain(address, size);
            this.logDebug(`Readback complete`);

            /* Hexdump readback data (first 64 bytes) */
            this.logDebug(`Readback data hexdump (first ${dumpSize} bytes):`);
            for (let i = 0; i < dumpSize; i += 16) {
                const chunk = readbackData.slice(i, i + 16);
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                const ascii = Array.from(chunk).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
                this.logDebug(`  ${(address + i).toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`);
            }

            /* Step 5: Verify data matches */
            let errors = 0;
            let firstError = -1;
            for (let i = 0; i < size; i++) {
                if (randomData[i] !== readbackData[i]) {
                    if (firstError === -1) {
                        firstError = i;
                    }
                    errors++;
                }
            }

            const result = {
                success: errors === 0,
                errors: errors,
                firstError: firstError,
                address: address,
                size: size,
                originalData: originalData,
                randomData: randomData,
                readbackData: readbackData
            };

            if (errors === 0) {
                this.logDebug(`âœ“ Test PASSED: All ${size} bytes match!`);
            } else {
                this.logError(`âœ— Test FAILED: ${errors} byte(s) mismatch!`);
                this.logError(`  First error at offset 0x${firstError.toString(16).padStart(4, '0')} (byte ${firstError})`);
                this.logError(`  Expected: 0x${randomData[firstError].toString(16).padStart(2, '0')}, Got: 0x${readbackData[firstError].toString(16).padStart(2, '0')}`);
            }

            cbr && cbr('complete', 3, 3, 100, result);
            return result;

        } catch (error) {
            this.logError(`Write/Read test failed: ${error.message}`);
            cbr && cbr('error', 0, 3, 0, { success: false, error: error.message });
            throw error;
        }
    }

    /**
     * Build command packet with 32-bit arguments
     * @param {number} command - Command code
     * @param {...(number|Uint8Array)} values - Arguments
     * @returns {Object} {command, payload: Uint8Array}
     */
    buildCommandPacketU32(command, ...values) {
        /* Calculate total length for data */
        let totalLength = 0;
        values.forEach(value => {
            if (typeof value === 'number') {
                totalLength += 4; // uint32 is 4 bytes
            } else if (value instanceof Uint8Array) {
                totalLength += value.length;
            }
        });

        /* Convert each uint32_t to little-endian bytes or append byte arrays */
        const data = new Uint8Array(totalLength);
        let offset = 0;
        values.forEach(value => {
            if (typeof value === 'number') {
                data[offset] = (value >> 0) & 0xFF;
                data[offset + 1] = (value >> 8) & 0xFF;
                data[offset + 2] = (value >> 16) & 0xFF;
                data[offset + 3] = (value >> 24) & 0xFF;
                offset += 4;
            } else if (value instanceof Uint8Array) {
                data.set(value, offset);
                offset += value.length;
            }
        });

        /* Call the original function with the constructed data */
        return this.buildCommandPacket(command, data);
    }

    /**
     * Build raw command packet
     * @param {number} command - Command code
     * @param {Uint8Array} data - Payload
     * @returns {Object} {command, payload: Uint8Array}
     */
    buildCommandPacket(command, data) {
        /* Construct command packet */
        const direction = 0x00;
        const size = data.length;
        let checksum = 0;

        if (size > 32) {
            checksum = 0xEF;
            for (let index = 16; index < size; index++) {
                checksum ^= data[index];
            }
        }

        const packet = new Uint8Array(8 + size);
        packet[0] = direction;
        packet[1] = command;
        packet[2] = size & 0xff;
        packet[3] = (size >> 8) & 0xff;
        packet[4] = checksum & 0xff;
        packet[5] = (checksum >> 8) & 0xff;
        packet[6] = (checksum >> 16) & 0xff;
        packet[7] = (checksum >> 24) & 0xff;
        packet.set(data, 8);

        var ret = {};

        ret.command = command;
        ret.payload = packet;

        return ret;
    }

    /**
     * Debug dump packet to console
     * @param {Object} pkt - Parsed packet
     */
    dumpPacket(pkt) {
        if (!this.devMode) {
            return;
        }

        /* Log command execution with parameters */
        const commandNames = {
            0x02: 'FLASH_BEGIN', 0x03: 'FLASH_DATA', 0x04: 'FLASH_END',
            0x05: 'MEM_BEGIN', 0x06: 'MEM_END', 0x07: 'MEM_DATA',
            0x08: 'SYNC', 0x09: 'WRITE_REG', 0x0a: 'READ_REG',
            0x0b: 'SPI_SET_PARAMS', 0x0d: 'SPI_ATTACH', 0x0f: 'CHANGE_BAUDRATE',
            0x10: 'FLASH_DEFL_BEGIN', 0x11: 'FLASH_DEFL_DATA', 0x12: 'FLASH_DEFL_END',
            0x13: 'SPI_FLASH_MD5', 0x14: 'GET_SECURITY_INFO',
            0xd0: 'ERASE_FLASH', 0xd1: 'ERASE_REGION', 0xd2: 'READ_FLASH', 0xd3: 'RUN_USER_CODE'
        };
        const cmdName = commandNames[packet.command] || `0x${packet.command.toString(16)}`;
        this.logDebug(`[CMD] ${cmdName} (0x${packet.command.toString(16).padStart(2, '0')})`, 'params:', pkt);

        if (pkt.dir == 0) {
            this.logDebug(`Command: `, pkt);
            this.logDebug(`Command raw: ${Array.from(pkt.raw).map(byte => byte.toString(16).padStart(2, '0')).join(' ')}`);
        }
        if (pkt.dir == 1) {
            this.logDebug(`Response: `, pkt);
            this.logDebug(`Response raw: ${Array.from(pkt.raw).map(byte => byte.toString(16).padStart(2, '0')).join(' ')}`);
        }
    }

    /**
     * Parse raw packet bytes
     * @param {Uint8Array} packet - Raw packet data
     * @returns {Object|null} Parsed packet or null if invalid
     */
    parsePacket(packet) {
        var pkt = {};

        pkt.dir = packet[0];
        pkt.command = packet[1];
        pkt.size = packet[2] | (packet[3] << 8);
        pkt.value = (packet[4] | (packet[5] << 8) | (packet[6] << 16) | (packet[7] << 24)) >>> 0;

        if (pkt.dir > 2 || packet.length != 8 + pkt.size) {
            return null;
        }
        pkt.data = packet.slice(8, 8 + pkt.size);
        pkt.raw = packet;

        return pkt;
    }

    /**
     * Process received packet
     * @async
     * @param {Uint8Array} packet - Raw packet bytes
     * @returns {Promise<void>}
     */
    async processPacket(packet) {
        var pkt = this.parsePacket(packet);

        if (pkt && pkt.dir === 0x01) {
            this.dumpPacket(pkt);
            /* Call response handler if registered */
            if (this.responseHandlers.has(pkt.command)) {
                var handler = this.responseHandlers.get(pkt.command);
                await handler(pkt);
            }
        } else {
            //this.logDebug(`Received raw SLIP: ${ Array.from(packet).map(byte => byte.toString(16).padStart(2, '0')).join(' ') }`);

            if (this.responseHandlers.has(-1)) {
                var handler = this.responseHandlers.get(-1);
                await handler(packet);
            }
        }
    }

    /* ==================== MD5 Hash Implementation ==================== */
    /**
     * MD5 Hash Implementation (from js-md5 library)
     * Standalone client-side hashing for data verification
     */
    Md5 = (function () {
        const ARRAY_BUFFER = typeof ArrayBuffer !== 'undefined';
        const HEX_CHARS = '0123456789abcdef'.split('');
        const EXTRA = [128, 32768, 8388608, -2147483648];
        const SHIFT = [0, 8, 16, 24];
        const FINALIZE_ERROR = 'finalize already called';

        let blocks = [], buffer8;
        if (ARRAY_BUFFER) {
            const buffer = new ArrayBuffer(68);
            buffer8 = new Uint8Array(buffer);
            blocks = new Uint32Array(buffer);
        }

        function formatMessage(message) {
            if (typeof message === 'string') {
                return [message, true];
            }
            if (message instanceof ArrayBuffer) {
                return [new Uint8Array(message), false];
            }
            if (message.constructor === Uint8Array || message.constructor === Array) {
                return [message, false];
            }
            return [message, false];
        }

        /**
         * Md5 class
         * @class Md5
         * @description This is internal class.
         * @see {@link md5.create}
         */
        function Md5(sharedMemory) {
            if (sharedMemory) {
                blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                    blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                    blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                    blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                this.blocks = blocks;
                this.buffer8 = buffer8;
            } else {
                if (ARRAY_BUFFER) {
                    var buffer = new ArrayBuffer(68);
                    this.buffer8 = new Uint8Array(buffer);
                    this.blocks = new Uint32Array(buffer);
                } else {
                    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                }
            }
            this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
            this.finalized = this.hashed = false;
            this.first = true;
        }

        /**
         * from https://www.npmjs.com/package/js-md5
         * @method update
         * @memberof Md5
         * @instance
         * @description Update hash
         * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
         * @returns {Md5} Md5 object.
         * @see {@link md5.update}
         */
        Md5.prototype.update = function (message) {
            if (this.finalized) {
                throw new Error(FINALIZE_ERROR);
            }

            var result = formatMessage(message);
            message = result[0];
            var isString = result[1];
            var code, index = 0, i, length = message.length, blocks = this.blocks;
            var buffer8 = this.buffer8;

            while (index < length) {
                if (this.hashed) {
                    this.hashed = false;
                    blocks[0] = blocks[16];
                    blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                }

                if (isString) {
                    if (ARRAY_BUFFER) {
                        for (i = this.start; index < length && i < 64; ++index) {
                            code = message.charCodeAt(index);
                            if (code < 0x80) {
                                buffer8[i++] = code;
                            } else if (code < 0x800) {
                                buffer8[i++] = 0xc0 | (code >>> 6);
                                buffer8[i++] = 0x80 | (code & 0x3f);
                            } else if (code < 0xd800 || code >= 0xe000) {
                                buffer8[i++] = 0xe0 | (code >>> 12);
                                buffer8[i++] = 0x80 | ((code >>> 6) & 0x3f);
                                buffer8[i++] = 0x80 | (code & 0x3f);
                            } else {
                                code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
                                buffer8[i++] = 0xf0 | (code >>> 18);
                                buffer8[i++] = 0x80 | ((code >>> 12) & 0x3f);
                                buffer8[i++] = 0x80 | ((code >>> 6) & 0x3f);
                                buffer8[i++] = 0x80 | (code & 0x3f);
                            }
                        }
                    } else {
                        for (i = this.start; index < length && i < 64; ++index) {
                            code = message.charCodeAt(index);
                            if (code < 0x80) {
                                blocks[i >>> 2] |= code << SHIFT[i++ & 3];
                            } else if (code < 0x800) {
                                blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                            } else if (code < 0xd800 || code >= 0xe000) {
                                blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                            } else {
                                code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
                                blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                            }
                        }
                    }
                } else {
                    if (ARRAY_BUFFER) {
                        for (i = this.start; index < length && i < 64; ++index) {
                            buffer8[i++] = message[index];
                        }
                    } else {
                        for (i = this.start; index < length && i < 64; ++index) {
                            blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];
                        }
                    }
                }
                this.lastByteIndex = i;
                this.bytes += i - this.start;
                if (i >= 64) {
                    this.start = i - 64;
                    this.hash();
                    this.hashed = true;
                } else {
                    this.start = i;
                }
            }
            if (this.bytes > 4294967295) {
                this.hBytes += this.bytes / 4294967296 << 0;
                this.bytes = this.bytes % 4294967296;
            }
            return this;
        };

        /**
         * Finalize hash computation
         * @method finalize
         * @memberof Md5
         * @description Pads message and performs final hash operations
         */
        Md5.prototype.finalize = function () {
            if (this.finalized) {
                return;
            }
            this.finalized = true;
            var blocks = this.blocks, i = this.lastByteIndex;
            blocks[i >>> 2] |= EXTRA[i & 3];
            if (i >= 56) {
                if (!this.hashed) {
                    this.hash();
                }
                blocks[0] = blocks[16];
                blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                    blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                    blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                    blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            }
            blocks[14] = this.bytes << 3;
            blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
            this.hash();
        };

        /**
         * Internal hash computation round
         * @method hash
         * @memberof Md5
         * @description Performs one MD5 hash block computation
         */
        Md5.prototype.hash = function () {
            var a, b, c, d, bc, da, blocks = this.blocks;

            if (this.first) {
                a = blocks[0] - 680876937;
                a = (a << 7 | a >>> 25) - 271733879 << 0;
                d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
                d = (d << 12 | d >>> 20) + a << 0;
                c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;
                c = (c << 17 | c >>> 15) + d << 0;
                b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;
                b = (b << 22 | b >>> 10) + c << 0;
            } else {
                a = this.h0;
                b = this.h1;
                c = this.h2;
                d = this.h3;
                a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;
                a = (a << 7 | a >>> 25) + b << 0;
                d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;
                d = (d << 12 | d >>> 20) + a << 0;
                c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;
                c = (c << 17 | c >>> 15) + d << 0;
                b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;
                b = (b << 22 | b >>> 10) + c << 0;
            }

            a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;
            b = (b << 20 | b >>> 12) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[5] - 378558;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[8] - 2022574463;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[11] + 1839030562;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[14] - 35309556;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[1] - 1530992060;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[4] + 1272893353;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[7] - 155497632;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[10] - 1094730640;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[13] + 681279174;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[0] - 358537222;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[3] - 722521979;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[6] + 76029189;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[9] - 640364487;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[12] - 421815835;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[15] + 530742520;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[2] - 995338651;
            b = (b << 23 | b >>> 9) + c << 0;
            a += (c ^ (b | ~d)) + blocks[0] - 198630844;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[5] - 57434055;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[10] - 1051523;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[15] - 30611744;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[4] - 145523070;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[2] + 718787259;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[9] - 343485551;
            b = (b << 21 | b >>> 11) + c << 0;

            if (this.first) {
                this.h0 = a + 1732584193 << 0;
                this.h1 = b - 271733879 << 0;
                this.h2 = c - 1732584194 << 0;
                this.h3 = d + 271733878 << 0;
                this.first = false;
            } else {
                this.h0 = this.h0 + a << 0;
                this.h1 = this.h1 + b << 0;
                this.h2 = this.h2 + c << 0;
                this.h3 = this.h3 + d << 0;
            }
        };

        /**
         * @method hex
         * @memberof Md5
         * @instance
         * @description Output hash as hex string
         * @returns {String} Hex string
         * @see {@link md5.hex}
         * @example
         * hash.hex();
         */
        Md5.prototype.hex = function () {
            this.finalize();

            var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;

            return HEX_CHARS[(h0 >>> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
                HEX_CHARS[(h0 >>> 12) & 0x0F] + HEX_CHARS[(h0 >>> 8) & 0x0F] +
                HEX_CHARS[(h0 >>> 20) & 0x0F] + HEX_CHARS[(h0 >>> 16) & 0x0F] +
                HEX_CHARS[(h0 >>> 28) & 0x0F] + HEX_CHARS[(h0 >>> 24) & 0x0F] +
                HEX_CHARS[(h1 >>> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
                HEX_CHARS[(h1 >>> 12) & 0x0F] + HEX_CHARS[(h1 >>> 8) & 0x0F] +
                HEX_CHARS[(h1 >>> 20) & 0x0F] + HEX_CHARS[(h1 >>> 16) & 0x0F] +
                HEX_CHARS[(h1 >>> 28) & 0x0F] + HEX_CHARS[(h1 >>> 24) & 0x0F] +
                HEX_CHARS[(h2 >>> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
                HEX_CHARS[(h2 >>> 12) & 0x0F] + HEX_CHARS[(h2 >>> 8) & 0x0F] +
                HEX_CHARS[(h2 >>> 20) & 0x0F] + HEX_CHARS[(h2 >>> 16) & 0x0F] +
                HEX_CHARS[(h2 >>> 28) & 0x0F] + HEX_CHARS[(h2 >>> 24) & 0x0F] +
                HEX_CHARS[(h3 >>> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
                HEX_CHARS[(h3 >>> 12) & 0x0F] + HEX_CHARS[(h3 >>> 8) & 0x0F] +
                HEX_CHARS[(h3 >>> 20) & 0x0F] + HEX_CHARS[(h3 >>> 16) & 0x0F] +
                HEX_CHARS[(h3 >>> 28) & 0x0F] + HEX_CHARS[(h3 >>> 24) & 0x0F];
        };
        return Md5;
    })();
}

/* CommonJS export for Node.js */
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ESPFlasher;
}
    </script>
    <script>
/* Inlined from esp32-parser.js */
// ESP32 Firmware Parser JavaScript Implementation
// Based on the C implementation from esp32.c

/**
 * SparseImage - Abstraction layer for accessing binary data with caching
 * Acts like a Uint8Array but lazily loads data from a device/source through a callback
 * 
 * Use cases:
 * 1. Reading from slow devices (e.g., flash memory over serial)
 * 2. Working with large files where only portions are needed
 * 3. Caching frequently accessed regions
 * 
 * Example usage:
 * ```javascript
 * // Create a SparseImage with a read callback
 * const sparseImage = new SparseImage(1024 * 1024, (address, size) => {
 *     // This callback is called when data is not in cache
 *     // Read from your device here
 *     return deviceRead(address, size); // Should return Uint8Array
 * });
 * 
 * // Wrap in proxy for array-like access
 * const buffer = SparseImage._createProxy(sparseImage);
 * 
 * // Access like a normal Uint8Array - data is fetched automatically
 * const byte = buffer[0x1000];
 * const chunk = buffer.subarray(0x1000, 0x2000);
 * ```
 * 
 * Architecture:
 * - ReadBuffer: Array of {address, data} segments containing cached read data
 * - ReadData callback: Called to fetch missing data from device/source
 * - Automatic merging: Adjacent/overlapping segments are merged to optimize memory
 * 
 * Future enhancement:
 * - WriteBuffer: Parallel buffer for tracking writes before committing to device
 *   - Reads check WriteBuffer first, then ReadBuffer
 *   - Allows batching writes and deferred commit operations
 */
class SparseImage {
    constructor(size, readDataCallback = null, writeDataCallback = null, flushPrepareCallback = null, sectorSize = 0x1000) {
        this.size = size;
        this.readDataCallback = readDataCallback;
        this.writeDataCallback = writeDataCallback;
        this.flushPrepareCallback = flushPrepareCallback;
        this.sectorSize = sectorSize || 0x1000;
        this.readBuffer = []; // Array of {address, data} structures
        this.writeBuffer = []; // Array of {address, data} structures
        this.length = size;
        /* Lock to ensure _ensureData executes serially */
        this._ensureDataLock = Promise.resolve();

        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    /**
     * Initialize from an existing ArrayBuffer/Uint8Array
     */
    static fromBuffer(arrayBuffer, sectorSize = 0x1000) {
        const buffer = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
        const sparseImage = new SparseImage(buffer.length, null, null, null, sectorSize);
        sparseImage.readBuffer.push({
            address: 0,
            data: buffer
        });
        return sparseImage;
    }

    /**
     * Find which buffer segment contains the given address
     */
    _findSegment(address, list = this.readBuffer) {
        for (const segment of list) {
            const endAddress = segment.address + segment.data.length;
            if (address >= segment.address && address < endAddress) {
                return segment;
            }
        }
        return null;
    }

    /**
     * Check if a range is fully covered by existing segments
     */
    _isRangeCovered(address, size, list = this.readBuffer) {
        let checkPos = address;
        const endAddress = address + size;

        while (checkPos < endAddress) {
            const segment = this._findSegment(checkPos, list);
            if (!segment) {
                return false;
            }
            checkPos = segment.address + segment.data.length;
        }
        return true;
    }

    /**
     * Check if a range is covered by either write or read buffers
     */
    _isRangeCoveredAny(address, size) {
        let checkPos = address;
        const endAddress = address + size;
        while (checkPos < endAddress) {
            const w = this._findSegment(checkPos, this.writeBuffer);
            if (w) {
                checkPos = Math.min(endAddress, w.address + w.data.length);
                continue;
            }
            const r = this._findSegment(checkPos, this.readBuffer);
            if (r) {
                checkPos = Math.min(endAddress, r.address + r.data.length);
                continue;
            }
            return false;
        }
        return true;
    }

    /**
     * Find the first gap within [address, address+size) not covered by write/read buffers.
     * Returns { start, size } or null if fully covered.
     */
    _findFirstGapRange(address, size) {
        const endAddress = address + size;
        let pos = address;
        while (pos < endAddress) {
            const w = this._findSegment(pos, this.writeBuffer);
            if (w) {
                pos = Math.min(endAddress, w.address + w.data.length);
                continue;
            }
            const r = this._findSegment(pos, this.readBuffer);
            if (r) {
                pos = Math.min(endAddress, r.address + r.data.length);
                continue;
            }
            /* pos is not covered: determine gap end at next segment start or endAddress */
            let nextStart = endAddress;
            for (const s of this.writeBuffer) {
                if (s.address > pos && s.address < nextStart) nextStart = s.address;
            }
            for (const s of this.readBuffer) {
                if (s.address > pos && s.address < nextStart) nextStart = s.address;
            }
            return { start: pos, size: nextStart - pos };
        }
        return null;
    }

    _mergeSegmentsGeneric(list) {
        if (list.length <= 1) return list;

        const indexed = list.map((segment, idx) => ({ ...segment, _idx: idx }));
        indexed.sort((a, b) => {
            if (a.address === b.address) {
                return a._idx - b._idx;
            }
            return a.address - b.address;
        });

        const merged = [];
        let current = indexed[0];

        for (let i = 1; i < indexed.length; i++) {
            const next = indexed[i];
            const currentEnd = current.address + current.data.length;

            if (next.address <= currentEnd) {
                const mergedEnd = Math.max(currentEnd, next.address + next.data.length);
                const mergedSize = mergedEnd - current.address;
                const mergedData = new Uint8Array(mergedSize);
                mergedData.set(current.data, 0);
                const nextOffset = next.address - current.address;
                mergedData.set(next.data, nextOffset);
                current = {
                    address: current.address,
                    data: mergedData
                };
            } else {
                merged.push({ address: current.address, data: current.data });
                current = next;
            }
        }
        merged.push({ address: current.address, data: current.data });
        return merged;
    }

    /**
     * Merge adjacent or overlapping segments in the readBuffer
     */
    _mergeSegments() {
        this.readBuffer = this._mergeSegmentsGeneric(this.readBuffer);
    }

    _mergeWriteSegments() {
        this.writeBuffer = this._mergeSegmentsGeneric(this.writeBuffer);
    }

    _effectiveByte(pos) {
        const w = this._findSegment(pos, this.writeBuffer);
        if (w) return w.data[pos - w.address] & 0xFF;
        const r = this._findSegment(pos, this.readBuffer);
        if (r) return r.data[pos - r.address] & 0xFF;
        return 0xFF;
    }

    _materializeRange(start, end) {
        const len = end - start;
        const out = new Uint8Array(len);
        out.fill(0xFF);

        for (const seg of this.readBuffer) {
            const s0 = seg.address;
            const s1 = seg.address + seg.data.length;
            const o0 = Math.max(start, s0);
            const o1 = Math.min(end, s1);
            if (o0 < o1) {
                const dstOff = o0 - start;
                const srcOff = o0 - s0;
                out.set(seg.data.subarray(srcOff, srcOff + (o1 - o0)), dstOff);
            }
        }

        for (const seg of this.writeBuffer) {
            const s0 = seg.address;
            const s1 = seg.address + seg.data.length;
            const o0 = Math.max(start, s0);
            const o1 = Math.min(end, s1);
            if (o0 < o1) {
                const dstOff = o0 - start;
                const srcOff = o0 - s0;
                out.set(seg.data.subarray(srcOff, srcOff + (o1 - o0)), dstOff);
            }
        }

        return out;
    }

    _materializeReadRange(start, end) {
        const len = end - start;
        const out = new Uint8Array(len);
        out.fill(0xFF);

        for (const seg of this.readBuffer) {
            const s0 = seg.address;
            const s1 = seg.address + seg.data.length;
            const o0 = Math.max(start, s0);
            const o1 = Math.min(end, s1);
            if (o0 < o1) {
                const dstOff = o0 - start;
                const srcOff = o0 - s0;
                out.set(seg.data.subarray(srcOff, srcOff + (o1 - o0)), dstOff);
            }
        }

        return out;
    }

    _addSegment(list, address, data) {
        list.push({ address, data });
        return this._mergeSegmentsGeneric(list);
    }

    /**
     * Read data from the sparse image, fetching from device if necessary
     */
    async _ensureData(address, size) {
        /* Acquire lock to ensure only one _ensureData executes at a time */
        const run = () => this._ensureDataUnlocked(address, size);
        this._ensureDataLock = this._ensureDataLock.then(run, run);
        return this._ensureDataLock;
    }

    /**
     * Internal _ensureData implementation (unlocked)
     * @private
     */
    async _ensureDataUnlocked(address, size) {
        if (address < 0 || address >= this.size) {
            throw new RangeError(`Address ${address} out of bounds [0, ${this.size})`);
        }

        // Clamp size to available data
        size = Math.min(size, this.size - address);

        // If range is already covered by write or read cache, nothing to do
        if (this._isRangeCoveredAny(address, size)) return;

        // Fill gaps: either by read callback (preferred) or zero-fill if no callback
        let safety = 64;
        while (!this._isRangeCoveredAny(address, size) && safety-- > 0) {
            const gap = this._findFirstGapRange(address, size);
            if (!gap || gap.size <= 0) break;

            if (!this.readDataCallback) {
                /* No callback - create zero segment only for the uncovered gap */
                const data = new Uint8Array(gap.size);
                this.readBuffer = this._addSegment(this.readBuffer, gap.start, data);
                continue;
            }

            /* Call the callback; it may return more/less and with its own base address */
            const res = await this.readDataCallback(gap.start, gap.size);
            let a = null;
            let d = null;
            if (res instanceof Uint8Array) {
                a = gap.start;
                d = res;
            } else if (res && res.buffer instanceof ArrayBuffer && res.byteLength !== undefined) {
                /* Accept ArrayBufferView-like */
                a = gap.start;
                d = new Uint8Array(res.buffer, res.byteOffset || 0, res.byteLength);
            } else if (res && typeof res === 'object') {
                const rAddr = res.address !== undefined ? res.address : gap.start;
                const rData = res.data;
                if (rData instanceof Uint8Array) {
                    a = rAddr;
                    d = rData;
                } else if (rData && rData.buffer instanceof ArrayBuffer && rData.byteLength !== undefined) {
                    a = rAddr;
                    d = new Uint8Array(rData.buffer, rData.byteOffset || 0, rData.byteLength);
                }
            }

            if (d && d.length > 0) {
                this.readBuffer = this._addSegment(this.readBuffer, a, d);
                // loop will re-check coverage
            } else {
                // No progress possible from callback, avoid infinite loop
                break;
            }
        }
    }

    write(address, data) {
        if (address < 0 || address >= this.size) {
            throw new RangeError(`Address ${address} out of bounds [0, ${this.size})`);
        }
        const normalized = data instanceof Uint8Array ? data : new Uint8Array(data);
        const start = address;
        const end = Math.min(address + normalized.length, this.size);
        if (end <= start) return;

        const fmtRanges = (list) => list.map(s => `[0x${s.address.toString(16)}-0x${(s.address + s.data.length).toString(16)})`).join(', ');
        const preRanges = fmtRanges(this.writeBuffer);
        // this.logDebug('SparseImage.write start', { address: start, length: normalized.length, preRanges });
        const sectorSize = this.sectorSize || 0x1000;
        const touchedSectors = new Set();

        /* Helper: find write buffer segment that covers pos */
        const findWriteSeg = (pos) => this._findSegment(pos, this.writeBuffer);

        /* Helper: find any cached segment (write preferred, then read) that covers pos */
        const findCachedSeg = (pos) => findWriteSeg(pos) || this._findSegment(pos, this.readBuffer);

        /* Helper: merge touching/overlapping segments after modifications */
        const mergeWrites = () => {
            this.writeBuffer = this._mergeSegmentsGeneric(this.writeBuffer);
        };

        /* Helper: mark sectors touched by a range */
        const markSectors = (rangeStart, rangeEnd) => {
            for (let s = Math.floor(rangeStart / sectorSize) * sectorSize; s < rangeEnd; s += sectorSize) {
                touchedSectors.add(s);
            }
        };

        /* Helper: compute next boundary where coverage changes */
        const nextBoundary = (pos, limit) => {
            let nb = limit;
            for (const s of [...this.readBuffer, ...this.writeBuffer]) {
                if (s.address > pos && s.address < nb) nb = s.address;
                const sEnd = s.address + s.data.length;
                if (sEnd > pos && sEnd < nb) nb = sEnd;
            }
            const sectorEnd = Math.min(limit, (Math.floor(pos / sectorSize) + 1) * sectorSize);
            if (sectorEnd > pos && sectorEnd < nb) nb = sectorEnd;
            return nb;
        };

        let pos = start;
        let remaining = end - start;

        while (remaining > 0) {
            /* Case 1: existing write buffer covers current position */
            const wseg = findWriteSeg(pos);
            if (wseg) {
                const offset = pos - wseg.address;
                const span = Math.min(remaining, wseg.data.length - offset);
                wseg.data.set(normalized.subarray(pos - start, pos - start + span), offset);
                markSectors(pos, pos + span);
                pos += span;
                remaining -= span;
                continue;
            }

            /* Case 2: cached (read) data covers current position */
            const cseg = findCachedSeg(pos);
            if (cseg) {
                const offset = pos - cseg.address;
                const span = Math.min(remaining, cseg.data.length - offset);

                /* Check matching prefix */
                let matchLen = 0;
                while (matchLen < span) {
                    const desired = normalized[pos - start + matchLen] & 0xFF;
                    if (cseg.data[offset + matchLen] !== desired) break;
                    matchLen++;
                }

                if (matchLen > 0) {
                    pos += matchLen;
                    remaining -= matchLen;
                    continue;
                }

                /* Mismatch: see if full sector is FULLY cached in readBuffer */
                const sectorStart = Math.floor(pos / sectorSize) * sectorSize;
                const sectorEnd = Math.min(sectorStart + sectorSize, this.size);
                if (this._isRangeCovered(sectorStart, sectorEnd - sectorStart, this.readBuffer)) {
                    const sectorBuf = this._materializeRange(sectorStart, sectorEnd);
                    const writeStart = pos;
                    const writeEnd = Math.min(end, sectorEnd);
                    sectorBuf.set(
                        normalized.subarray(writeStart - start, writeEnd - start),
                        writeStart - sectorStart
                    );
                    this.writeBuffer = this._addSegment(this.writeBuffer, sectorStart, sectorBuf);
                    markSectors(sectorStart, sectorEnd);
                    pos = writeEnd;
                    remaining = end - pos;
                    continue;
                }

                /* Not fully cached: create a new segment until the next boundary */
                const boundary = nextBoundary(pos, end);
                const writeEnd = Math.min(boundary, end);
                const slice = normalized.slice(pos - start, writeEnd - start);
                this.writeBuffer = this._addSegment(this.writeBuffer, pos, slice);
                markSectors(pos, writeEnd);
                mergeWrites();
                pos = writeEnd;
                remaining = end - pos;
                continue;
            }

            /* Case 3: no cache coverage; create a new segment up to next sector/boundary */
            const boundary = nextBoundary(pos, end);
            const writeEnd = Math.min(boundary, end);
            const slice = normalized.slice(pos - start, writeEnd - start);
            this.writeBuffer = this._addSegment(this.writeBuffer, pos, slice);
            markSectors(pos, writeEnd);
            mergeWrites();
            pos = writeEnd;
            remaining = end - pos;
        }

        /* Cleanup: remove sectors we touched that are identical to cached data */
        for (const sectorStart of touchedSectors) {
            const sectorEnd = Math.min(sectorStart + sectorSize, this.size);

            /* Only prune if the sector is fully backed by real read cache and matches */
            const readCovered = this._isRangeCovered(sectorStart, sectorEnd - sectorStart, this.readBuffer);
            if (!readCovered) {
                continue;
            }

            const baseline = this._materializeReadRange(sectorStart, sectorEnd);
            const combined = this._materializeRange(sectorStart, sectorEnd);

            let identical = baseline.length === combined.length;
            if (identical) {
                for (let i = 0; i < combined.length; i++) {
                    if (combined[i] !== baseline[i]) {
                        identical = false;
                        break;
                    }
                }
            }

            if (identical) {
                const pruned = [];
                for (const seg of this.writeBuffer) {
                    const segStart = seg.address;
                    const segEnd = seg.address + seg.data.length;
                    if (segEnd <= sectorStart || segStart >= sectorEnd) {
                        pruned.push(seg);
                        continue;
                    }

                    if (segStart < sectorStart) {
                        const left = seg.data.slice(0, sectorStart - segStart);
                        if (left.length) pruned.push({ address: segStart, data: left });
                    }

                    if (segEnd > sectorEnd) {
                        const right = seg.data.slice(sectorEnd - segStart);
                        if (right.length) pruned.push({ address: sectorEnd, data: right });
                    }
                }
                this.writeBuffer = this._mergeSegmentsGeneric(pruned);
            }
        }

        /* Ensure buffers are merged after all operations */
        mergeWrites();

        const postRanges = fmtRanges(this.writeBuffer);
        // this.logDebug('SparseImage.write done', { address: start, length: normalized.length, preRanges, postRanges });
    }

    fill(value, start = 0, end = this.size) {
        if (start < 0 || start >= this.size) {
            throw new RangeError(`Address ${start} out of bounds [0, ${this.size})`);
        }
        end = Math.min(end, this.size);
        if (end <= start) return;

        const desired = value & 0xFF;
        const len = end - start;
        const buf = new Uint8Array(len);
        buf.fill(desired);
        // this.logDebug('SparseImage.fill', { start, end, len, desired });
        this.write(start, buf);
    }

    async flush() {
        if (!this.writeBuffer.length) return;

        // Consolidate write segments first (touching/overlapping writes coalesce)
        this._mergeWriteSegments();

        /* Call prepare callback if provided */
        if (this.flushPrepareCallback) {
            await this.flushPrepareCallback(this);
        }

        // Flush to backing store if provided
        if (this.writeDataCallback) {
            // Deterministic order: ascending address
            const toWrite = [...this.writeBuffer].sort((a, b) => a.address - b.address);
            for (const segment of toWrite) {
                await this.writeDataCallback(segment.address, segment.data);
            }
        }

        // Merge read+write with explicit priority: write data overrides read data
        this.readBuffer = this._mergeReadAndWriteWithPriority(this.readBuffer, this.writeBuffer);

        // Clear pending writes
        this.writeBuffer = [];
    }

    async clear(){
        this.readBuffer = [];
        this.writeBuffer = [];
    }

    /**
     * Merge read and write buffers into a single read buffer, ensuring
     * write data has priority over read data in any overlap. Touching
     * segments are merged into a single continuous segment.
     */
    _mergeReadAndWriteWithPriority(readList, writeList) {
        if ((!readList || readList.length === 0) && (!writeList || writeList.length === 0)) {
            return [];
        }

        const annotated = [];
        if (readList && readList.length) {
            for (const s of readList) annotated.push({ address: s.address, data: s.data, _src: 'r' });
        }
        if (writeList && writeList.length) {
            for (const s of writeList) annotated.push({ address: s.address, data: s.data, _src: 'w' });
        }

        // Sort by address to form contiguous/touching groups
        annotated.sort((a, b) => a.address - b.address);

        const result = [];
        let group = [];
        let groupStart = null;
        let groupEnd = null;

        const flushGroup = () => {
            if (!group.length) return;
            const length = groupEnd - groupStart;
            const mergedData = new Uint8Array(length);

            // Overlay order: read first, then write (write overrides)
            for (const seg of group) {
                if (seg._src !== 'r') continue;
                const off = seg.address - groupStart;
                mergedData.set(seg.data, off);
            }
            for (const seg of group) {
                if (seg._src !== 'w') continue;
                const off = seg.address - groupStart;
                mergedData.set(seg.data, off);
            }

            result.push({ address: groupStart, data: mergedData });
            group = [];
            groupStart = null;
            groupEnd = null;
        };

        for (const seg of annotated) {
            const segStart = seg.address;
            const segEnd = seg.address + seg.data.length;
            if (groupStart === null) {
                // start new group
                groupStart = segStart;
                groupEnd = segEnd;
                group.push(seg);
                continue;
            }
            // Merge if overlapping or touching
            if (segStart <= groupEnd) {
                group.push(seg);
                if (segEnd > groupEnd) groupEnd = segEnd;
            } else {
                // Gap: finalize previous group
                flushGroup();
                // start new group
                groupStart = segStart;
                groupEnd = segEnd;
                group.push(seg);
            }
        }

        flushGroup();
        return result;
    }

    /**
     * Get a single byte at the given offset (Uint8Array-like interface)
     * NOTE: Assumes data is already loaded. Use async methods to ensure data first.
     */
    _get(index) {
        if (index < 0 || index >= this.size) {
            return undefined;
        }

        // Write buffer overrides read buffer
        const wseg = this._findSegment(index, this.writeBuffer);
        if (wseg) {
            return wseg.data[index - wseg.address];
        }

        const segment = this._findSegment(index, this.readBuffer);
        if (!segment) {
            return 0; // Return 0 for unread data
        }

        return segment.data[index - segment.address];
    }

    /**
     * Proxy handler to make SparseImage act like a Uint8Array
     */
    static _createProxy(sparseImage) {
        return new Proxy(sparseImage, {
            get(target, prop) {
                if (typeof prop === 'symbol') {
                    return target[prop];
                }
                // Handle numeric indices
                const index = Number(prop);
                if (Number.isInteger(index) && index >= 0) {
                    return target._get(index);
                }

                // Handle standard properties and methods
                if (prop in target) {
                    const value = target[prop];
                    return typeof value === 'function' ? value.bind(target) : value;
                }

                return undefined;
            },

            set(target, prop, value) {
                if (typeof prop === 'symbol') {
                    target[prop] = value;
                    return true;
                }
                const index = Number(prop);
                if (Number.isInteger(index) && index >= 0) {
                    const byte = Number(value) & 0xFF;
                    target.write(index, Uint8Array.of(byte));
                    return true;
                }

                target[prop] = value;
                return true;
            },

            has(target, prop) {
                if (typeof prop === 'symbol') {
                    return prop in target;
                }
                const index = Number(prop);
                if (Number.isInteger(index) && index >= 0 && index < target.size) {
                    return true;
                }
                return prop in target;
            }
        });
    }

    /**
     * Get a subarray (similar to Uint8Array.subarray)
     * SYNC version - assumes data is already loaded via prefetch/ensureData
     */
    subarray(start, end) {
        start = start || 0;
        end = end === undefined ? this.size : end;

        const size = end - start;

        const result = new Uint8Array(size);
        for (let pos = start, idx = 0; pos < end; pos++, idx++) {
            result[idx] = this._get(pos);
        }

        return result;
    }

    /**
     * Get a subarray asynchronously (ensures data is loaded first)
     */
    async subarray_async(start, end) {
        start = start || 0;
        end = end === undefined ? this.size : end;

        const size = end - start;

        // Ensure all data is loaded first
        await this._ensureData(start, size);

        const result = new Uint8Array(size);
        for (let pos = start, idx = 0; pos < end; pos++, idx++) {
            result[idx] = this._get(pos);
        }

        return result;
    }

    /**
     * Get a slice (creates a copy, similar to Uint8Array.slice)
     * SYNC version - assumes data is already loaded
     */
    slice(start, end) {
        return this.subarray(start, end);
    }

    /**
     * Get a slice asynchronously (ensures data is loaded first)
     */
    async slice_async(start, end) {
        return await this.subarray_async(start, end);
    }

    /**
     * Create a DataView for this SparseImage
     */
    createDataView() {
        return new SparseImageDataView(this);
    }



    /**
     * Pre-fetch a range of data
     */
    async prefetch(address, size) {
        return await this._ensureData(address, size);
    }
}


class FATParser {
    constructor(sparseImage, startOffset, size) {
        if (!sparseImage) {
            throw new Error('FATParser requires a SparseImage');
        }
        this.sparseImage = sparseImage;
        this.startOffset = startOffset;
        this.size = size;
        this.buffer = SparseImage._createProxy(sparseImage);
        this.view = sparseImage.createDataView();
        this.fatInfo = null;
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    async initialize() {
        this.fatInfo = await this.parse();
        return this.fatInfo;
    }

    async parseWearLeveling() {
        const WL_SECTOR_SIZE = 0x1000;
        const WL_STATE_RECORD_SIZE = 16;
        const WL_STATE_COPY_COUNT = 2;
        const offset = this.startOffset;
        const length = this.size;

        const totalSectors = Math.floor(length / WL_SECTOR_SIZE);
        const wlStateSize = 64 + WL_STATE_RECORD_SIZE * totalSectors;
        const wlStateSectors = Math.ceil(wlStateSize / WL_SECTOR_SIZE);
        const wlSectorsSize = (wlStateSectors * WL_SECTOR_SIZE * WL_STATE_COPY_COUNT) + WL_SECTOR_SIZE;
        const fatSectors = totalSectors - 1 - (WL_STATE_COPY_COUNT * wlStateSectors);

        const stateOffset = offset + length - wlSectorsSize;
        if (stateOffset + 64 > this.sparseImage.size) {
            return { error: 'Cannot read wear leveling state' };
        }

        const wlState = {
            pos: await this.view.getUint32(stateOffset, true),
            maxPos: await this.view.getUint32(stateOffset + 4, true),
            moveCount: await this.view.getUint32(stateOffset + 8, true),
            accessCount: await this.view.getUint32(stateOffset + 12, true),
            maxCount: await this.view.getUint32(stateOffset + 16, true),
            blockSize: await this.view.getUint32(stateOffset + 20, true),
            version: await this.view.getUint32(stateOffset + 24, true),
            deviceId: await this.view.getUint32(stateOffset + 28, true)
        };

        let totalRecords = 0;
        let recordOffset = stateOffset + 64;
        for (let i = 0; i < wlStateSize && recordOffset + WL_STATE_RECORD_SIZE <= this.sparseImage.size; i++) {
            let isEmpty = true;
            for (let j = 0; j < WL_STATE_RECORD_SIZE; j++) {
                if ((await this.view.getUint8(recordOffset + j)) !== 0xFF) {
                    isEmpty = false;
                    break;
                }
            }
            if (isEmpty) break;
            totalRecords++;
            recordOffset += WL_STATE_RECORD_SIZE;
        }

        return {
            wlState: wlState,
            totalSectors: totalSectors,
            wlSectorsSize: wlSectorsSize,
            fatSectors: fatSectors,
            totalRecords: totalRecords,
            dataOffset: offset,
            dataSize: length - wlSectorsSize
        };
    }

    wlTranslateSector(wlInfo, sector) {
        let translated = (sector + wlInfo.wlState.moveCount) % wlInfo.fatSectors;
        if (translated >= wlInfo.totalRecords) {
            translated += 1;
        }
        return translated;
    }

    /*
     * Read from a logical sector, with wear leveling translation applied
     * Returns absolute offset in sparseImage for the given logical sector
     */
    wlSectorToOffset(wlInfo, logicalSector) {
        const WL_SECTOR_SIZE = 0x1000;
        const physicalSector = this.wlTranslateSector(wlInfo, logicalSector);
        return this.startOffset + physicalSector * WL_SECTOR_SIZE;
    }

    async parse() {
        const WL_SECTOR_SIZE = 0x1000;
        const wlInfo = await this.parseWearLeveling();
        if (wlInfo.error) {
            return { error: wlInfo.error };
        }

        const sector0Physical = this.wlTranslateSector(wlInfo, 0);
        const bootSectorOffset = this.wlSectorToOffset(wlInfo, 0);
        if (bootSectorOffset + 512 > this.sparseImage.size) {
            return { error: 'Cannot read FAT boot sector' };
        }

        const bootSig = await this.view.getUint16(bootSectorOffset + 510, true);
        if (bootSig !== 0xAA55) {
            return { error: `Invalid boot sector signature: 0x${bootSig.toString(16).toUpperCase()} (expected 0xAA55)` };
        }

        const bytesPerSector = await this.view.getUint16(bootSectorOffset + 11, true);
        const sectorsPerCluster = await this.view.getUint8(bootSectorOffset + 13);
        const reservedSectors = await this.view.getUint16(bootSectorOffset + 14, true);
        const numFATs = await this.view.getUint8(bootSectorOffset + 16);
        const rootEntryCount = await this.view.getUint16(bootSectorOffset + 17, true);
        const totalSectors16 = await this.view.getUint16(bootSectorOffset + 19, true);
        const sectorsPerFAT = await this.view.getUint16(bootSectorOffset + 22, true);
        const totalSectors32 = await this.view.getUint32(bootSectorOffset + 32, true);

        if (bytesPerSector === 0 || sectorsPerCluster === 0 || numFATs === 0) {
            return { error: 'Invalid FAT boot sector parameters' };
        }

        const totalSectors = totalSectors16 || totalSectors32;
        const rootDirSectors = Math.ceil((rootEntryCount * 32) / bytesPerSector);
        const firstDataSector = reservedSectors + (numFATs * sectorsPerFAT) + rootDirSectors;
        const dataSectors = totalSectors - firstDataSector;
        const totalClusters = Math.floor(dataSectors / sectorsPerCluster);

        let fatType;
        if (totalClusters < 4085) fatType = 'FAT12';
        else if (totalClusters < 65525) fatType = 'FAT16';
        else fatType = 'FAT32';

        let volumeLabel = '';
        for (let i = 0; i < 11; i++) {
            const c = await this.view.getUint8(bootSectorOffset + 43 + i);
            if (c === 0 || c === 0x20) break;
            volumeLabel += String.fromCharCode(c);
        }

        const rootDirOffset = this.wlSectorToOffset(wlInfo, reservedSectors + numFATs * sectorsPerFAT);

        const files = await this.parseDirectory(wlInfo, rootDirOffset, rootEntryCount,
            bytesPerSector, sectorsPerCluster, reservedSectors, numFATs, sectorsPerFAT, '', true);

        this.fatInfo = {
            fatType: fatType,
            volumeLabel: volumeLabel || '(no label)',
            bytesPerSector: bytesPerSector,
            sectorsPerCluster: sectorsPerCluster,
            reservedSectors: reservedSectors,
            numFATs: numFATs,
            sectorsPerFAT: sectorsPerFAT,
            totalSectors: totalSectors,
            totalClusters: totalClusters,
            files: files,
            wearLeveling: wlInfo
        };

        return this.fatInfo;
    }

    async parseDirectory(wlInfo, dirOffset, maxEntries, bytesPerSector, sectorsPerCluster,
        reservedSectors, numFATs, sectorsPerFAT, parentPath, isRoot = false) {
        const WL_SECTOR_SIZE = 0x1000;
        const files = [];
        const firstDataSector = reservedSectors + numFATs * sectorsPerFAT +
            Math.ceil((maxEntries || 512) * 32 / bytesPerSector);

        const maxIter = isRoot ? maxEntries : 512;

        for (let i = 0; i < maxIter; i++) {
            const entryOffset = dirOffset + i * 32;
            if (entryOffset + 32 > this.sparseImage.size) break;
            const firstByte = await this.view.getUint8(entryOffset);
            if (firstByte === 0x00) break;
            if (firstByte === 0xE5 || firstByte === 0x05) continue;
            const attr = await this.view.getUint8(entryOffset + 11);
            if (attr === 0x0F) continue;
            if (attr & 0x08) continue;

            let name = '';
            for (let j = 0; j < 8; j++) {
                const c = await this.view.getUint8(entryOffset + j);
                if (c !== 0x20 && c >= 0x20 && c <= 0x7E) name += String.fromCharCode(c);
            }
            let ext = '';
            for (let j = 0; j < 3; j++) {
                const c = await this.view.getUint8(entryOffset + 8 + j);
                if (c !== 0x20 && c >= 0x20 && c <= 0x7E) ext += String.fromCharCode(c);
            }
            if (name.length === 0 || name === '.' || name === '..') continue;
            if (ext) name += '.' + ext;

            const size = await this.view.getUint32(entryOffset + 28, true);
            const cluster = await this.view.getUint16(entryOffset + 26, true);

            const attributes = [];
            if (attr & 0x01) attributes.push('Read-only');
            if (attr & 0x02) attributes.push('Hidden');
            if (attr & 0x04) attributes.push('System');
            if (attr & 0x08) attributes.push('Volume');
            if (attr & 0x10) attributes.push('Directory');
            if (attr & 0x20) attributes.push('Archive');

            const date = await this.view.getUint16(entryOffset + 24, true);
            const time = await this.view.getUint16(entryOffset + 22, true);
            const year = ((date >> 9) & 0x7F) + 1980;
            const month = (date >> 5) & 0x0F;
            const day = date & 0x1F;
            const hour = (time >> 11) & 0x1F;
            const minute = (time >> 5) & 0x3F;
            const second = (time & 0x1F) * 2;

            const isDirectory = !!(attr & 0x10);
            const fullPath = parentPath ? `${parentPath}/${name}` : name;

            const fileEntry = {
                name: name,
                path: fullPath,
                size: size,
                cluster: cluster,
                attributes: attributes,
                isDirectory: isDirectory,
                date: `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`,
                time: `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:${second.toString().padStart(2, '0')}`,
                directorySector: dirOffset,
                directoryEntry: i
            };

            files.push(fileEntry);

            if (isDirectory && cluster >= 2 && cluster < 0xFFF0) {
                const clusterSector = firstDataSector + (cluster - 2) * sectorsPerCluster;
                const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

                if (clusterOffset + sectorsPerCluster * WL_SECTOR_SIZE <= this.sparseImage.size) {
                    const subFiles = await this.parseDirectory(wlInfo, clusterOffset, null,
                        bytesPerSector, sectorsPerCluster, reservedSectors, numFATs, sectorsPerFAT, fullPath, false);
                    fileEntry.children = subFiles;
                }
            }
        }

        return files;
    }

    async readFATEntry(cluster) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const fatOffset = fatInfo.reservedSectors * WL_SECTOR_SIZE;
        const fatType = fatInfo.fatType;

        if (fatType === 'FAT12') {
            const entryOffset = fatOffset + Math.floor(cluster * 1.5);
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;
            const val = await this.view.getUint16(sectorOffset + byteOffset, true);
            if (cluster & 1) {
                return val >> 4;
            } else {
                return val & 0x0FFF;
            }
        } else if (fatType === 'FAT16') {
            const entryOffset = fatOffset + cluster * 2;
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;
            return await this.view.getUint16(sectorOffset + byteOffset, true);
        } else {
            const entryOffset = fatOffset + cluster * 4;
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;
            return (await this.view.getUint32(sectorOffset + byteOffset, true)) & 0x0FFFFFFF;
        }
    }

    async extractFile(fileEntry) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const bytesPerCluster = fatInfo.bytesPerSector * fatInfo.sectorsPerCluster;
        const firstDataSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT +
            Math.ceil(512 * 32 / fatInfo.bytesPerSector);

        const clusters = [];
        let currentCluster = fileEntry.cluster;
        const maxClusters = Math.ceil(fileEntry.size / bytesPerCluster) + 10;

        while (currentCluster >= 2 && currentCluster < 0xFFF0 && clusters.length < maxClusters) {
            clusters.push(currentCluster);
            currentCluster = await this.readFATEntry(currentCluster);
        }

        const fileData = new Uint8Array(fileEntry.size);
        let bytesRead = 0;

        for (const cluster of clusters) {
            const clusterSector = firstDataSector + (cluster - 2) * fatInfo.sectorsPerCluster;
            const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

            const bytesToRead = Math.min(bytesPerCluster, fileEntry.size - bytesRead);
            if (clusterOffset + bytesToRead <= this.sparseImage.size) {
                fileData.set(await this.buffer.slice_async(clusterOffset, clusterOffset + bytesToRead), bytesRead);
                bytesRead += bytesToRead;
            }
            if (bytesRead >= fileEntry.size) break;
        }

        return new Blob([fileData], { type: 'application/octet-stream' });
    }

    /*
     * Find a file entry by its full path
     * @param {string} targetPath - Full path to search for (e.g., "CERT/CA.DER")
     * @returns {Object|null} - File entry if found, null otherwise
     */
    findFileByPath(targetPath) {
        if (!this.fatInfo || !this.fatInfo.files) {
            return null;
        }

        const searchRecursive = (files, path) => {
            if (!files) return null;
            for (const file of files) {
                if (file.path === path) {
                    return file;
                }
                if (file.children) {
                    const found = searchRecursive(file.children, path);
                    if (found) return found;
                }
            }
            return null;
        };

        return searchRecursive(this.fatInfo.files, targetPath);
    }

    /*
     * Delete a file by:
     * 1. Clearing all its clusters with 0xFF
     * 2. Setting FAT entries to unused (0x0000)
     * 3. Marking the directory entry as deleted (0xE5)
     */
    async deleteFile(fileEntry) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const bytesPerCluster = fatInfo.bytesPerSector * fatInfo.sectorsPerCluster;
        const firstDataSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT +
            Math.ceil(512 * 32 / fatInfo.bytesPerSector);

        /* Step 1: Get all clusters used by the file */
        const clusters = [];
        let currentCluster = fileEntry.cluster;
        const maxClusters = Math.ceil(fileEntry.size / bytesPerCluster) + 10;

        while (currentCluster >= 2 && currentCluster < 0xFFF0 && clusters.length < maxClusters) {
            clusters.push(currentCluster);
            currentCluster = await this.readFATEntry(currentCluster);
        }

        /* Step 2: Clear all clusters with 0xFF */
        const clearData = new Uint8Array(WL_SECTOR_SIZE);
        clearData.fill(0xFF);

        for (const cluster of clusters) {
            const clusterSector = firstDataSector + (cluster - 2) * fatInfo.sectorsPerCluster;
            const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

            /* Write 0xFF to each sector in the cluster */
            for (let i = 0; i < fatInfo.sectorsPerCluster; i++) {
                const sectorOffset = clusterOffset + i * WL_SECTOR_SIZE;
                this.sparseImage.write(sectorOffset, clearData);
            }
        }

        /* Step 3: Mark FAT entries as unused (0x0000) */
        for (const cluster of clusters) {
            const fatOffset = fatInfo.reservedSectors * WL_SECTOR_SIZE;
            const fatType = fatInfo.fatType;

            if (fatType === 'FAT12') {
                const entryOffset = fatOffset + Math.floor(cluster * 1.5);
                const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
                const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
                const byteOffset = entryOffset % WL_SECTOR_SIZE;

                /* Read current FAT entry */
                const val = await this.view.getUint16(sectorOffset + byteOffset, true);
                let newVal = val;

                if (cluster & 1) {
                    /* Odd cluster: upper 12 bits */
                    newVal = (val & 0x0FFF);
                } else {
                    /* Even cluster: lower 12 bits */
                    newVal = (val & 0xF000);
                }

                /* Write back the modified FAT entry */
                const writeData = new Uint8Array(2);
                new DataView(writeData.buffer).setUint16(0, newVal, true);
                this.sparseImage.write(sectorOffset + byteOffset, writeData);

            } else if (fatType === 'FAT16') {
                const entryOffset = fatOffset + cluster * 2;
                const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
                const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
                const byteOffset = entryOffset % WL_SECTOR_SIZE;

                const writeData = new Uint8Array(2);
                writeData.fill(0x00);
                this.sparseImage.write(sectorOffset + byteOffset, writeData);

            } else {
                /* FAT32 */
                const entryOffset = fatOffset + cluster * 4;
                const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
                const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
                const byteOffset = entryOffset % WL_SECTOR_SIZE;

                const writeData = new Uint8Array(4);
                writeData.fill(0x00);
                this.sparseImage.write(sectorOffset + byteOffset, writeData);
            }
        }

        /* Step 4: Mark directory entry as deleted (0xE5) */
        if (fileEntry.directorySector !== undefined && fileEntry.directoryEntry !== undefined) {
            const entryOffset = fileEntry.directorySector + fileEntry.directoryEntry * 32;
            const deleteMarker = new Uint8Array(1);
            deleteMarker[0] = 0xE5;
            this.sparseImage.write(entryOffset, deleteMarker);
        }

        return { success: true, clustersCleared: clusters.length };
    }

    /*
     * Add a file to the FAT filesystem
     * @param {string} path - Full path including filename (e.g., "dir/subdir/file.txt")
     * @param {Uint8Array} data - Binary data to write
     * @returns {Object} - Result with success status and details
     */
    async addFile(path, data) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const bytesPerCluster = fatInfo.bytesPerSector * fatInfo.sectorsPerCluster;
        const firstDataSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT +
            Math.ceil(512 * 32 / fatInfo.bytesPerSector);

        /* Parse path into directory path and filename */
        const parts = path.split('/').filter(p => p.length > 0);
        const filename = parts.pop();
        const dirPath = parts.join('/');

        if (!filename || filename.length > 12) {
            return { success: false, error: 'Invalid filename (max 8.3 format)' };
        }

        /* Parse filename into name and extension */
        const nameParts = filename.split('.');
        let name = nameParts[0].toUpperCase().padEnd(8, ' ').substring(0, 8);
        let ext = (nameParts[1] || '').toUpperCase().padEnd(3, ' ').substring(0, 3);

        /* Step 1: Find the target directory */
        const dirEntry = await this._findDirectory(dirPath);
        if (!dirEntry.found) {
            return { success: false, error: `Directory not found: ${dirPath || '(root)'}` };
        }

        /* Step 2: Find a free directory entry (prioritize deleted entries 0xE5) */
        const freeEntry = await this._findFreeDirectoryEntry(dirEntry.offset, dirEntry.isRoot, dirEntry.maxEntries);
        if (!freeEntry) {
            return { success: false, error: 'No free directory entries available' };
        }

        /* Step 3: Allocate clusters for the file */
        const clustersNeeded = Math.ceil(data.length / bytesPerCluster);
        const allocatedClusters = await this._allocateClusters(clustersNeeded);
        if (allocatedClusters.length < clustersNeeded) {
            return { success: false, error: 'Not enough free clusters' };
        }

        /* Step 4: Write data to allocated clusters */
        let bytesWritten = 0;
        for (let i = 0; i < allocatedClusters.length; i++) {
            const cluster = allocatedClusters[i];
            const clusterSector = firstDataSector + (cluster - 2) * fatInfo.sectorsPerCluster;
            const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

            const bytesToWrite = Math.min(bytesPerCluster, data.length - bytesWritten);
            const clusterData = data.slice(bytesWritten, bytesWritten + bytesToWrite);

            /* Write data to cluster */
            this.sparseImage.write(clusterOffset, clusterData);

            /* If less than full cluster, fill remainder with 0xFF */
            if (bytesToWrite < bytesPerCluster) {
                const fillData = new Uint8Array(bytesPerCluster - bytesToWrite);
                fillData.fill(0xFF);
                this.sparseImage.write(clusterOffset + bytesToWrite, fillData);
            }

            bytesWritten += bytesToWrite;
        }

        /* Step 5: Update FAT chain */
        for (let i = 0; i < allocatedClusters.length; i++) {
            const cluster = allocatedClusters[i];
            const nextCluster = (i < allocatedClusters.length - 1) ? allocatedClusters[i + 1] : 0xFFFF;
            await this._writeFATEntry(cluster, nextCluster);
        }

        /* Step 6: Write directory entry */
        const now = new Date();
        const dirEntryData = new Uint8Array(32);

        /* Filename (8 bytes) + Extension (3 bytes) */
        for (let i = 0; i < 8; i++) dirEntryData[i] = name.charCodeAt(i);
        for (let i = 0; i < 3; i++) dirEntryData[8 + i] = ext.charCodeAt(i);

        /* Attributes (1 byte): 0x20 = Archive */
        dirEntryData[11] = 0x20;

        /* Reserved (10 bytes) */
        for (let i = 12; i < 22; i++) dirEntryData[i] = 0x00;

        /* Time (2 bytes) */
        const time = ((now.getHours() & 0x1F) << 11) |
            ((now.getMinutes() & 0x3F) << 5) |
            ((now.getSeconds() / 2) & 0x1F);
        new DataView(dirEntryData.buffer).setUint16(22, time, true);

        /* Date (2 bytes) */
        const date = (((now.getFullYear() - 1980) & 0x7F) << 9) |
            (((now.getMonth() + 1) & 0x0F) << 5) |
            (now.getDate() & 0x1F);
        new DataView(dirEntryData.buffer).setUint16(24, date, true);

        /* First cluster (2 bytes) */
        new DataView(dirEntryData.buffer).setUint16(26, allocatedClusters[0], true);

        /* File size (4 bytes) */
        new DataView(dirEntryData.buffer).setUint32(28, data.length, true);

        /* Write directory entry */
        this.sparseImage.write(freeEntry.offset, dirEntryData);

        return {
            success: true,
            filename: filename,
            size: data.length,
            clusters: allocatedClusters.length,
            startCluster: allocatedClusters[0]
        };
    }

    /* Helper: Find directory by path */
    async _findDirectory(path) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;

        /* Root directory */
        if (!path || path === '') {
            const rootDirSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT;
            const rootDirOffset = this.wlSectorToOffset(wlInfo, rootDirSector);
            const maxEntries = 512; // Standard for FAT16 root directory

            return {
                found: true,
                offset: rootDirOffset,
                isRoot: true,
                maxEntries: maxEntries
            };
        }

        /* Navigate to subdirectory */
        const parts = path.split('/').filter(p => p.length > 0);
        let currentDir = fatInfo.files;

        for (const part of parts) {
            const found = currentDir.find(f => f.isDirectory && f.name.toLowerCase() === part.toLowerCase());
            if (!found) {
                return { found: false, error: `Directory not found: ${part}` };
            }
            currentDir = found.children || [];

            /* Get directory cluster offset */
            if (found.cluster >= 2 && found.cluster < 0xFFF0) {
                const firstDataSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT +
                    Math.ceil(512 * 32 / fatInfo.bytesPerSector);
                const clusterSector = firstDataSector + (found.cluster - 2) * fatInfo.sectorsPerCluster;
                const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

                return {
                    found: true,
                    offset: clusterOffset,
                    isRoot: false,
                    maxEntries: null // Subdirectory size limited by cluster
                };
            }
        }

        return { found: false, error: 'Invalid directory structure' };
    }

    /* Helper: Find free directory entry, prioritizing deleted entries */
    async _findFreeDirectoryEntry(dirOffset, isRoot, maxEntries) {
        const WL_SECTOR_SIZE = 0x1000;
        const maxIter = maxEntries || 512;
        let firstFreeEntry = null;

        for (let i = 0; i < maxIter; i++) {
            const entryOffset = dirOffset + i * 32;
            if (entryOffset + 32 > this.sparseImage.size) break;

            const firstByte = await this.view.getUint8(entryOffset);

            /* Deleted entry (0xE5) - prioritize this */
            if (firstByte === 0xE5) {
                return { offset: entryOffset, index: i, wasDeleted: true };
            }

            /* End of directory (0x00) - use this if no deleted entry found */
            if (firstByte === 0x00) {
                if (!firstFreeEntry) {
                    firstFreeEntry = { offset: entryOffset, index: i, wasDeleted: false };
                }
                break;
            }
        }

        return firstFreeEntry;
    }

    /* Helper: Allocate free clusters */
    async _allocateClusters(count) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const allocated = [];

        /* Scan FAT for free clusters (value 0x0000) */
        for (let cluster = 2; cluster < fatInfo.totalClusters && allocated.length < count; cluster++) {
            const entry = await this.readFATEntry(cluster);
            if (entry === 0x0000) {
                allocated.push(cluster);
            }
        }

        return allocated;
    }

    /* Helper: Write FAT entry */
    async _writeFATEntry(cluster, value) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const fatOffset = fatInfo.reservedSectors * WL_SECTOR_SIZE;
        const fatType = fatInfo.fatType;

        if (fatType === 'FAT12') {
            const entryOffset = fatOffset + Math.floor(cluster * 1.5);
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;

            /* Read current value */
            const currentVal = await this.view.getUint16(sectorOffset + byteOffset, true);
            let newVal;

            if (cluster & 1) {
                /* Odd cluster: upper 12 bits */
                newVal = (currentVal & 0x000F) | ((value & 0x0FFF) << 4);
            } else {
                /* Even cluster: lower 12 bits */
                newVal = (currentVal & 0xF000) | (value & 0x0FFF);
            }

            const writeData = new Uint8Array(2);
            new DataView(writeData.buffer).setUint16(0, newVal, true);
            this.sparseImage.write(sectorOffset + byteOffset, writeData);

        } else if (fatType === 'FAT16') {
            const entryOffset = fatOffset + cluster * 2;
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;

            const writeData = new Uint8Array(2);
            new DataView(writeData.buffer).setUint16(0, value & 0xFFFF, true);
            this.sparseImage.write(sectorOffset + byteOffset, writeData);

        } else {
            /* FAT32 */
            const entryOffset = fatOffset + cluster * 4;
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;

            const writeData = new Uint8Array(4);
            new DataView(writeData.buffer).setUint32(0, value & 0x0FFFFFFF, true);
            this.sparseImage.write(sectorOffset + byteOffset, writeData);
        }
    }
}




class SpiffsParser {
    constructor(sparseImage, startOffset, size) {
        if (!sparseImage) {
            throw new Error('SpiffsParser requires a SparseImage');
        }
        this.sparseImage = sparseImage;
        this.startOffset = startOffset;
        this.size = size;
        this.buffer = SparseImage._createProxy(sparseImage);
        this.view = sparseImage.createDataView();
        this.spiffsInfo = null;
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    async initialize() {
        this.spiffsInfo = await this.parse();
        return this.spiffsInfo;
    }

    async parse() {
        const offset = this.startOffset;
        const size = this.size;

        this.logDebug(`[SPIFFS] Parsing partition at offset 0x${offset.toString(16)}, size ${size} bytes`);

        const defaultBlockSize = 4096;
        const headerData = await this.buffer.slice_async(offset, offset + Math.min(defaultBlockSize, size));
        const view = new DataView(headerData.buffer, headerData.byteOffset);

        let magic = 0;
        let pageSize = 256;
        let blockSizeActual = 4096;
        let validHeader = false;

        this.logDebug(`[SPIFFS] Scanning for magic number...`);
        for (let i = 0; i < Math.min(512, headerData.length - 4); i += 4) {
            try {
                const testMagic = view.getUint32(i, true);
                if (testMagic === 0x20160902) {
                    magic = testMagic;
                    validHeader = true;
                    this.logDebug(`[SPIFFS] Found magic at offset 0x${i.toString(16)}`);
                    if (i + 16 <= headerData.length) {
                        const cfgPhysSize = view.getUint32(i + 4, true);
                        const cfgLogBlockSize = view.getUint32(i + 8, true);
                        const cfgLogPageSize = view.getUint32(i + 12, true);
                        this.logDebug(`[SPIFFS] Config: phys=${cfgPhysSize}, blockSize=${cfgLogBlockSize}, pageSize=${cfgLogPageSize}`);
                        if (cfgLogBlockSize > 0 && cfgLogBlockSize <= 65536 &&
                            cfgLogPageSize > 0 && cfgLogPageSize <= 2048) {
                            blockSizeActual = cfgLogBlockSize;
                            pageSize = cfgLogPageSize;
                        }
                    }
                    break;
                }
            } catch (e) {
                continue;
            }
        }

        if (!validHeader) {
            this.logDebug(`[SPIFFS] No magic found, trying pattern detection...`);
            validHeader = await this.detectByPattern(headerData);
            this.logDebug(`[SPIFFS] Pattern detection result: ${validHeader}`);
        }

        const files = [];
        const pagesPerBlock = Math.floor(blockSizeActual / pageSize);
        this.logDebug(`[SPIFFS] Config: blockSize=${blockSizeActual}, pageSize=${pageSize}, pagesPerBlock=${pagesPerBlock}`);
        this.logDebug(`[SPIFFS] Scanning ${Math.floor(size / blockSizeActual)} blocks...`);

        for (let blockIdx = 0; blockIdx < Math.floor(size / blockSizeActual); blockIdx++) {
            const blockOffset = offset + blockIdx * blockSizeActual;
            this.logDebug(`[SPIFFS] ===== Block ${blockIdx}: offset 0x${blockOffset.toString(16)} =====`);
            const blockData = await this.buffer.slice_async(blockOffset, blockOffset + Math.min(blockSizeActual, size - blockIdx * blockSizeActual));

            for (let pageIdx = 0; pageIdx < pagesPerBlock; pageIdx++) {
                const pageStart = pageIdx * pageSize;
                if (pageStart + pageSize > blockData.length) break;

                const objId = blockData[pageStart] | (blockData[pageStart + 1] << 8);
                const span = blockData[pageStart + 2] | (blockData[pageStart + 3] << 8);
                const flags = blockData[pageStart + 4];

                if (objId === 0xFFFF || objId === 0x0000) continue;

                let fileSize = 0;
                let type = 0;
                let nameStr = '[NO NAME]';
                const isIndexHeader = (span === 0);

                if (isIndexHeader) {
                    if (pageStart + 12 <= blockData.length) {
                        fileSize = (blockData[pageStart + 8] |
                            (blockData[pageStart + 9] << 8) |
                            (blockData[pageStart + 10] << 16) |
                            (blockData[pageStart + 11] << 24)) >>> 0;
                    }
                    type = blockData[pageStart + 12];
                    const nameStartIdx = pageStart + 13;
                    if (nameStartIdx < blockData.length) {
                        let nameBytes = [];
                        for (let i = nameStartIdx; i < Math.min(nameStartIdx + 256, pageStart + pageSize); i++) {
                            if (blockData[i] === 0 || blockData[i] === 0xFF) break;
                            if (blockData[i] >= 32 && blockData[i] < 127) nameBytes.push(blockData[i]); else break;
                        }
                        if (nameBytes.length > 0) nameStr = String.fromCharCode(...nameBytes);
                    }
                }

                const isDeleted = (flags & 0x80) === 0;
                this.logDebug(`[SPIFFS] ===== Page at Block ${blockIdx}, Page ${pageIdx} (offset 0x${pageStart.toString(16)}) =====`);
                this.logDebug(`[SPIFFS]   Offset 0-1: obj_id = 0x${objId.toString(16).padStart(4, '0')}`);
                this.logDebug(`[SPIFFS]   Offset 2-3: span_ix = ${span} (0x${span.toString(16).padStart(4, '0')})`);
                this.logDebug(`[SPIFFS]   Offset 4:   flags = 0x${flags.toString(16).padStart(2, '0')} ${isDeleted ? '[DELETED]' : '[VALID]'}`);

                if (isIndexHeader) {
                    const sizeIsUndefined = fileSize === 0xFFFFFFFF;
                    const sizeLog = sizeIsUndefined ? 'undefined (0xFFFFFFFF)' : `${fileSize} bytes (0x${fileSize.toString(16)})`;
                    this.logDebug(`[SPIFFS]   Offset 8-11: size = ${sizeLog}`);
                    this.logDebug(`[SPIFFS]   Offset 12:   type = ${type} (${type === 0x01 ? 'FILE' : type === 0x02 ? 'DIR' : 'UNKNOWN'})`);
                    this.logDebug(`[SPIFFS]   Offset 13+:  name = "${nameStr}"`);

                    if ((type === 0x01 || type === 0x02) && nameStr !== '[NO NAME]' && nameStr.startsWith('/')) {
                        const displayName = isDeleted ? `${nameStr} (deleted)` : nameStr;
                        files.push({
                            name: displayName,
                            objId: objId,
                            size: fileSize > 0 && fileSize < 0xFFFFFFFF ? fileSize : 0,
                            blockIdx: blockIdx,
                            pageIdx: pageIdx,
                            type: type,
                            span: span,
                            flags: flags,
                            deleted: isDeleted
                        });
                        this.logDebug(`[SPIFFS] âœ“ Added to file list: "${displayName}" (deleted=${isDeleted})`);
                    } else {
                        this.logDebug(`[SPIFFS] âŠ˜ Skipped: not a valid file (type=${type}, name="${nameStr}")`);
                    }
                } else {
                    this.logDebug(`[SPIFFS]   (Data page, span_ix=${span})`);
                }
            }
        }

        this.logDebug(`[SPIFFS] Parsing complete. Found ${files.length} files.`);
        return {
            valid: validHeader || files.length > 0,
            magic: magic,
            blockSize: blockSizeActual,
            pageSize: pageSize,
            totalSize: size,
            files: files,
            filesCount: files.length
        };
    }

    async detectByPattern(data) {
        let foundPattern = false;
        for (let i = 0; i < Math.min(2048, data.length - 64); i += 256) {
            const b0 = data[i];
            const b1 = data[i + 1];
            const flags = data[i + 2];
            const objId = b0 | (b1 << 8);
            if (objId !== 0xFFFF && objId !== 0x0000 && flags !== 0xFF) {
                for (let j = i + 12; j < i + 64 && j < data.length; j++) {
                    if (data[j] === 0x2F) {
                        this.logDebug(`[SPIFFS] Pattern detected at offset 0x${i.toString(16)}: objId=0x${objId.toString(16)}, flags=0x${flags.toString(16)}`);
                        foundPattern = true;
                        break;
                    }
                }
                if (foundPattern) break;
            }
        }
        return foundPattern;
    }

    async readFile(file) {
        const offset = this.startOffset;
        const blockSize = this.spiffsInfo.blockSize;
        const pageSize = this.spiffsInfo.pageSize;
        const pagesPerBlock = Math.floor(blockSize / pageSize);
        const fileSize = file.size >>> 0;

        this.logDebug(`[SPIFFS] ========== Reading file "${file.name}" ==========`);
        this.logDebug(`[SPIFFS] objId(header)=0x${file.objId.toString(16)}, size=${fileSize} bytes`);
        this.logDebug(`[SPIFFS] Header page: block=${file.blockIdx}, page=${file.pageIdx}`);

        if (!fileSize) {
            this.logDebug(`[SPIFFS] File size is 0, returning empty array`);
            return new Uint8Array(0);
        }

        const IX_FLAG_MASK = 0x8000;
        const dataObjId = (file.objId & ~IX_FLAG_MASK) & 0xFFFF;

        const totalBlocks = Math.floor(this.spiffsInfo.totalSize / blockSize) || Math.floor(this.size / blockSize);
        const dataHeaderLen = 5;
        const dataPerPage = pageSize - dataHeaderLen;

        const spixToAddr = new Map();
        let pagesFound = 0;
        this.logDebug(`[SPIFFS] Scanning for data pages: target obj_id=0x${dataObjId.toString(16)}`);

        for (let blk = 0; blk < totalBlocks; blk++) {
            const blockBase = offset + blk * blockSize;
            const blockData = await this.buffer.slice_async(blockBase, blockBase + blockSize);
            for (let pg = 0; pg < pagesPerBlock; pg++) {
                const pageOffInBlock = pg * pageSize;
                if (pageOffInBlock + dataHeaderLen > blockData.length) break;
                const objId = blockData[pageOffInBlock] | (blockData[pageOffInBlock + 1] << 8);
                const span = blockData[pageOffInBlock + 2] | (blockData[pageOffInBlock + 3] << 8);
                const flags = blockData[pageOffInBlock + 4];
                if (objId === 0xFFFF || objId === 0x0000) continue;
                const isDeleted = (flags & 0x80) === 0;
                if (isDeleted) continue;
                if (objId === dataObjId) {
                    const paddr = blockBase + pageOffInBlock;
                    if (!spixToAddr.has(span)) {
                        spixToAddr.set(span, paddr);
                        pagesFound++;
                        if (pagesFound <= 8) {
                            this.logDebug(`[SPIFFS]   Data page: blk=${blk}, pg=${pg}, span_ix=${span}, paddr=0x${paddr.toString(16)}`);
                        }
                    }
                }
            }
        }

        this.logDebug(`[SPIFFS] Found ${pagesFound} data pages for obj_id=0x${dataObjId.toString(16)} (data_per_page=${dataPerPage})`);
        if (pagesFound === 0) {
            const headerOffset = offset + file.blockIdx * blockSize + file.pageIdx * pageSize;
            const naiveContent = headerOffset + pageSize;
            console.warn(`[SPIFFS] WARNING: No data pages found via scan. Falling back to next-page heuristic at 0x${naiveContent.toString(16)}`);
            const fileData = await this.buffer.slice_async(naiveContent, naiveContent + fileSize);
            this.logDebug(`[SPIFFS] Fallback read first 32 bytes: ${Array.from(fileData.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
            return fileData;
        }

        const out = new Uint8Array(fileSize);
        let curOff = 0;
        let logPreview = [];
        while (curOff < fileSize) {
            const spix = Math.floor(curOff / dataPerPage);
            const pageOff = curOff % dataPerPage;
            const lenToRead = Math.min(fileSize - curOff, dataPerPage - pageOff);
            if (!spixToAddr.has(spix)) {
                console.warn(`[SPIFFS] Missing data page for span_ix=${spix}, filling with 0xFF for ${lenToRead} bytes`);
                out.fill(0xFF, curOff, curOff + lenToRead);
                curOff += lenToRead;
                continue;
            }
            const paddr = spixToAddr.get(spix);
            const dataStart = paddr + dataHeaderLen + pageOff;
            const dataEnd = dataStart + lenToRead;
            const chunk = await this.buffer.slice_async(dataStart, dataEnd);
            out.set(chunk, curOff);
            if (logPreview.length < 4) {
                logPreview.push({ spix, paddr: dataStart, len: lenToRead });
            }
            curOff += lenToRead;
        }

        this.logDebug(`[SPIFFS] Read complete: ${out.length} bytes`);
        if (logPreview.length) {
            for (const e of logPreview) {
                this.logDebug(`[SPIFFS]   Read spix=${e.spix} at 0x${e.paddr.toString(16)} len=${e.len}`);
            }
        }
        this.logDebug(`[SPIFFS] First 32 bytes (hex): ${Array.from(out.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
        return out;
    }
}

class OTADataParser {
    constructor(sparseImage, offset, length) {
        if (!sparseImage) {
            throw new Error('OTADataParser requires a SparseImage');
        }
        if (offset === undefined || length === undefined) {
            throw new Error('OTADataParser requires offset and length parameters');
        }
        this.sparseImage = sparseImage;
        this.offset = offset;
        this.length = length;
        this.otaInfo = null;
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };

        // CRC32 lookup table for esp_rom_crc32_le
        this.crc32_le_table = new Uint32Array([
            0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
            0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
            0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
            0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
            0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
            0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
            0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
            0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
            0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
            0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
            0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
            0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
            0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
            0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
            0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
            0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,

            0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
            0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
            0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
            0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
            0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
            0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
            0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
            0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
            0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
            0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
            0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
            0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
            0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
            0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
            0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
            0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
        ]);
    }


    async initialize() {
        const OTA_DATA_SIZE = 0x1000;  // 4096 bytes (one sector)
        const data = await this.sparseImage.subarray_async(this.offset, this.offset + (OTA_DATA_SIZE * 2));

        // ESP32 IDF uses two sectors to store information about which partition is running
        // They are defined as the OTA data partition, two esp_ota_select_entry_t structures
        // are saved in the two sectors, named otadata[0] (first sector) and otadata[1] (second sector)
        // 
        // If otadata[0].ota_seq == otadata[1].ota_seq == 0xFFFFFFFF, OTA info partition is in init status
        // So it will boot factory application (if there is), otherwise boot ota[0]
        // 
        // If both ota_seq != 0, it will choose max seq, and calculate (max_seq - 1) % max_ota_app_number
        // to determine which OTA partition to boot (subtype mask 0x0F)

        // OTA image states
        const ESP_OTA_IMG_NEW = 0x0;
        const ESP_OTA_IMG_PENDING_VERIFY = 0x1;
        const ESP_OTA_IMG_VALID = 0x2;
        const ESP_OTA_IMG_INVALID = 0x3;
        const ESP_OTA_IMG_ABORTED = 0x4;
        const ESP_OTA_IMG_UNDEFINED = 0xFFFFFFFF;

        const entries = [];
        for (let i = 0; i < 2; i++) {
            const offset = i * OTA_DATA_SIZE;
            const view = new DataView(data.buffer, data.byteOffset + offset, OTA_DATA_SIZE);

            const seq = view.getUint32(0, true);
            const otaState = view.getUint32(24, true);  // Read as uint32
            const crc = view.getUint32(28, true);

            // CRC32 is calculated over first 4 bytes (sequence number) using esp_rom_crc32_le(UINT32_MAX, &ota_seq, 4)
            const dataForCRC = new Uint8Array(data.buffer, data.byteOffset + offset, 4);
            const calculatedCRC = this.calculateCRC32(dataForCRC);
            const crcValid = crc === calculatedCRC;

            // Entry is invalid if: seq == 0xFFFFFFFF OR ota_state == INVALID OR ota_state == ABORTED
            const isInvalid = seq === 0xFFFFFFFF || otaState === ESP_OTA_IMG_INVALID || otaState === ESP_OTA_IMG_ABORTED;

            // Entry is valid if: NOT invalid AND CRC matches
            const isValid = !isInvalid && crcValid;

            entries.push({
                index: i,
                sequence: seq,
                otaState: otaState,
                otaStateName: this.getOTAStateName(otaState),
                crc: crc,
                calculatedCRC: calculatedCRC,
                crcValid: crcValid,
                isValid: isValid,
                isEmpty: seq === 0xFFFFFFFF
            });
        }

        // Determine which entry is active using bootloader_common_get_active_otadata logic
        // Both must be valid, then choose highest sequence
        let activeEntry = null;
        if (entries[0].isValid && entries[1].isValid) {
            activeEntry = entries[0].sequence > entries[1].sequence ? 0 : 1;
        } else if (entries[0].isValid) {
            activeEntry = 0;
        } else if (entries[1].isValid) {
            activeEntry = 1;
        }

        this.otaInfo = {
            entries: entries,
            activeEntry: activeEntry
        };

        return this.otaInfo;
    }

    getOTAStateName(state) {
        const states = {
            0x0: 'NEW',
            0x1: 'PENDING_VERIFY',
            0x2: 'VALID',
            0x3: 'INVALID',
            0x4: 'ABORTED',
            0xFFFFFFFF: 'UNDEFINED'
        };
        return states[state] || `Unknown (0x${state.toString(16)})`;
    }

    // CRC32 using esp_rom_crc32_le() algorithm with lookup table
    // Matches ROM implementation: esp_rom_crc32_le(UINT32_MAX, &ota_seq, 4)
    calculateCRC32(data) {
        let crc = 0;  // Input 0xFFFFFFFF gets inverted to 0
        for (let i = 0; i < data.length; i++) {
            crc = this.crc32_le_table[(crc ^ data[i]) & 0xff] ^ (crc >>> 8);
        }
        return (~crc) >>> 0;  // Invert and return
    }
}

class NVSParser {
    constructor(sparseImage, startOffset, size) {
        if (!sparseImage) {
            throw new Error('NVSParser requires a SparseImage');
        }
        this.sparseImage = sparseImage;
        this.startOffset = startOffset;
        this.size = size;
        this.buffer = SparseImage._createProxy(sparseImage);
        this.view = sparseImage.createDataView();
        this.pages = null;
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    async initialize() {
        this.pages = await this.parse();
        return this.pages;
    }

    static bytesToHex(bytes, separator = '') {
        return Array.from(bytes)
            .map(b => b.toString(16).padStart(2, '0').toUpperCase())
            .join(separator);
    }

    static crc32Byte(crc, d) {
        for (let i = 0; i < 8; i++) {
            const bit = d & 1;
            crc ^= bit;
            crc = (crc & 1) ? (crc >>> 1) ^ 0xEDB88320 : crc >>> 1;
            d >>>= 1;
        }
        return crc >>> 0;
    }

    static crc32(data, offset = 0, length = null) {
        let crc = 0;
        const len = length ?? data.length - offset;
        for (let i = 0; i < len; i++) {
            crc = NVSParser.crc32Byte(crc, data[offset + i]);
        }
        return (~crc) >>> 0;
    }

    static crc32Header(data, offset = 0) {
        const buf = new Uint8Array(0x20 - 4);
        buf.set(data.subarray(offset, offset + 4), 0);
        buf.set(data.subarray(offset + 8, offset + 8 + 0x18), 4);
        return NVSParser.crc32(buf, 0, 0x1C);
    }

    async readString(offset, maxLength) {
        let result = '';
        for (let i = 0; i < maxLength; i++) {
            const byte = await this.view.getUint8(offset + i);
            if (byte === 0) break;
            if (byte >= 32 && byte <= 126) {
                result += String.fromCharCode(byte);
            } else if (byte !== 0) {
                return result;
            }
        }
        return result;
    }

    getNVSTypeName(datatype) {
        const types = {
            0x01: 'U8',
            0x02: 'U16',
            0x04: 'U32',
            0x08: 'U64',
            0x11: 'I8',
            0x12: 'I16',
            0x14: 'I32',
            0x18: 'I64',
            0x21: 'String',
            0x42: 'Blob',
            0x48: 'Blob Index'
        };
        return types[datatype] || `Unknown (0x${datatype.toString(16)})`;
    }

    getNVSItemState(stateBitmap, index) {
        const bmpIdx = Math.floor(index / 4);
        const bmpBit = (index % 4) * 2;
        return (stateBitmap[bmpIdx] >> bmpBit) & 3;
    }

    setNVSItemState(stateBitmap, index, state) {
        const bmpIdx = Math.floor(index / 4);
        const bmpBit = (index % 4) * 2;
        stateBitmap[bmpIdx] &= ~(3 << bmpBit);
        stateBitmap[bmpIdx] |= (state << bmpBit);
    }

    async parseItem(offset, namespaces) {
        if (offset + 32 > this.sparseImage.size) {
            return null;
        }

        const nsIndex = await this.view.getUint8(offset);
        const datatype = await this.view.getUint8(offset + 1);
        const span = await this.view.getUint8(offset + 2);
        const chunkIndex = await this.view.getUint8(offset + 3);
        const crc32 = await this.view.getUint32(offset + 4, true);
        const key = await this.readString(offset + 8, 16);

        if (span === 0 || span > 126) {
            console.warn(`Invalid span ${span} at offset ${offset}`);
            return null;
        }

        if (nsIndex !== 0 && (!key || key.length === 0)) {
            return null;
        }

        if (nsIndex !== 0) {
            for (let i = 0; i < key.length; i++) {
                const code = key.charCodeAt(i);
                if (code < 32 || code > 126) {
                    return null;
                }
            }
        }

        if (datatype === 0xFF || datatype === 0x00) {
            return null;
        }

        if (nsIndex === 0xFF) {
            return null;
        }

        const headerCrcCalc = NVSParser.crc32Header(this.buffer, offset);

        const item = {
            nsIndex: nsIndex,
            datatype: datatype,
            span: span,
            chunkIndex: chunkIndex,
            crc32: crc32 >>> 0,
            headerCrcCalc: headerCrcCalc >>> 0,
            headerCrcValid: (crc32 >>> 0) === (headerCrcCalc >>> 0),
            key: key,
            value: null,
            typeName: this.getNVSTypeName(datatype),
            isBlobChunk: false,
            offset: offset - this.startOffset,
            entrySize: 32
        };

        if (nsIndex === 0) {
            const namespaceIndex = await this.view.getUint8(offset + 24);
            item.value = namespaceIndex;
            item.namespace = key;
        } else {
            switch (datatype) {
                case 0x01:
                    item.value = await this.view.getUint8(offset + 24);
                    break;
                case 0x02:
                    item.value = await this.view.getUint16(offset + 24, true);
                    break;
                case 0x04:
                    item.value = await this.view.getUint32(offset + 24, true);
                    break;
                case 0x08:
                    item.value = (await this.view.getBigUint64(offset + 24, true)).toString();
                    break;
                case 0x11:
                    item.value = await this.view.getInt8(offset + 24);
                    break;
                case 0x12:
                    item.value = await this.view.getInt16(offset + 24, true);
                    break;
                case 0x14:
                    item.value = await this.view.getInt32(offset + 24, true);
                    break;
                case 0x18:
                    item.value = (await this.view.getBigInt64(offset + 24, true)).toString();
                    break;
                case 0x21: {
                    const strSize = await this.view.getUint16(offset + 24, true);
                    const strCrc = (await this.view.getUint32(offset + 28, true)) >>> 0;
                    if (strSize > 0 && strSize < 4096 && offset + 32 + strSize <= this.sparseImage.size) {
                        const strData = new Uint8Array(strSize);
                        for (let i = 0; i < strSize; i++) {
                            strData[i] = await this.view.getUint8(offset + 32 + i);
                        }
                        const allErased = strData.every(b => b === 0xFF);
                        let strValue = '';
                        for (let i = 0; i < strData.length; i++) {
                            if (strData[i] === 0) break;
                            if (strData[i] >= 32 && strData[i] <= 126) {
                                strValue += String.fromCharCode(strData[i]);
                            }
                        }
                        item.value = allErased ? '<erased>' : strValue;
                        item.rawValue = strData;
                        const dataCrcCalc = NVSParser.crc32(strData, 0, strSize);
                        item.dataCrcStored = strCrc >>> 0;
                        item.dataCrcCalc = dataCrcCalc >>> 0;
                        item.dataCrcValid = (dataCrcCalc >>> 0) === (strCrc >>> 0);
                        item.size = strSize;
                        item.entrySize = 32 + strSize;
                    } else {
                        item.value = '<invalid string>';
                        item.size = 0;
                    }
                    break;
                }
                case 0x42: {
                    const blobSize = await this.view.getUint16(offset + 24, true);
                    const blobCrc = (await this.view.getUint32(offset + 28, true)) >>> 0;
                    if (chunkIndex !== 0xFF) {
                        item.chunkIndex = chunkIndex;
                    }
                    if (blobSize > 0 && blobSize < 4096 && offset + 32 + blobSize <= this.sparseImage.size) {
                        const blobData = new Uint8Array(blobSize);
                        for (let i = 0; i < blobSize; i++) {
                            blobData[i] = await this.view.getUint8(offset + 32 + i);
                        }
                        const allErased = blobData.every(b => b === 0xFF);
                        item.value = allErased ? '<erased>' : NVSParser.bytesToHex(blobData, ' ');
                        item.rawValue = blobData;
                        const dataCrcCalc = NVSParser.crc32(blobData, 0, blobSize);
                        item.dataCrcStored = blobCrc >>> 0;
                        item.dataCrcCalc = dataCrcCalc >>> 0;
                        item.dataCrcValid = (dataCrcCalc >>> 0) === (blobCrc >>> 0);
                        item.size = blobSize;
                        item.entrySize = 32 + blobSize;
                    } else {
                        item.value = '<invalid blob>';
                        item.size = 0;
                    }
                    break;
                }
                case 0x48:
                    item.totalSize = await this.view.getUint32(offset + 24, true);
                    item.chunkCount = await this.view.getUint8(offset + 28);
                    item.chunkStart = await this.view.getUint8(offset + 29);
                    item.isBlobIndex = true;
                    item.value = `${item.chunkCount} chunks, ${item.totalSize} bytes total`;
                    break;
            }
        }

        return item;
    }

    async parse() {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;
        const NVS_PAGE_STATE = {
            UNINIT: 0xFFFFFFFF,
            ACTIVE: 0xFFFFFFFE,
            FULL: 0xFFFFFFFC,
            FREEING: 0xFFFFFFF8,
            CORRUPT: 0xFFFFFFF0
        };

        const pages = [];
        const namespaces = new Map();
        namespaces.set(0, '');

        //this.logDebug(`[NVS Parse] Starting NVS parse for partition at offset 0x${this.startOffset.toString(16)}, length 0x${this.size.toString(16)}`);

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;

            const state = await this.view.getUint32(blockOffset, true);
            const seq = await this.view.getUint32(blockOffset + 4, true);
            const version = await this.view.getUint8(blockOffset + 8);
            const crc32 = await this.view.getUint32(blockOffset + 28, true);

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);
            }

            let stateName = 'UNKNOWN';
            if (state === NVS_PAGE_STATE.UNINIT) {
                stateName = 'UNINIT';
                //this.logDebug(`[NVS Parse] Page at 0x${blockOffset.toString(16)}: UNINIT, skipping`);
                continue;
            } else if (state === NVS_PAGE_STATE.ACTIVE) {
                stateName = 'ACTIVE';
            } else if (state === NVS_PAGE_STATE.FULL) {
                stateName = 'FULL';
            } else if (state === NVS_PAGE_STATE.FREEING) {
                stateName = 'FREEING';
            } else if (state === NVS_PAGE_STATE.CORRUPT) {
                stateName = 'CORRUPT';
                //this.logDebug(`[NVS Parse] Page at 0x${blockOffset.toString(16)}: CORRUPT, skipping`);
                continue;
            }

            //this.logDebug(`[NVS Parse] Page at 0x${blockOffset.toString(16)}: state=${stateName}, seq=${seq}, version=${version}`);

            const page = {
                offset: blockOffset,
                state: stateName,
                seq: seq,
                version: version,
                crc32: crc32,
                items: []
            };

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                //this.logDebug(`[NVS Parse]   Entry ${entry}: state=${itemState} (0=ERASED, 2=WRITTEN, 3=EMPTY)`);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const nsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);

                //this.logDebug(`[NVS Parse]     nsIndex=${nsIndex}, datatype=0x${datatype.toString(16)}, span=${span}`);

                if (span === 0 || span > 126) {
                    console.warn(`[NVS Parse]     Invalid span ${span} at offset ${entryOffset}, skipping`);
                    continue;
                }

                if (nsIndex === 0 && datatype !== 0xFF && datatype !== 0x00) {
                    const key = await this.readString(entryOffset + 8, 16);
                    const namespaceIndex = await this.view.getUint8(entryOffset + 24);
                    //this.logDebug(`[NVS Parse]     Namespace definition: "${key}" -> index ${namespaceIndex}`);
                    if (key && namespaceIndex < 255) {
                        namespaces.set(namespaceIndex, key);
                    }
                }

                const item = await this.parseItem(entryOffset, namespaces);
                if (item) {
                    //this.logDebug(`[NVS Parse]     Parsed item: nsIndex=${item.nsIndex}, key="${item.key}", type=${item.typeName}, value=${JSON.stringify(item.value)}`);
                    page.items.push(item);
                    if (item.span > 1) {
                        entry += item.span - 1;
                    }
                } else {
                    this.logDebug(`[NVS Parse]     Item parsing returned null, skipping`);
                }
            }

            if (page.items.length > 0) {
                //this.logDebug(`[NVS Parse] Page added with ${page.items.length} items`);
                pages.push(page);
            } else {
                //this.logDebug(`[NVS Parse] Page has no items, not added`);
            }
        }

        for (const page of pages) {
            for (const item of page.items) {
                if (item.nsIndex !== undefined && item.nsIndex !== 0) {
                    item.namespace = namespaces.get(item.nsIndex) || `ns_${item.nsIndex}`;
                }
            }
        }

        //this.logDebug(`[NVS Parse] Parse complete: ${pages.length} pages, ${pages.reduce((sum, p) => sum + p.items.length, 0)} total items`);
        return pages;
    }

    /**
     * Build a map of namespace names to their indices
     * Returns: { name: index, ... }
     */
    async buildNamespaceMap() {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;
        const namespaceMap = {};

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);

                if (itemNsIndex === 0 && datatype !== 0xFF && datatype !== 0x00) {
                    const itemKey = await this.readString(entryOffset + 8, 16);
                    const namespaceIndex = await this.view.getUint8(entryOffset + 24);
                    if (itemKey && namespaceIndex < 255) {
                        namespaceMap[itemKey] = namespaceIndex;
                    }
                }

                entry += span - 1;
            }
        }

        return namespaceMap;
    }

    /**
     * Add a new namespace entry to NVS
     */
    async addNamespace(namespaceName) {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;

        let maxNsIndex = 0;
        const usedIndices = new Set();

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;

            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);
            }

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);
                const itemKey = await this.readString(entryOffset + 8, 16);

                if (itemNsIndex === 0 && datatype !== 0xFF && datatype !== 0x00) {
                    const existingIndex = await this.view.getUint8(entryOffset + 24);
                    usedIndices.add(existingIndex);
                    if (existingIndex > maxNsIndex) maxNsIndex = existingIndex;

                    if (itemKey === namespaceName) {
                        throw new Error(`Namespace "${namespaceName}" already exists with index ${existingIndex}`);
                    }
                }

                entry += span - 1;
            }
        }

        let newNsIndex = 1;
        while (usedIndices.has(newNsIndex) && newNsIndex < 255) newNsIndex++;
        if (newNsIndex >= 255) throw new Error('No available namespace indices (max 254 namespaces)');

        this.logDebug(`[NVS AddNamespace] Creating namespace "${namespaceName}" with index ${newNsIndex}`);

        const entry = new Uint8Array(32);
        entry[0] = 0;
        entry[1] = 0x01;
        entry[2] = 1;
        entry[3] = 0xFF;

        const keyBytes = new TextEncoder().encode(namespaceName);
        for (let i = 0; i < Math.min(keyBytes.length, 15); i++) entry[8 + i] = keyBytes[i];
        entry[8 + Math.min(keyBytes.length, 15)] = 0;
        entry[24] = newNsIndex;

        const headerCrc = NVSParser.crc32Header(entry);
        new DataView(entry.buffer).setUint32(4, headerCrc, true);

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;
            if (state !== 0xFFFFFFFE && state !== 0xFFFFFFFC) continue;

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

            for (let entryIdx = 0; entryIdx < MAX_ENTRY_COUNT; entryIdx++) {
                const itemState = this.getNVSItemState(stateBitmap, entryIdx);
                if (itemState === 3 || itemState === 0) {
                    const entryOffset = blockOffset + 64 + entryIdx * 32;
                    this.logDebug(`[NVS AddNamespace] Writing namespace definition at entry ${entryIdx}, offset 0x${entryOffset.toString(16)}`);
                    this.sparseImage.write(entryOffset, entry);
                    this.setNVSItemState(stateBitmap, entryIdx, 2);
                    this.sparseImage.write(blockOffset + 32, stateBitmap);
                    this.logDebug(`[NVS AddNamespace] Successfully added namespace "${namespaceName}" with index ${newNsIndex}`);
                    return;
                }
            }
        }

        throw new Error('No space available in NVS partition for namespace definition');
    }

    /**
     * Delete an item by namespace + key, and also delete the vice versa entry (Blob <-> BlobIndex)
     */
    async deleteItem(namespace, key) {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;
        const BLOB_TYPE = 0x42;
        const BLOB_INDEX_TYPE = 0x48;

        this.logDebug(`[NVS Delete] Starting delete for ${namespace}.${key}`);

        /* Build namespace map first */
        const namespaceMap = await this.buildNamespaceMap();
        this.logDebug(`[NVS Delete] Namespace map:`, namespaceMap);

        const nsIndex = namespaceMap[namespace];
        if (nsIndex === undefined) {
            this.logDebug(`[NVS Delete] Namespace "${namespace}" not found in map`);
            throw new Error(`NVS namespace ${namespace} not found`);
        }
        this.logDebug(`[NVS Delete] Target namespace "${namespace}" has index ${nsIndex}`);

        let foundItemType = null;

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

            const stateName =
                state === 0xFFFFFFFF ? 'UNINIT' :
                    state === 0xFFFFFFFE ? 'ACTIVE' :
                        state === 0xFFFFFFFC ? 'FULL' :
                            state === 0xFFFFFFF8 ? 'FREEING' :
                                state === 0xFFFFFFF0 ? 'CORRUPT' : `UNKNOWN(0x${state.toString(16)})`;
            this.logDebug(`[NVS Delete] Scanning page at 0x${blockOffset.toString(16)} state=${stateName}`);

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);
                const itemKey = await this.readString(entryOffset + 8, 16);

                this.logDebug(`[NVS Delete]   Entry ${entry}: ns=${itemNsIndex}, type=0x${datatype.toString(16)}, span=${span}, key="${itemKey}"`);

                /* Skip namespace definitions */
                if (itemNsIndex === 0) {
                    entry += span - 1;
                    continue;
                }

                if (itemNsIndex === nsIndex && itemKey === key) {
                    foundItemType = datatype;
                    this.logDebug(`[NVS Delete]   Found target item at entry ${entry}, offset 0x${entryOffset.toString(16)}, span=${span}. Erasing...`);
                    for (let slice = 0; slice < span; slice++) {
                        const sliceOffset = entryOffset + slice * 32;
                        const erasedEntry = new Uint8Array(32);
                        erasedEntry.fill(0xFF);
                        this.sparseImage.write(sliceOffset, erasedEntry);
                        this.setNVSItemState(stateBitmap, entry + slice, 3);
                    }
                    this.sparseImage.write(blockOffset + 32, stateBitmap);
                    this.logDebug(`[NVS Delete]   Erase complete and state bitmap updated for page at 0x${blockOffset.toString(16)}`);
                    break;
                }

                entry += span - 1;
            }

            if (foundItemType !== null) break;
        }

        if (foundItemType === null) {
            this.logDebug(`[NVS Delete] Item ${namespace}.${key} not found (nsIndex=${nsIndex})`);
            throw new Error(`NVS item ${namespace}.${key} not found`);
        }

        /* If deleting a Blob (0x42), also delete the BlobIndex (0x48) */
        /* If deleting a BlobIndex (0x48), also delete the Blob chunks (0x42) */
        if (foundItemType === BLOB_TYPE || foundItemType === BLOB_INDEX_TYPE) {
            const complementaryType = (foundItemType === BLOB_TYPE) ? BLOB_INDEX_TYPE : BLOB_TYPE;
            this.logDebug(`[NVS Delete] Item is a Blob${foundItemType === BLOB_TYPE ? 'Index' : ''}, searching for complementary ${complementaryType === BLOB_TYPE ? 'Blob' : 'BlobIndex'} entry...`);

            for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
                const blockOffset = this.startOffset + sectorOffset;
                if (blockOffset + 64 > this.sparseImage.size) break;
                const state = await this.view.getUint32(blockOffset, true);
                if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

                const stateBitmap = new Uint8Array(32);
                for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

                for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                    const itemState = this.getNVSItemState(stateBitmap, entry);
                    if (itemState !== 2) continue;

                    const entryOffset = blockOffset + 64 + entry * 32;
                    if (entryOffset + 32 > this.sparseImage.size) break;

                    const itemNsIndex = await this.view.getUint8(entryOffset);
                    const datatype = await this.view.getUint8(entryOffset + 1);
                    const span = await this.view.getUint8(entryOffset + 2);
                    const itemKey = await this.readString(entryOffset + 8, 16);

                    /* Skip if not the complementary type or wrong namespace/key */
                    if (datatype !== complementaryType || itemNsIndex !== nsIndex || itemKey !== key) {
                        entry += span - 1;
                        continue;
                    }

                    this.logDebug(`[NVS Delete]   Found complementary ${complementaryType === BLOB_TYPE ? 'Blob' : 'BlobIndex'} entry at entry ${entry}, offset 0x${entryOffset.toString(16)}, span=${span}. Erasing...`);
                    for (let slice = 0; slice < span; slice++) {
                        const sliceOffset = entryOffset + slice * 32;
                        const erasedEntry = new Uint8Array(32);
                        erasedEntry.fill(0xFF);
                        this.sparseImage.write(sliceOffset, erasedEntry);
                        this.setNVSItemState(stateBitmap, entry + slice, 3);
                    }
                    this.sparseImage.write(blockOffset + 32, stateBitmap);
                    this.logDebug(`[NVS Delete]   Complementary entry erase complete`);
                    return;
                }
            }

            this.logDebug(`[NVS Delete] No complementary ${complementaryType === BLOB_TYPE ? 'Blob' : 'BlobIndex'} entry found for ${namespace}.${key}`);
        }
    }

    /**
     * Add an item
     */
    async addItem(namespace, key, type, value) {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;

        const item = this.createItem(key, type, value);
        let nsIndex = -1;

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);
                const itemKey = await this.readString(entryOffset + 8, 16);

                if (itemNsIndex === 0 && datatype !== 0xFF && datatype !== 0x00 && itemKey === namespace) {
                    nsIndex = await this.view.getUint8(entryOffset + 24);
                }

                entry += span - 1;
            }

            if (nsIndex !== -1) {
                for (let entry = 0; entry < MAX_ENTRY_COUNT && (entry + item.span - 1 < MAX_ENTRY_COUNT); entry++) {
                    let hasSpace = true;
                    for (let slice = 0; slice < item.span; slice++) {
                        const sliceState = this.getNVSItemState(stateBitmap, entry + slice);
                        if (sliceState === 2) { hasSpace = false; break; }
                    }

                    if (hasSpace) {
                        const entryOffset = blockOffset + 64 + entry * 32;

                        /* Set nsIndex for all entries and calculate header CRC */
                        for (let i = 0; i < item.entries.length; i++) {
                            if (item.entries[i][0] === 0) {
                                item.entries[i][0] = nsIndex;
                                const headerCrc = NVSParser.crc32Header(item.entries[i]);
                                new DataView(item.entries[i].buffer).setUint32(4, headerCrc, true);
                            }
                        }

                        this.logDebug(`[NVS Add] Writing item at entry ${entry}, nsIndex=${nsIndex}, key="${key}", span=${item.span}, entries=${item.entries.length}`);

                        for (let slice = 0; slice < item.entries.length; slice++) {
                            const sliceOffset = entryOffset + slice * 32;
                            this.sparseImage.write(sliceOffset, item.entries[slice]);
                            this.setNVSItemState(stateBitmap, entry + slice, 2);
                        }

                        this.sparseImage.write(blockOffset + 32, stateBitmap);
                        this.logDebug(`[NVS Add] Successfully added item to partition`);
                        return;
                    }

                    const curState = this.getNVSItemState(stateBitmap, entry);
                    if (curState === 2) {
                        const entryOffset = blockOffset + 64 + entry * 32;
                        const entrySpan = await this.view.getUint8(entryOffset + 2);
                        entry += entrySpan - 1;
                    }
                }
            }
        }

        throw new Error(`No space available in NVS partition or namespace ${namespace} not found`);
    }

    /**
     * Create entries for an item
     */
    createItem(key, type, value) {
        const typeMap = {
            'U8': 0x01, 'U16': 0x02, 'U32': 0x04, 'U64': 0x08,
            'I8': 0x11, 'I16': 0x12, 'I32': 0x14, 'I64': 0x18,
            'String': 0x21, 'Blob': 0x42, 'BlobSmall': 0x42
        };

        const datatype = typeMap[type];
        if (!datatype) throw new Error(`Unknown type: ${type}`);

        const entry = new Uint8Array(32);
        entry.fill(0xFF);
        entry[0] = 0; /* nsIndex will be set later */
        entry[1] = datatype;
        entry[3] = 0xFF; /* chunkIndex */

        const keyBytes = new TextEncoder().encode(key.substring(0, 15));
        entry.set(keyBytes, 8);
        entry[8 + keyBytes.length] = 0;

        const entries = [];

        switch (type) {
            case 'U8': {
                const val = parseInt(value);
                if (isNaN(val) || val < 0 || val > 255) throw new Error('Invalid U8 value');
                entry[24] = val;
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'U16': {
                const val = parseInt(value);
                if (isNaN(val) || val < 0 || val > 65535) throw new Error('Invalid U16 value');
                new DataView(entry.buffer).setUint16(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'U32': {
                const val = parseInt(value);
                if (isNaN(val) || val < 0 || val > 4294967295) throw new Error('Invalid U32 value');
                new DataView(entry.buffer).setUint32(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'U64': {
                const val = BigInt(value);
                if (val < 0n || val > 18446744073709551615n) throw new Error('Invalid U64 value');
                new DataView(entry.buffer).setBigUint64(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'I8': {
                const val = parseInt(value);
                if (isNaN(val) || val < -128 || val > 127) throw new Error('Invalid I8 value');
                new DataView(entry.buffer).setInt8(24, val);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'I16': {
                const val = parseInt(value);
                if (isNaN(val) || val < -32768 || val > 32767) throw new Error('Invalid I16 value');
                new DataView(entry.buffer).setInt16(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'I32': {
                const val = parseInt(value);
                if (isNaN(val) || val < -2147483648 || val > 2147483647) throw new Error('Invalid I32 value');
                new DataView(entry.buffer).setInt32(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'I64': {
                const val = BigInt(value);
                if (val < -9223372036854775808n || val > 9223372036854775807n) throw new Error('Invalid I64 value');
                new DataView(entry.buffer).setBigInt64(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'String': {
                const strBytes = new TextEncoder().encode(value);
                if (strBytes.length > 64) throw new Error('String too long (max 64 bytes)');
                new DataView(entry.buffer).setUint16(24, strBytes.length, true);
                const dataCrc = NVSParser.crc32(strBytes);
                new DataView(entry.buffer).setUint32(28, dataCrc, true);
                const span = 1 + Math.ceil(strBytes.length / 32);
                entry[2] = span;
                entries.push(entry);
                const dataEntry = new Uint8Array(32 * (span - 1));
                dataEntry.fill(0xFF);
                dataEntry.set(strBytes, 0);
                for (let i = 0; i < span - 1; i++) entries.push(dataEntry.slice(i * 32, (i + 1) * 32));
                break;
            }
            case 'BlobSmall': {
                const hexBytes = value.split(/\s+/).filter(b => b).map(b => parseInt(b, 16));
                if (hexBytes.some(b => isNaN(b) || b < 0 || b > 255)) throw new Error('Invalid hex bytes');
                if (hexBytes.length > 32) throw new Error('BlobSmall too long (max 32 bytes)');
                const blobData = new Uint8Array(hexBytes);

                /* Small blob: single entry without blob index */
                new DataView(entry.buffer).setUint16(24, blobData.length, true);
                /* Reserved bytes (26-27) must stay 0xFF to match firmware */
                entry[26] = 0xFF;
                entry[27] = 0xFF;
                const dataCrc = NVSParser.crc32(blobData);
                new DataView(entry.buffer).setUint32(28, dataCrc, true);
                const span = 1 + Math.ceil(blobData.length / 32);
                entry[2] = span;
                entry[3] = 0; /* chunkIndex for first chunk */
                entries.push(entry);
                if (span > 1) {
                    const dataEntry = new Uint8Array(32 * (span - 1));
                    dataEntry.fill(0xFF);
                    dataEntry.set(blobData, 0);
                    for (let i = 0; i < span - 1; i++) entries.push(dataEntry.slice(i * 32, (i + 1) * 32));
                }
                break;
            }
            case 'Blob': {
                const hexBytes = value.split(/\s+/).filter(b => b).map(b => parseInt(b, 16));
                if (hexBytes.some(b => isNaN(b) || b < 0 || b > 255)) throw new Error('Invalid hex bytes');
                if (hexBytes.length > 1984) throw new Error('Blob too long (max 1984 bytes)');
                const blobData = new Uint8Array(hexBytes);

                {
                    /* Large blob: write blob chunks first, then blob index (firmware order) */
                    const indexEntry = new Uint8Array(32);
                    indexEntry.fill(0x00);
                    indexEntry[0] = 0; /* nsIndex will be set later */
                    indexEntry[1] = 0x48; /* Blob Index type */
                    indexEntry[2] = 1; /* span */
                    indexEntry[3] = 0xFF; /* chunkIndex */
                    const keyBytes = new TextEncoder().encode(key.substring(0, 15));
                    indexEntry.set(keyBytes, 8);
                    indexEntry[8 + keyBytes.length] = 0;
                    new DataView(indexEntry.buffer).setUint32(24, blobData.length, true); /* totalSize */

                    /* Calculate number of chunks needed */
                    const maxChunkSize = 32 + 31 * 32; /* first entry has 32 bytes, each additional can hold 32 bytes */
                    const chunkCount = Math.ceil(blobData.length / maxChunkSize);
                    indexEntry[28] = chunkCount; /* chunkCount */
                    indexEntry[29] = 0; /* chunkStart */

                    /* Create chunk entries first */
                    let offset = 0;
                    for (let chunkIdx = 0; chunkIdx < chunkCount; chunkIdx++) {
                        const chunkSize = Math.min(maxChunkSize, blobData.length - offset);
                        const chunkData = blobData.slice(offset, offset + chunkSize);

                        const chunkEntry = new Uint8Array(32);
                        chunkEntry.fill(0x00);
                        chunkEntry[0] = 0; /* nsIndex will be set later */
                        chunkEntry[1] = 0x42; /* Blob type */
                        const chunkSpan = 1 + Math.ceil(chunkSize / 32);
                        chunkEntry[2] = chunkSpan;
                        chunkEntry[3] = chunkIdx; /* chunkIndex */
                        chunkEntry.set(keyBytes, 8);
                        chunkEntry[8 + keyBytes.length] = 0;
                        new DataView(chunkEntry.buffer).setUint16(24, chunkSize, true);
                        /* Reserved bytes (26-27) must stay 0xFF to match firmware */
                        chunkEntry[26] = 0xFF;
                        chunkEntry[27] = 0xFF;
                        const chunkCrc = NVSParser.crc32(chunkData);
                        new DataView(chunkEntry.buffer).setUint32(28, chunkCrc, true);

                        entries.push(chunkEntry);

                        const chunkDataEntry = new Uint8Array(32 * (chunkSpan - 1));
                        chunkDataEntry.fill(0xFF);
                        chunkDataEntry.set(chunkData, 0);
                        for (let i = 0; i < chunkSpan - 1; i++) {
                            entries.push(chunkDataEntry.slice(i * 32, (i + 1) * 32));
                        }

                        offset += chunkSize;
                    }

                    /* Append blob index after all chunks (firmware ordering) */
                    entries.push(indexEntry);
                }
                break;
            }
        }

        /* Calculate total span (sum of all entry spans, but entries array contains all 32-byte blocks) */
        const totalSpan = entries.length;

        const headerCrc = NVSParser.crc32Header(entries[0]);
        new DataView(entries[0].buffer).setUint32(4, headerCrc, true);

        return { span: totalSpan, entries };
    }

    /**
     * Convenience: update item by deleting and re-adding
     */
    async updateItem(namespace, key, type, value) {
        try { await this.deleteItem(namespace, key); } catch (e) { /* ignore if not exists */ }
        await this.addItem(namespace, key, type, value);
    }

    /**
     * Find item metadata by namespace/key
     */
    async findItem(namespace, key) {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;
        let nsIndex = -1;
        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;
            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);
            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;
                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;
                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);
                const itemKey = await this.readString(entryOffset + 8, 16);
                if (itemNsIndex === 0 && datatype !== 0xFF && datatype !== 0x00) {
                    const namespaceIndex = await this.view.getUint8(entryOffset + 24);
                    if (itemKey === namespace) nsIndex = namespaceIndex;
                    entry += span - 1;
                    continue;
                }
                if (nsIndex === itemNsIndex && itemKey === key) {
                    return { blockOffset, entryIndex: entry, entryOffset, span };
                }
                entry += span - 1;
            }
        }
        return null;
    }
}


/**
 * DataView-like wrapper for SparseImage
 */
class SparseImageDataView {
    constructor(sparseImage) {
        this.sparseImage = sparseImage;
        this.byteLength = sparseImage.size;
    }

    async _ensureData(offset, size) {
        await this.sparseImage._ensureData(offset, size);
    }

    async getUint8(offset) {
        await this._ensureData(offset, 1);
        return this.sparseImage._get(offset);
    }

    async getInt8(offset) {
        const val = await this.getUint8(offset);
        return val > 127 ? val - 256 : val;
    }

    async getUint16(offset, littleEndian = false) {
        await this._ensureData(offset, 2);
        const b0 = this.sparseImage._get(offset);
        const b1 = this.sparseImage._get(offset + 1);
        return littleEndian ? (b1 << 8) | b0 : (b0 << 8) | b1;
    }

    async getInt16(offset, littleEndian = false) {
        const val = await this.getUint16(offset, littleEndian);
        return val > 32767 ? val - 65536 : val;
    }

    async getUint32(offset, littleEndian = false) {
        await this._ensureData(offset, 4);
        const b0 = this.sparseImage._get(offset);
        const b1 = this.sparseImage._get(offset + 1);
        const b2 = this.sparseImage._get(offset + 2);
        const b3 = this.sparseImage._get(offset + 3);
        return (littleEndian
            ? (b3 << 24) | (b2 << 16) | (b1 << 8) | b0
            : (b0 << 24) | (b1 << 16) | (b2 << 8) | b3) >>> 0; /* Force unsigned 32-bit */
    }

    async getInt32(offset, littleEndian = false) {
        return await this.getUint32(offset, littleEndian) | 0;
    }

    async getBigUint64(offset, littleEndian = false) {
        await this._ensureData(offset, 8);
        if (littleEndian) {
            const low = await this.getUint32(offset, true);
            const high = await this.getUint32(offset + 4, true);
            return (BigInt(high) << 32n) | BigInt(low);
        } else {
            const high = await this.getUint32(offset, false);
            const low = await this.getUint32(offset + 4, false);
            return (BigInt(high) << 32n) | BigInt(low);
        }
    }

    async getBigInt64(offset, littleEndian = false) {
        return await this.getBigUint64(offset, littleEndian);
    }
}

class ESP32Parser {
    constructor(input, options = {}) {
        /* Options structure:
         * {
         *   readDataCallback: async function(addr, len) -> { address, data }
         *   writeDataCallback: async function(addr, data) -> void
         *   sizeHint: number (for lazy-loading without explicit size)
         *   preReadCommandCbr: function(addr, len) -> void
         *   postReadCommandCbr: function(addr, len) -> void
         *   preReadBlockCbr: function() -> void
         *   readBlockCbr: function(bytesRead, totalBytes) -> void
         *   postReadBlockCbr: function() -> void
         *   preWriteCommandCbr: function(addr, len) -> void
         *   postWriteCommandCbr: function(addr, len) -> void
         *   writeBlockCbr: function(offset, total, status) -> void
         *   preFlushPrepareCbr: function(sparseImage) -> void
         *   postFlushPrepareCbr: function(sparseImage) -> void
         * }
         */

        /* Store callback references for use in async handlers */
        this.callbacks = {
            preReadCommandCbr: options.preReadCommandCbr,
            postReadCommandCbr: options.postReadCommandCbr,
            preReadBlockCbr: options.preReadBlockCbr,
            readBlockCbr: options.readBlockCbr,
            postReadBlockCbr: options.postReadBlockCbr,
            preWriteCommandCbr: options.preWriteCommandCbr,
            postWriteCommandCbr: options.postWriteCommandCbr,
            writeBlockCbr: options.writeBlockCbr,
            preFlushPrepareCbr: options.preFlushPrepareCbr,
            postFlushPrepareCbr: options.postFlushPrepareCbr
        };

        this.logMessage = options.logMessage || ((msg) => { });
        this.logDebug = options.logDebug || ((msg) => { });
        this.logWarning = options.logWarning || ((msg) => { });
        this.logError = options.logError || ((msg) => { });

        // Cases:
        // 1) input is ESPFlasher - use it directly as this.flasher
        // 2) input is SparseImage
        // 3) input is Uint8Array/ArrayBuffer (eager data)
        // 4) input is number (size) with readDataCallback (and optional writeDataCallback)
        // 5) input is null/undefined but readDataCallback provided with sizeHint

        this.flasher = null;

        if (input instanceof ESPFlasher) {
            /* ESPFlasher device path */
            this.flasher = input;
            this.sparseImage = new SparseImage(
                options.sizeHint ?? 0,
                this._onSparseImageRead.bind(this),
                this._onSparseImageWrite.bind(this),
                this._onSparseImageFlushPrepare.bind(this)
            );
        } else if (input instanceof SparseImage) {
            /* SparseImage provided directly */
            this.sparseImage = input;
        } else if (input instanceof Uint8Array || input instanceof ArrayBuffer) {
            /* Eager buffer path, backward compatible */
            this.sparseImage = SparseImage.fromBuffer(input);
        } else if (typeof input === 'number') {
            /* Size provided directly */
            this.sparseImage = new SparseImage(input, options.readDataCallback, options.writeDataCallback);
        } else if ((input === null || input === undefined) && options.readDataCallback) {
            /* Lazy-only path needs a size hint */
            this.sparseImage = new SparseImage(options.sizeHint ?? 0, options.readDataCallback, options.writeDataCallback);
        } else {
            throw new Error('Invalid constructor arguments for ESP32Parser. Provide ESPFlasher, Uint8Array/ArrayBuffer, SparseImage, or size with readDataCallback.');
        }

        this.buffer = SparseImage._createProxy(this.sparseImage);
        this.view = this.sparseImage.createDataView();
        this.partitions = [];
        this.nvsData = [];
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    /**
     * SparseImage read callback for ESPFlasher device
     * Reads flash data from the device, respecting alignment and size constraints
     */
    async _onSparseImageRead(readAddr, readLen) {
        const addr = readAddr & ~0x0FFF;
        const maxChunk = 0x00800000;
        const desired = Math.min(readLen, maxChunk);
        let len = (desired + 0x1000) & ~0x0FFF;

        this.callbacks.preReadCommandCbr && this.callbacks.preReadCommandCbr(addr, len);

        const totalSize = this.sparseImage.size;
        /* Ensure we don't read beyond configured flash size */
        if (addr >= totalSize) {
            throw new Error(`Read address 0x${addr.toString(16)} exceeds flash size 0x${totalSize.toString(16)}`);
        }
        len = Math.min(len, totalSize - addr);
        if (len <= 0) {
            throw new Error(`Invalid read length at address 0x${addr.toString(16)}`);
        }

        try {
            this.callbacks.preReadBlockCbr && this.callbacks.preReadBlockCbr();
            const ret = await this.flasher.readFlashPlain(addr, len, (bytesRead, totalBytes) => {
                this.callbacks.readBlockCbr && this.callbacks.readBlockCbr(addr, len, bytesRead, totalBytes);
            });
            this.callbacks.postReadBlockCbr && this.callbacks.postReadBlockCbr();
            const chunk = { address: addr, data: ret };
            this.callbacks.postReadCommandCbr && this.callbacks.postReadCommandCbr(addr, len);
            return chunk;
        } catch (readError) {
            this.logError('Device read error:', readError);
            throw readError;
        }
    }

    /**
     * SparseImage write callback for ESPFlasher device
     * Writes flash data to the device with alignment validation
     */
    async _onSparseImageWrite(writeAddr, writeData) {
        this.callbacks.preWriteCommandCbr && this.callbacks.preWriteCommandCbr(writeAddr, writeData.length);

        /* Write callback for flushing changes to device */
        if (writeAddr % 0x1000 !== 0) {
            throw new Error(`Write address 0x${writeAddr.toString(16)} is not aligned to 0x1000 bytes`);
        }
        if (writeData.length % 0x1000 !== 0) {
            throw new Error(`Write data length ${writeData.length} is not aligned to 0x1000 bytes`);
        }
        try {
            await this.flasher.writeFlash(writeAddr, writeData, (offset, total, status) => {
                this.callbacks.writeBlockCbr && this.callbacks.writeBlockCbr(writeAddr, writeData, offset, total, status);
            });
        } catch (writeError) {
            this.logError('Device write error:', writeError);
            throw writeError;
        }
        this.callbacks.postWriteCommandCbr && this.callbacks.postWriteCommandCbr(writeAddr, writeData.length);
    }

    /**
     * SparseImage flush prepare callback for ESPFlasher device
     * Consolidates write buffer into 4KB-aligned blocks
     */
    async _onSparseImageFlushPrepare(sparseImage) {
        this.callbacks.preFlushPrepareCbr && this.callbacks.preFlushPrepareCbr();

        /* Flush prepare callback: combine cached and write data into 0x1000-byte blocks */
        this.logDebug('Flush prepare: consolidating write buffer into 4KB-aligned blocks');

        if (sparseImage.writeBuffer.length === 0) return;

        /* Get the range we need to cover */
        let minAddr = Infinity;
        let maxAddr = 0;

        for (const seg of sparseImage.writeBuffer) {
            minAddr = Math.min(minAddr, seg.address);
            maxAddr = Math.max(maxAddr, seg.address + seg.data.length);
        }

        if (minAddr === Infinity) return; /* Nothing to do */

        /* Align to 0x1000 byte boundaries */
        const blockStart = minAddr & ~0x0FFF;
        const blockEnd = (maxAddr + 0x0FFF) & ~0x0FFF;

        this.logDebug(`Prepare: processing range 0x${blockStart.toString(16)} - 0x${blockEnd.toString(16)}`);

        /* Build aligned blocks: prefer writeBuffer-only materialization; otherwise read via sparse image */
        const blockMap = new Map(); /* blockAddr -> blockData */

        for (let blockAddr = blockStart; blockAddr < blockEnd; blockAddr += 0x1000) {
            const blockEndAddr = blockAddr + 0x1000;

            const overlaps = [];
            for (const seg of sparseImage.writeBuffer) {
                const segStart = seg.address;
                const segEnd = seg.address + seg.data.length;
                const overlapStart = Math.max(blockAddr, segStart);
                const overlapEnd = Math.min(blockEndAddr, segEnd);
                if (overlapStart < overlapEnd) {
                    overlaps.push({ start: overlapStart, end: overlapEnd, seg });
                }
            }

            /* Skip blocks with no write data at all */
            if (overlaps.length === 0) {
                continue;
            }

            overlaps.sort((a, b) => a.start - b.start);

            let coveredCursor = blockAddr;
            for (const ov of overlaps) {
                if (ov.start > coveredCursor) {
                    break;
                }
                if (ov.end > coveredCursor) {
                    coveredCursor = ov.end;
                }
                if (coveredCursor >= blockEndAddr) {
                    break;
                }
            }

            const fullyCovered = coveredCursor >= blockEndAddr;
            let blockData;

            if (fullyCovered) {
                blockData = new Uint8Array(0x1000);
                blockData.fill(0xFF);
                for (const ov of overlaps) {
                    const srcOff = ov.start - ov.seg.address;
                    const dstOff = ov.start - blockAddr;
                    const len = ov.end - ov.start;
                    blockData.set(ov.seg.data.slice(srcOff, srcOff + len), dstOff);
                }
            } else {
                blockData = await sparseImage.slice_async(blockAddr, blockEndAddr);
            }

            blockMap.set(blockAddr, blockData);
        }

        /* Merge touching/consecutive blocks */
        const mergedBlocks = [];
        const blockAddrs = Array.from(blockMap.keys()).sort((a, b) => a - b);

        let currentStart = null;
        let currentData = null;

        for (const blockAddr of blockAddrs) {
            if (currentStart === null) {
                /* Start new merged block */
                currentStart = blockAddr;
                currentData = new Uint8Array(blockMap.get(blockAddr));
            } else if (currentStart + currentData.length === blockAddr) {
                /* Consecutive block: merge it */
                const mergedData = new Uint8Array(currentData.length + 0x1000);
                mergedData.set(currentData, 0);
                mergedData.set(blockMap.get(blockAddr), currentData.length);
                currentData = mergedData;
            } else {
                /* Gap detected: save current merged block and start new one */
                mergedBlocks.push({ address: currentStart, data: currentData });
                this.logDebug(`  Merged block at 0x${currentStart.toString(16)}, size: ${currentData.length} bytes`);
                currentStart = blockAddr;
                currentData = new Uint8Array(blockMap.get(blockAddr));
            }
        }

        /* Add final merged block */
        if (currentStart !== null) {
            mergedBlocks.push({ address: currentStart, data: currentData });
            this.logDebug(`  Merged block at 0x${currentStart.toString(16)}, size: ${currentData.length} bytes`);
        }

        /* Replace write buffer with merged blocks */
        sparseImage.writeBuffer = mergedBlocks;

        this.logDebug(`Flush prepare complete: ${mergedBlocks.length} blocks aligned and ready`);

        this.callbacks.postFlushPrepareCbr && this.callbacks.postFlushPrepareCbr();
    }

    static bytesToHex(bytes, separator = '') {
        return Array.from(bytes)
            .map(b => b.toString(16).padStart(2, '0').toUpperCase())
            .join(separator);
    }

    static crc32Byte(crc, d) {
        // Process exactly 8 bits of the byte, matching esp32.c behavior
        for (let i = 0; i < 8; i++) {
            const bit = d & 1;
            crc ^= bit;
            crc = (crc & 1) ? (crc >>> 1) ^ 0xEDB88320 : crc >>> 1;
            d >>>= 1;
        }
        return crc >>> 0;
    }

    static crc32(data, offset = 0, length = null) {
        let crc = 0;
        const len = length ?? data.length - offset;
        for (let i = 0; i < len; i++) {
            crc = ESP32Parser.crc32Byte(crc, data[offset + i]);
        }
        return (~crc) >>> 0;
    }

    static crc32Header(data, offset = 0) {
        const buf = new Uint8Array(0x20 - 4);
        buf.set(data.subarray(offset, offset + 4), 0);
        buf.set(data.subarray(offset + 8, offset + 8 + 0x18), 4);
        return ESP32Parser.crc32(buf, 0, 0x1C);
    }

    // Calculate SHA256 hash using Web Crypto API
    static async calculateSHA256(data) {
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        return new Uint8Array(hashBuffer);
    }

    // Calculate SHA1 hash using Web Crypto API
    static async calculateSHA1(data) {
        const hashBuffer = await crypto.subtle.digest('SHA-1', data);
        return new Uint8Array(hashBuffer);
    }

    /* Calculate correct bootloader/image checksum */
    async calculateImageChecksum(imageOffset, imageLength = null) {
        /* Read image header to find checksum location */
        const magic = await this.view.getUint8(imageOffset);
        if (magic !== 0xE9) {
            throw new Error('Invalid image magic');
        }

        const segmentCount = await this.view.getUint8(imageOffset + 1);

        /* Parse segments and calculate checksum ONLY over segment data payloads */
        /* Headers are NOT included in checksum (but are included in SHA256) */
        let currentOffset = imageOffset + 24;
        let checksum = 0xEF;

        const MAX_CHUNK_SIZE = 1024 * 1024; // 1 MB chunks to avoid allocation failures
        const maxOffset = imageLength !== null ? imageOffset + imageLength : this.sparseImage.size;

        for (let i = 0; i < segmentCount; i++) {
            // Check if we've hit erased flash (segment header would be 0xFFFFFFFF)
            const segLoadAddr = await this.view.getUint32(currentOffset, true);
            const segLength = await this.view.getUint32(currentOffset + 4, true);

            // Detect erased/invalid flash: length 0xFFFFFFFF or unreasonably large
            if (segLength === 0xFFFFFFFF || segLength > 0x1000000) {
                throw new Error(`Segment ${i} has invalid length (0x${segLength.toString(16)}) - image may be corrupted or truncated`);
            }

            currentOffset += 8; // Skip segment header (not included in checksum)

            // Validate segment is within partition/flash bounds
            if (currentOffset + segLength > maxOffset) {
                throw new Error(`Segment ${i} extends beyond image bounds (offset: 0x${currentOffset.toString(16)}, length: ${segLength}, max: 0x${maxOffset.toString(16)})`);
            }

            // Process segment in chunks to avoid memory allocation failures
            let segmentOffset = currentOffset;
            let remaining = segLength;

            while (remaining > 0) {
                const chunkSize = Math.min(remaining, MAX_CHUNK_SIZE);
                const segmentChunk = await this.sparseImage.slice_async(segmentOffset, segmentOffset + chunkSize);

                // XOR all bytes of this chunk
                for (let j = 0; j < segmentChunk.length; j++) {
                    checksum ^= segmentChunk[j];
                }

                segmentOffset += chunkSize;
                remaining -= chunkSize;
            }

            currentOffset += segLength;
        }

        /* Pad until checksum sits at offset % 16 == 15 */
        while ((currentOffset % 16) !== 15) {
            currentOffset++;
        }

        const checksumPosition = currentOffset;

        return {
            checksum: checksum & 0xFF,
            checksumOffset: checksumPosition,
            checksumOffsetAbsolute: checksumPosition
        };
    }

    /* Calculate and fix appended SHA256 hash for an image */
    async calculateAndFixImageSHA256(imageOffset) {
        const magic = await this.view.getUint8(imageOffset);
        if (magic !== 0xE9) {
            throw new Error('Invalid image magic');
        }

        const segmentCount = await this.view.getUint8(imageOffset + 1);
        const hasHash = (await this.view.getUint8(imageOffset + 23)) === 1;

        if (!hasHash) {
            return {
                hasHash: false,
                reason: 'Image does not have appended hash'
            };
        }

        /* Parse segments to find checksum offset */
        let currentOffset = imageOffset + 24;
        for (let i = 0; i < segmentCount; i++) {
            const segLength = await this.view.getUint32(currentOffset + 4, true);
            currentOffset += 8 + segLength;
        }

        /* Pad until checksum sits at offset % 16 == 15 */
        while ((currentOffset % 16) !== 15) {
            currentOffset++;
        }

        /* Hash region is from image start to checksum offset (inclusive) */
        const hashRegionEnd = currentOffset + 1;
        const hashRegionLength = hashRegionEnd - imageOffset;

        /* Process in chunks to avoid allocation failures on large images */
        const MAX_CHUNK = 1024 * 1024; // 1 MB
        let hashRegionData;

        if (hashRegionLength <= MAX_CHUNK) {
            hashRegionData = await this.sparseImage.slice_async(imageOffset, hashRegionEnd);
        } else {
            hashRegionData = new Uint8Array(hashRegionLength);
            let offset = 0;
            let remaining = hashRegionLength;

            while (remaining > 0) {
                const chunkSize = Math.min(remaining, MAX_CHUNK);
                const chunk = await this.sparseImage.slice_async(
                    imageOffset + offset,
                    imageOffset + offset + chunkSize
                );
                hashRegionData.set(chunk, offset);
                offset += chunkSize;
                remaining -= chunkSize;
            }
        }

        /* Calculate SHA256 of the region */
        const sha256Bytes = await ESP32Parser.calculateSHA256(hashRegionData);
        const newSha256Hex = ESP32Parser.bytesToHex(sha256Bytes);

        /* SHA256 is stored 32 bytes after the checksum */
        const sha256StorageOffset = currentOffset + 1;

        /* Read the stored SHA256 to compare */
        let storedSha256Hex = '';
        if (sha256StorageOffset + 32 <= this.sparseImage.size) {
            const storedSha256Bytes = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                storedSha256Bytes[i] = await this.view.getUint8(sha256StorageOffset + i);
            }
            storedSha256Hex = ESP32Parser.bytesToHex(storedSha256Bytes);
        }

        /* Check if SHA256 needs updating */
        if (storedSha256Hex.toLowerCase() !== newSha256Hex.toLowerCase()) {
            /* Write the new SHA256 */
            const sha256BytesToWrite = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                sha256BytesToWrite[i] = sha256Bytes[i];
            }
            this.sparseImage.write(sha256StorageOffset, sha256BytesToWrite);

            return {
                hasHash: true,
                fixed: true,
                oldSHA256: storedSha256Hex,
                newSHA256: newSha256Hex,
                offset: sha256StorageOffset
            };
        } else {
            return {
                hasHash: true,
                fixed: false,
                reason: 'SHA256 already valid',
                sha256: storedSha256Hex
            };
        }
    }

    /* Fix checksums for bootloader and OTA app images */
    /* fixType: 'bootloader', 'ota', or null for both */
    /* otaOffset, otaLength: optional partition info when fixing specific OTA app */
    async fixAllChecksums(fixType = null, otaOffset = null, otaLength = null) {
        const results = {
            bootloader: null,
            otaApp: null,
            errors: []
        };

        try {
            /* Fix bootloader if requested */
            if (!fixType || fixType === 'bootloader') {
                /* Try bootloader at 0x0 */
                try {
                    const bl0 = await this.parseImage(0x0, 0x10000);
                    if (bl0 && bl0.magic === 0xE9 && !bl0.error) {
                        const checksumInfo = await this.calculateImageChecksum(0x0, 0x10000);
                        let checksumFixed = false;
                        if (checksumInfo.checksum !== bl0.checksum) {
                            const checksumByte = new Uint8Array(1);
                            checksumByte[0] = checksumInfo.checksum;
                            this.sparseImage.write(checksumInfo.checksumOffsetAbsolute, checksumByte);
                            checksumFixed = true;
                        }

                        /* Also try to fix SHA256 if present */
                        let sha256Fixed = false;
                        let sha256OldValue = null;
                        let sha256NewValue = null;
                        try {
                            const sha256Info = await this.calculateAndFixImageSHA256(0x0);
                            if (sha256Info.hasHash && sha256Info.fixed) {
                                sha256Fixed = true;
                                sha256OldValue = sha256Info.oldSHA256;
                                sha256NewValue = sha256Info.newSHA256;
                            }
                        } catch (e) {
                            /* SHA256 fix not critical */
                        }

                        if (checksumFixed || sha256Fixed) {
                            results.bootloader = {
                                offset: 0x0,
                                checksumFixed: checksumFixed,
                                oldChecksum: checksumFixed ? bl0.checksum : null,
                                newChecksum: checksumFixed ? checksumInfo.checksum : null,
                                sha256Fixed: sha256Fixed,
                                oldSHA256: sha256OldValue,
                                newSHA256: sha256NewValue,
                                fixed: true
                            };
                        } else {
                            results.bootloader = {
                                offset: 0x0,
                                checksum: bl0.checksum,
                                fixed: false,
                                reason: 'Already valid'
                            };
                        }
                    }
                } catch (e) {
                    /* No bootloader at 0x0, try 0x1000 */
                }

                if (!results.bootloader) {
                    try {
                        const bl1 = await this.parseImage(0x1000, 0x10000);
                        if (bl1 && bl1.magic === 0xE9 && !bl1.error) {
                            const checksumInfo = await this.calculateImageChecksum(0x1000, 0x10000);
                            let checksumFixed = false;
                            if (checksumInfo.checksum !== bl1.checksum) {
                                const checksumByte = new Uint8Array(1);
                                checksumByte[0] = checksumInfo.checksum;
                                this.sparseImage.write(checksumInfo.checksumOffsetAbsolute, checksumByte);
                                checksumFixed = true;
                            }

                            /* Also try to fix SHA256 if present */
                            let sha256Fixed = false;
                            let sha256OldValue = null;
                            let sha256NewValue = null;
                            try {
                                const sha256Info = await this.calculateAndFixImageSHA256(0x1000);
                                if (sha256Info.hasHash && sha256Info.fixed) {
                                    sha256Fixed = true;
                                    sha256OldValue = sha256Info.oldSHA256;
                                    sha256NewValue = sha256Info.newSHA256;
                                }
                            } catch (e) {
                                /* SHA256 fix not critical */
                            }

                            if (checksumFixed || sha256Fixed) {
                                results.bootloader = {
                                    offset: 0x1000,
                                    checksumFixed: checksumFixed,
                                    oldChecksum: checksumFixed ? bl1.checksum : null,
                                    newChecksum: checksumFixed ? checksumInfo.checksum : null,
                                    sha256Fixed: sha256Fixed,
                                    oldSHA256: sha256OldValue,
                                    newSHA256: sha256NewValue,
                                    fixed: true
                                };
                            } else {
                                results.bootloader = {
                                    offset: 0x1000,
                                    checksum: bl1.checksum,
                                    fixed: false,
                                    reason: 'Already valid'
                                };
                            }
                        }
                    } catch (e) {
                        results.errors.push('No bootloader found at 0x0 or 0x1000');
                    }
                }
            }

            /* Fix OTA app if requested */
            if (!fixType || fixType === 'ota') {
                try {
                    let otaPartition = null;

                    /* If OTA offset/length provided, use them directly */
                    if (otaOffset !== null && otaLength !== null) {
                        otaPartition = {
                            offset: otaOffset,
                            length: otaLength,
                            label: 'OTA App'
                        };
                    } else {
                        /* Try to find OTA partition from partition table */
                        const validationResult = await this.isValidImage();
                        if (validationResult.bootOtaPartitionIndex !== null && this.partitions && this.partitions.length > 0) {
                            otaPartition = this.partitions[validationResult.bootOtaPartitionIndex];
                        }
                    }

                    if (otaPartition) {
                        const otaImage = await this.parseImage(otaPartition.offset, otaPartition.length);
                        if (otaImage && otaImage.magic === 0xE9 && !otaImage.error) {
                            const checksumInfo = await this.calculateImageChecksum(otaPartition.offset, otaPartition.length);
                            let checksumFixed = false;
                            let sha256Fixed = false;
                            let oldChecksum = otaImage.checksum;
                            let newChecksum = checksumInfo.checksum;
                            let oldSHA256 = null;
                            let newSHA256 = null;

                            if (checksumInfo.checksum !== otaImage.checksum) {
                                const checksumByte = new Uint8Array(1);
                                checksumByte[0] = checksumInfo.checksum;
                                this.sparseImage.write(checksumInfo.checksumOffsetAbsolute, checksumByte);
                                checksumFixed = true;
                            }

                            /* Fix SHA256 if appended */
                            try {
                                const sha256Info = await this.calculateAndFixImageSHA256(otaPartition.offset);
                                if (sha256Info.hasHash) {
                                    if (sha256Info.fixed) {
                                        sha256Fixed = true;
                                        oldSHA256 = sha256Info.oldSHA256;
                                        newSHA256 = sha256Info.newSHA256;
                                    }
                                }
                            } catch (sha256Error) {
                                /* Non-critical: continue even if SHA256 fixing fails */
                            }

                            if (checksumFixed || sha256Fixed) {
                                results.otaApp = {
                                    partition: otaPartition.label,
                                    offset: otaPartition.offset,
                                    checksumFixed: checksumFixed,
                                    oldChecksum: oldChecksum,
                                    newChecksum: newChecksum,
                                    sha256Fixed: sha256Fixed,
                                    oldSHA256: oldSHA256,
                                    newSHA256: newSHA256,
                                    fixed: true
                                };
                            } else {
                                results.otaApp = {
                                    partition: otaPartition.label,
                                    offset: otaPartition.offset,
                                    checksum: otaImage.checksum,
                                    fixed: false,
                                    reason: 'Already valid'
                                };
                            }
                        }
                    } else if (!otaOffset && !otaLength) {
                        results.errors.push('OTA partition not found in partition table');
                    }
                } catch (e) {
                    results.errors.push('Could not fix OTA app: ' + e.message);
                }
            }
        } catch (e) {
            results.errors.push('Error during checksum fix: ' + e.message);
        }

        return results;
    }

    // Quick check if partition has valid ESP32 image magic
    async hasValidImageMagic(partition) {
        if (partition.offset >= this.sparseImage.size) {
            return false;
        }

        const magic = await this.view.getUint8(partition.offset);
        return magic === 0xE9;
    }

    // Parse partition table
    async parsePartitions(offset = 0x9000) {
        const partitions = [];
        let currentOffset = offset;
        let num = 0;

        this.partitionTableOffset = offset;

        while (currentOffset + 32 <= this.sparseImage.size) {
            const magic = await this.view.getUint16(currentOffset, true);

            if (magic !== 0x50AA) {
                break;
            }

            const partition = {
                num: num,
                magic: magic,
                type: await this.view.getUint8(currentOffset + 2),
                subType: await this.view.getUint8(currentOffset + 3),
                offset: await this.view.getUint32(currentOffset + 4, true),
                length: await this.view.getUint32(currentOffset + 8, true),
                label: await this.readString(currentOffset + 12, 16),
                reserved: await this.view.getUint32(currentOffset + 28, true)
            };

            partition.typeName = this.getPartitionTypeName(partition.type, partition.subType);
            partitions.push(partition);

            currentOffset += 32;
            num++;
        }

        this.partitions = partitions;
        return partitions;
    }

    // Compute SHA-1 of a partition
    async computePartitionSHA1(partition) {
        const start = partition.offset;
        const end = Math.min(this.sparseImage.size, partition.offset + partition.length);
        if (start >= this.sparseImage.size || start >= end) {
            return null;
        }
        const view = await this.sparseImage.subarray_async(start, end);
        const hash = await ESP32Parser.calculateSHA1(view);
        return ESP32Parser.bytesToHex(hash);
    }

    // Detect partition table offset: start after bootloader end, skip 0xFF, pick next data at 4K boundary
    // Try to parse partition entries to validate, continue seeking until 0x00100000 if valid table found
    async detectPartitionTableOffset(bootImage) {
        const sector = 0x1000;
        const start = bootImage?.endOffset ?? 0;
        const searchLimit = Math.min(0x00010000, this.sparseImage.size);
        const len = this.sparseImage.size;
        let ptr = start;
        let bestCandidate = null;
        let bestPartitionCount = 0;

        //this.logDebug(`Detecting partition table offset starting from 0x${start.toString(16)}`);
        //this.logDebug(`Buffer length: 0x${len.toString(16)}, search limit: 0x${searchLimit.toString(16)}`);

        while (!bestCandidate && ptr < searchLimit) {
            // Skip 0xFF bytes and check for 4K boundary alignment
            if ((await this.view.getUint8(ptr)) !== 0xFF && (ptr % sector === 0)) {
                // Try to parse partition entries at this offset
                const validCount = await this.validatePartitionTable(ptr);

                if (validCount > 0) {
                    //this.logDebug(`Found valid partition table at 0x${ptr.toString(16)} with ${validCount} entries`);

                    // Keep track of best candidate (most partitions)
                    if (validCount > bestPartitionCount) {
                        bestCandidate = ptr;
                        bestPartitionCount = validCount;
                    }
                }
            }
            ptr++;
        }

        if (bestCandidate !== null) {
            this.partitionTableOffset = bestCandidate;
            //this.logDebug(`Selected partition table offset at 0x${bestCandidate.toString(16)} with ${bestPartitionCount} entries`);
            return bestCandidate;
        }

        //this.logDebug(`No partition table detected`);
        return null;
    }

    // Validate partition table at given offset by trying to parse entries
    async validatePartitionTable(offset) {
        let validCount = 0;
        let currentOffset = offset;
        const maxPartitions = 32; // Reasonable limit

        for (let i = 0; i < maxPartitions; i++) {
            if (currentOffset + 32 > this.sparseImage.size) {
                break;
            }

            const magic = await this.view.getUint16(currentOffset, true);

            // End of partition table
            if (magic !== 0x50AA) {
                break;
            }

            const type = await this.view.getUint8(currentOffset + 2);
            const subType = await this.view.getUint8(currentOffset + 3);
            const partOffset = await this.view.getUint32(currentOffset + 4, true);
            const partLength = await this.view.getUint32(currentOffset + 8, true);

            // Validate partition entry sanity
            // Type should be 0 (APP) or 1 (DATA) typically
            if (type > 0xFE) {
                break; // Invalid type
            }

            // Offset should be reasonable (within flash)
            if (partOffset > 0x10000000) {
                break; // Offset too large
            }

            // Length should be non-zero and reasonable
            if (partLength === 0 || partLength > 0x10000000) {
                break;
            }

            // Read label and check for valid characters
            let validLabel = true;
            for (let j = 0; j < 16; j++) {
                const labelByte = await this.view.getUint8(currentOffset + 12 + j);
                if (labelByte === 0) {
                    break; // Null terminator is fine
                }
                // Check if character is printable ASCII or high bit set
                if (labelByte < 0x20 || (labelByte > 0x7E && labelByte < 0x80)) {
                    validLabel = false;
                    break;
                }
            }

            if (!validLabel) {
                break;
            }

            validCount++;
            currentOffset += 32;
        }

        return validCount;
    }

    getPartitionTypeName(type, subType) {
        const types = {
            0: 'APP',
            1: 'DATA'
        };

        const appSubTypes = {
            0x00: 'factory',
            0x10: 'ota_0',
            0x11: 'ota_1',
            0x12: 'ota_2',
            0x13: 'ota_3',
            0x14: 'ota_4',
            0x15: 'ota_5',
            0x16: 'ota_6',
            0x17: 'ota_7',
            0x20: 'test'
        };

        const dataSubTypes = {
            0x00: 'ota',
            0x01: 'phy',
            0x02: 'nvs',
            0x03: 'coredump',
            0x04: 'nvs_keys',
            0x05: 'efuse',
            0x80: 'esphttpd',
            0x81: 'fat',
            0x82: 'spiffs'
        };

        let typeName = types[type] || 'UNKNOWN';
        let subTypeName = '';

        if (type === 0) {
            subTypeName = appSubTypes[subType] || `unknown_${subType.toString(16)}`;
        } else if (type === 1) {
            subTypeName = dataSubTypes[subType] || `unknown_${subType.toString(16)}`;
        }

        return `${typeName} (${subTypeName})`;
    }

    async readString(offset, maxLength) {
        let result = '';
        for (let i = 0; i < maxLength; i++) {
            const byte = await this.view.getUint8(offset + i);
            if (byte === 0) break;
            // Only include printable ASCII characters (32-126)
            if (byte >= 32 && byte <= 126) {
                result += String.fromCharCode(byte);
            } else if (byte !== 0) {
                // Non-printable character found - might be corrupt data
                return result; // Return what we have so far
            }
        }
        return result;
    }

    // NVS helpers are now encapsulated in NVSParser

    // Get chip name from chip ID
    getChipName(chipId) {
        const chipNames = {
            0x0000: 'ESP32',
            0x0002: 'ESP32-S2',
            0x0005: 'ESP32-C3',
            0x0009: 'ESP32-S3',
            0x000C: 'ESP32-C2',
            0x000D: 'ESP32-C6',
            0x0010: 'ESP32-H2',
            0x0012: 'ESP32-P4',
            0x0017: 'ESP32-C5',
            0x0014: 'ESP32-C61',
            0x0019: 'ESP32-H21',
            0x001C: 'ESP32-H4',
            0x0020: 'ESP32-S31',
            0xFFFF: 'Invalid'
        };
        return chipNames[chipId] || `Unknown (0x${chipId.toString(16).toUpperCase().padStart(4, '0')})`;
    }

    // Get SPI flash mode name
    getSpiModeName(mode) {
        const modes = {
            0: 'QIO',
            1: 'QOUT',
            2: 'DIO',
            3: 'DOUT'
        };
        return modes[mode] || `Unknown (${mode})`;
    }

    // Get SPI flash speed
    getSpiSpeedName(speed) {
        const speeds = {
            0: '40MHz',
            1: '26MHz',
            2: '20MHz',
            0xF: '80MHz'
        };
        return speeds[speed] || `${speed}`;
    }

    // Get SPI flash size
    getSpiSizeName(size) {
        const sizes = {
            0: '1MB',
            1: '2MB',
            2: '4MB',
            3: '8MB',
            4: '16MB',
            5: '32MB',
            6: '64MB',
            7: '128MB'
        };
        return sizes[size] || `Unknown (${size})`;
    }

    // Parse firmware image
    async parseImage(offset, length) {
        if (offset + 24 > this.sparseImage.size) {
            return { error: 'Offset out of bounds' };
        }

        const magic = await this.view.getUint8(offset);
        if (magic !== 0xE9) {
            return { error: 'Invalid magic number', magic: magic };
        }

        const segmentCount = await this.view.getUint8(offset + 1);
        const spiMode = await this.view.getUint8(offset + 2);
        const flashInfoByte = await this.view.getUint8(offset + 3);
        const spiSpeed = flashInfoByte & 0x0F;  // Lower 4 bits
        const spiSize = (flashInfoByte >> 4) & 0x0F;  // Upper 4 bits
        const entryAddr = await this.view.getUint32(offset + 4, true);

        // Extended header (24 bytes total)
        const wpPin = await this.view.getUint8(offset + 8);
        const spiPinDrv = [
            await this.view.getUint8(offset + 9),
            await this.view.getUint8(offset + 10),
            await this.view.getUint8(offset + 11)
        ];
        const chipId = await this.view.getUint16(offset + 12, true);
        const minChipRev = await this.view.getUint8(offset + 14);
        const minChipRevFull = await this.view.getUint16(offset + 15, true);
        const maxChipRevFull = await this.view.getUint16(offset + 17, true);
        const reserved = [
            await this.view.getUint8(offset + 19),
            await this.view.getUint8(offset + 20),
            await this.view.getUint8(offset + 21),
            await this.view.getUint8(offset + 22)
        ];
        const hashAppended = await this.view.getUint8(offset + 23);

        const image = {
            offset: offset,
            magic: magic,
            segmentCount: segmentCount,
            spiMode: spiMode,
            spiModeName: this.getSpiModeName(spiMode),
            spiSpeed: spiSpeed,
            spiSpeedName: this.getSpiSpeedName(spiSpeed),
            spiSize: spiSize,
            spiSizeName: this.getSpiSizeName(spiSize),
            entryAddr: entryAddr,
            wpPin: wpPin,
            wpPinDisabled: wpPin === 0xEE,
            spiPinDrv: spiPinDrv,
            chipId: chipId,
            chipName: this.getChipName(chipId),
            minChipRev: minChipRev,
            minChipRevFull: minChipRevFull,
            minChipRevMajor: Math.floor(minChipRevFull / 100),
            minChipRevMinor: minChipRevFull % 100,
            maxChipRevFull: maxChipRevFull,
            maxChipRevMajor: Math.floor(maxChipRevFull / 100),
            maxChipRevMinor: maxChipRevFull % 100,
            reserved: reserved,
            hashAppended: hashAppended,
            hasHash: hashAppended === 1,
            segmentList: []
        };

        let currentOffset = offset + 24;

        // Parse segments
        for (let i = 0; i < segmentCount; i++) {
            if (currentOffset + 8 > this.sparseImage.size) break;

            const loadAddress = await this.view.getUint32(currentOffset, true);
            const segLength = await this.view.getUint32(currentOffset + 4, true);

            // Detect erased/invalid flash: length 0xFFFFFFFF or unreasonably large
            if (segLength === 0xFFFFFFFF || segLength > 0x1000000) {
                image.error = `Segment ${i} has invalid length (0x${segLength.toString(16)})`;
                break;
            }

            // Check if segment extends beyond partition bounds
            const maxOffset = length !== null ? offset + length : this.sparseImage.size;
            if (currentOffset + 8 + segLength > maxOffset) {
                // Add the faulty segment to show where parsing failed
                image.segmentList.push({
                    loadAddress: loadAddress,
                    length: segLength,
                    offset: currentOffset + 8,
                    truncated: true,
                    error: 'Extends beyond image bounds'
                });
                image.error = `Segment ${i} extends beyond image bounds (offset: 0x${(currentOffset + 8).toString(16)}, length: ${segLength}, max: 0x${maxOffset.toString(16)})`;
                break;
            }

            image.segmentList.push({
                loadAddress: loadAddress,
                length: segLength,
                offset: currentOffset + 8
            });

            currentOffset += 8 + segLength;
        }

        // Pad until checksum sits at offset % 16 == 15 (esptool layout)
        while ((currentOffset % 16) !== 15) {
            currentOffset++;
        }

        const checksumOffset = currentOffset;
        if (currentOffset < this.sparseImage.size) {
            image.checksum = await this.view.getUint8(currentOffset);
            currentOffset++;

            // Always record hash region (header through checksum) for debugging/calculation
            image.sha256DataStart = offset;
            image.sha256DataEnd = checksumOffset + 1;

            if (image.hasHash && currentOffset + 32 <= this.sparseImage.size) {
                const hash = new Uint8Array(32);
                for (let i = 0; i < 32; i++) {
                    hash[i] = await this.view.getUint8(currentOffset + i);
                }
                image.sha256 = ESP32Parser.bytesToHex(hash);
                image.sha256Offset = currentOffset;
                currentOffset += 32;
            }
        }

        image.endOffset = currentOffset;

        // Try to find and parse app description
        image.appDesc = await this.parseAppDescription(image);

        return image;
    }

    // Parse application description (esp_app_desc_t)
    async parseAppDescription(image) {
        const ESP_APP_DESC_MAGIC_WORD = 0xABCD5432;

        if (image.segmentList.length === 0) {
            console.warn(`AppDesc: no segments present for image at 0x${(image.offset ?? 0).toString(16)}`);
            return null;
        }

        const parseAt = async (offset) => {
            const appDesc = {
                found: true,
                offset: offset,
                magicWord: ESP_APP_DESC_MAGIC_WORD,
                secureVersion: await this.view.getUint32(offset + 4, true),
                version: (await this.readString(offset + 16, 32)).trim(),
                projectName: (await this.readString(offset + 48, 32)).trim(),
                time: (await this.readString(offset + 80, 16)).trim(),
                date: (await this.readString(offset + 96, 16)).trim(),
                idfVer: (await this.readString(offset + 112, 32)).trim(),
                appElfSha256: null
            };

            if (offset + 144 + 32 <= this.sparseImage.size) {
                const sha256 = new Uint8Array(32);
                for (let i = 0; i < 32; i++) {
                    sha256[i] = await this.view.getUint8(offset + 144 + i);
                }
                appDesc.appElfSha256 = ESP32Parser.bytesToHex(sha256);
            }

            return appDesc;
        };

        /* Fixed offset: header (24) + first segment header (8) */
        const descOffset = (image.offset ?? 0) + 24 + 8;
        if (descOffset + 256 > this.sparseImage.size || descOffset < 0) {
            // Out of bounds - silently return null
            return null;
        }

        const magic = await this.view.getUint32(descOffset, true);
        if (magic !== ESP_APP_DESC_MAGIC_WORD) {
            // No app descriptor found - this is normal for bootloaders, erased partitions, etc.
            return null;
        }

        try {
            return await parseAt(descOffset);
        } catch (error) {
            console.warn('Error parsing app description at fixed offset:', error);
            return null;
        }
    }

    // Validate image SHA256 hash
    async validateImageSHA256(image) {
        if (image.sha256 === undefined || image.sha256 === null ||
            image.sha256DataStart === undefined || image.sha256DataEnd === undefined) {
            return { valid: false, reason: 'No hash data available' };
        }

        try {
            //this.logDebug(`Image SHA256 region: start=0x${image.sha256DataStart.toString(16)}, end=0x${image.sha256DataEnd.toString(16)}, length=${image.sha256DataEnd - image.sha256DataStart}`);
            const dataToHash = await this.sparseImage.slice_async(image.sha256DataStart, image.sha256DataEnd);
            const calculatedHash = await ESP32Parser.calculateSHA256(dataToHash);
            const calculatedHashHex = ESP32Parser.bytesToHex(calculatedHash);

            const valid = calculatedHashHex === image.sha256;

            return {
                valid: valid,
                calculated: calculatedHashHex,
                expected: image.sha256,
                reason: valid ? 'Hash matches' : 'Hash mismatch'
            };
        } catch (error) {
            return { valid: false, reason: 'Error calculating hash: ' + error.message };
        }
    }

    /**
     * Parse FAT partition
     */
    async parseFATFilesystem(partition) {
        if (!this.sparseImage) {
            throw new Error('ESP32Parser has no SparseImage');
        }
        const parser = new FATParser(this.sparseImage, partition.offset, partition.length);
        parser.logMessage = this.logMessage.bind(this);
        parser.logDebug = this.logDebug.bind(this);
        parser.logError = this.logError.bind(this);
        await parser.initialize();
        return parser;
    }

    /**
     * Parse SPIFFS partition
     */
    async parseSPIFFS(partition) {
        if (!this.sparseImage) {
            throw new Error('ESP32Parser has no SparseImage');
        }
        const parser = new SpiffsParser(this.sparseImage, partition.offset, partition.length);
        parser.logMessage = this.logMessage.bind(this);
        parser.logDebug = this.logDebug.bind(this);
        parser.logError = this.logError.bind(this);
        await parser.initialize();
        return parser;
    }

    // Parse NVS (Non-Volatile Storage) â€” returns NVSParser instance
    async parseNVS(partition) {
        if (!this.sparseImage) {
            throw new Error('ESP32Parser has no SparseImage');
        }
        const parser = new NVSParser(this.sparseImage, partition.offset, partition.length);
        parser.logMessage = this.logMessage.bind(this);
        parser.logDebug = this.logDebug.bind(this);
        parser.logError = this.logError.bind(this);
        await parser.initialize();
        return parser;
    }

    // Parse OTA data partition â€” delegated to OTADataParser class
    async parseOTAData(partition) {
        if (!this.sparseImage) {
            throw new Error('ESP32Parser has no SparseImage');
        }
        const parser = new OTADataParser(this.sparseImage, partition.offset, partition.length);
        parser.logMessage = this.logMessage.bind(this);
        parser.logDebug = this.logDebug.bind(this);
        parser.logError = this.logError.bind(this);
        await parser.initialize();
        return parser;
    }

    // Get partition by label
    getPartition(label) {
        return this.partitions.find(p => p.label === label);
    }

    // Export methods
    async exportPartitionData(partition) {
        const data = await this.buffer.slice_async(partition.offset, partition.offset + partition.length);
        return new Blob([data], { type: 'application/octet-stream' });
    }

    /**
     * High-level validation pipeline for an ESP32 image.
     * - Detect bootloader at 0x0 or 0x1000
     * - Find and parse partition table
     * - Parse OTA data; if valid, resolve boot OTA partition
     * - Validate referenced boot OTA partition image
     * - Parse NVS partition if present and valid
     * Returns a summary structure.
     */
    async isValidImage() {
        const result = {
            success: false,
            allValid: false,
            bootloader: false,
            bootloaderOffset: null,
            otadata: false,
            bootPartition: null,
            bootPartitionValid: false
        };

        /* Step 1: detect bootloader at 0x0, then fallback to 0x1000 */
        let bootloaderImage = null;
        try {
            bootloaderImage = await this.parseImage(0x0000, 0x10000);
            if (bootloaderImage && bootloaderImage.magic === 0xE9 && !bootloaderImage.error) {
                result.bootloader = true;
                result.bootloaderOffset = 0x0000;
            } else {
                bootloaderImage = await this.parseImage(0x1000, 0x10000);
                if (bootloaderImage && bootloaderImage.magic === 0xE9 && !bootloaderImage.error) {
                    result.bootloader = true;
                    result.bootloaderOffset = 0x1000;
                }
            }
        } catch (e) {
            /* Leave result.bootloader false */
        }

        /* Step 2: detect and parse partition table (reference viewer logic) */
        let ptOffset = null;
        try {
            ptOffset = await this.detectPartitionTableOffset(bootloaderImage);
            if (ptOffset !== null) {
                await this.parsePartitions(ptOffset);
            } else {
                this.partitions = [];
            }
        } catch (e) {
            /* keep partitions empty on error */
            this.partitions = this.partitions || [];
        }

        /* Step 3: parse OTA data and resolve boot partition if checksums valid */
        let bootOtaSubType = null;
        let activeOtaSeq = null;
        let allOtaCrcsValid = false;
        const otaDataPart = this.partitions.find(p => p.type === 1 && p.subType === 0x00);
        if (otaDataPart) {
            try {
                const otaInfo = (await this.parseOTAData(otaDataPart)).otaInfo;
                if (otaInfo && Array.isArray(otaInfo.entries) && otaInfo.entries.length === 2) {
                    /* Consider otadata valid if both CRCs are valid OR at least one valid entry exists */
                    const crcAll = otaInfo.entries.every(e => e.crcValid);
                    const anyValid = otaInfo.entries.some(e => e.isValid);
                    allOtaCrcsValid = crcAll;
                    result.otadata = anyValid;

                    if (anyValid) {
                        const activeIdx = otaInfo.activeEntry;
                        if (activeIdx !== null && otaInfo.entries[activeIdx]) {
                            activeOtaSeq = otaInfo.entries[activeIdx].sequence >>> 0;
                            /* Count APP OTA partitions */
                            const otaApps = this.partitions.filter(p => p.type === 0 && p.subType >= 0x10 && p.subType <= 0x1F);
                            const otaCount = otaApps.length;
                            if (otaCount > 0) {
                                const slot = ((activeOtaSeq - 1) % otaCount) >>> 0;
                                bootOtaSubType = 0x10 + slot;
                                result.bootPartition = `ota_${slot}`;
                            }
                        }
                    }
                }
            } catch (e) {
                /* otadata parse failed */
            }
        }

        /* Step 4: validate the referenced boot OTA partition image */
        if (bootOtaSubType !== null) {
            const bootPart = this.partitions.find(p => p.type === 0 && p.subType === bootOtaSubType);
            if (bootPart) {
                try {
                    const hasMagic = await this.hasValidImageMagic(bootPart);
                    if (hasMagic) {
                        /* Parse image and validate appended SHA256 when present */
                        const img = await this.parseImage(bootPart.offset, bootPart.length);
                        if (img && img.hasHash) {
                            const shaRes = await this.validateImageSHA256(img);
                            result.bootPartitionValid = !!(shaRes && shaRes.valid);
                        } else {
                            /* No appended hash; treat valid magic as acceptable */
                            result.bootPartitionValid = true;
                        }

                        /* Extract app description if available */
                        if (img && img.appDesc && img.appDesc.found) {
                            result.appProjectName = img.appDesc.projectName || null;
                            result.appVersion = img.appDesc.version || null;
                        }
                    }
                } catch (e) {
                    /* Leave bootPartitionValid as false on failure */
                }
            }
        }

        /* Step 5: parse NVS if present (validity requires actual valid entries) */
        const nvsPart = this.partitions.find(p => p.type === 1 && p.subType === 0x02);
        let nvsValid = false;
        if (nvsPart) {
            try {
                const nvs = await this.parseNVS(nvsPart);
                if (nvs && Array.isArray(nvs.pages) && nvs.pages.length > 0) {
                    /* Count valid items (not just pages) */
                    let itemCount = 0;
                    for (const page of nvs.pages) {
                        if (page.items && Array.isArray(page.items)) {
                            itemCount += page.items.length;
                        }
                    }
                    nvsValid = itemCount > 0;
                }
            } catch (e) {
                nvsValid = false;
            }
        }

        /* Step 6: aggregate success */
        const partitionsFound = Array.isArray(this.partitions) && this.partitions.length > 0;
        result.success = !!(result.bootloader && partitionsFound);

        /* All valid if: bootloader parsed, partition table found, otadata OK with all CRCs valid, nvs valid and boot partition valid */
        result.allValid = !!(result.bootloader && partitionsFound && result.otadata && allOtaCrcsValid && result.bootPartitionValid && nvsValid);

        /* Attach optional details for callers that need them */
        result.partitionTableOffset = ptOffset ?? null;
        result.nvs = nvsValid;

        return result;
    }
}

// Export for use in HTML
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ESP32Parser;
    module.exports.SparseImage = SparseImage;
}

    </script>
    <script>
        let parser = null;
        let currentFile = null;
        let replaceTargetPartition = null;

        let deviceFlasher = null;
        let deviceMode = false;
        let deviceMac = null;
        let devicePopupTimer = null;
        let devicePopupContent = '';
        let deviceFlashSizeBytes = 0x00800000; /* Default 8 MiB */
        let deviceReadProgressTotal = 0;
        let deviceReadProgressDone = 0;
        let fetchOverlayReason = '';
        let fetchOverlayActiveReads = 0;
        let intentionalDisconnect = false; /* Track intentional disconnects */
        let bootloaderInfo = null;
        let partitionTableOffset = null;
        let isDebugMode = window.location.hash.includes('debug');
        let isAdvancedMode = window.location.hash.includes('advanced');
        let selectedBaudRate = 921600;

        /* Performance tracking for read/write operations */
        let readStartTime = null;
        let readSlowWarningShown = false;
        let readWarningShownTime = null;
        let readWarningHideTimeout = null;
        let writeStartTime = null;
        let writeSlowWarningShown = false;
        let writeWarningShownTime = null;
        let writeWarningHideTimeout = null;
        const SLOW_SPEED_THRESHOLD = 50 * 1024; /* 200 KiB/s in bytes/s */
        const SPEED_CHECK_DELAY = 5000; /* 1 second before checking speed */
        const WARNING_MIN_DISPLAY_TIME = 10000; /* Keep warning visible for at least 10 seconds */

        async function openFlasherMenu() {
            await toggleDeviceSession();
        }

        async function toggleDeviceSession() {
            const btn = document.getElementById('connectToggleBtn');
            const isDisconnect = btn && btn.dataset.state === 'connected';

            if (isDisconnect) {
                await disconnectDeviceSession();
                return;
            }

            try {
                setDeviceStatus('Requesting serial port...', 'loading');
                deviceFlasher = new ESPFlasher({
                    initialBaudRate: selectedBaudRate,
                    logMessage: (msg) => console.log('[Flasher]', msg),
                    logWarning: (msg) => console.warn('[Flasher WARNING]', msg),
                    logError: (msg) => console.error('[Flasher ERROR]', msg),
                    logDebug: (msg) => { isDebugMode ?? console.log('[Flasher DEBUG]', msg); },
                    logPackets: isDebugMode,
                });

                /* Set up callback for unexpected device disconnection */
                deviceFlasher.disconnected = () => {
                    handleUnexpectedDeviceDisconnect();
                };

                deviceFlasher.deviceStateCallback = (state, data) => {
                    if (state === 'secure') {
                        showSecureModError('Secure bootloader detected. Flash access is disabled.');
                    } else if (state === 'secure_boot') {
                        showSecureModError('Secure bootloader detected. Flash access is disabled.');
                    } else if (state === 'secure_download') {
                        showSecureModError('Secure download mode detected.<br>Flash readout is disabled. Write would brick the device.');
                    } else {
                        const msg = formatDeviceStateMessage(state, data);
                        showDevicePopup(msg, state);
                    }
                };

                /* Detect Android and use WebUSB (Web Serial not available on Android) */
                const isAndroid = /Android/i.test(navigator.userAgent);
                if (isAndroid) {
                    console.log('Android device detected, using WebUSB');
                    setDeviceStatus('Android detected - using WebUSB', 'info');
                    const port = await WebUSBSerial.requestPort();
                    await deviceFlasher.openPortWithPort(port);
                } else {
                    console.log('Desktop detected, using Web Serial API');
                    await deviceFlasher.openPort(); // Use Web Serial (default)
                }
                setDeviceButtons({ connected: true });

                /* Try hard reset + sync across baud rates: default, 250000, 115200 */
                let synced = false;
                const baudCandidates = [deviceFlasher.initialBaudRate, 250000, 115200];
                for (const baud of baudCandidates) {
                    try {
                        if (baud && baud !== deviceFlasher.initialBaudRate) {
                            await deviceFlasher.reopenPort(baud);
                        }
                        setDeviceStatus('Resetting ESP32...', 'loading');
                        await deviceFlasher.hardReset(true);

                        setDeviceStatus('Syncing...', 'loading');
                        await deviceFlasher.sync();
                        synced = true;
                        break;
                    } catch (err) {
                        setDeviceStatus('Sync failed' + (baud ? ` at ${baud} baud` : '') + ': ' + err.message, 'error');
                    }
                }
                if (!synced) {
                    deviceFlasher.disconnect();
                    throw new Error('Failed to sync after trying default, 250000, 115200 baud.');
                }

                // Read MAC address after successful sync
                try {
                    deviceMac = await deviceFlasher.readMac();
                } catch (macErr) {
                    console.warn('Could not read device MAC:', macErr);
                    deviceMac = null;
                }

                const isStub = await deviceFlasher.isStubLoader();
                setDeviceButtons({ connected: true, synced: true, stub: isStub });

                if (!isStub) {
                    setDeviceStatus('Loading stub...', 'loading');
                    const stubLoaded = await deviceFlasher.downloadStub();
                    setDeviceButtons({ connected: true, synced: true, stub: stubLoaded });
                }

                setDeviceStatus('Fetching bootloader and partition table...', 'loading');
                setFetchOverlayReason('Reading flash from ESP32');
                showFetchOverlay('Reading flash from ESP32...');
                deviceMode = true;
                deviceReadProgressTotal = deviceFlashSizeBytes;
                deviceReadProgressDone = 0;
                const totalSize = deviceFlashSizeBytes;

                parser = new ESP32Parser(deviceFlasher, {
                    sizeHint: totalSize,
                    logMessage: (msg) => console.log('[Parser]', msg),
                    logWarning: (msg) => console.warn('[Parser WARNING]', msg),
                    logError: (msg) => console.error('[Parser ERROR]', msg),
                    logDebug: (msg) => { },
                    preReadCommandCbr: (addr, len) => {
                        deviceReadProgressDone = 0;
                        deviceReadProgressTotal = len;
                        fetchOverlayActiveReads++;
                        if (!isFetchOverlayVisible()) {
                            showFetchOverlay(fetchOverlayReason || 'Reading flash from ESP32...');
                        }
                    },
                    readBlockCbr: (addr, len, bytesRead, totalBytes) => {
                        deviceReadProgressDone = bytesRead;
                        const now = Date.now();
                        if (now - lastProgressUpdateTime >= UPDATE_THROTTLE_MS) {
                            lastProgressUpdateTime = now;
                            updateFetchOverlayProgress(addr + deviceReadProgressDone, deviceReadProgressDone, deviceReadProgressTotal);
                        }
                    },
                    postReadCommandCbr: (addr, len) => {
                        const now = Date.now();
                        if (now - lastProgressUpdateTime >= UPDATE_THROTTLE_MS) {
                            lastProgressUpdateTime = now;
                            updateFetchOverlayProgress(addr + len, deviceReadProgressDone, deviceReadProgressTotal);
                        }
                        if (--fetchOverlayActiveReads === 0) {
                            hideFetchOverlay();
                        }
                    },
                    preWriteCommandCbr: (addr, len) => {
                        showWriteOverlay('Writing to device...');
                    },
                    writeBlockCbr: (addr, len, bytesWritten, totalBytes, status) => {
                        updateWriteOverlayProgress(addr + bytesWritten, bytesWritten, totalBytes, status);
                    },
                    postWriteCommandCbr: (addr, len) => {
                        hideWriteOverlay();
                        updateMemoryMap();
                    }
                });
                displaySourceInfo({
                    name: 'ESP32 Device',
                    size: totalSize,
                    type: `device/${deviceFlasher.current_chip || 'esp32'}`,
                    lastModified: Date.now()
                });

                parser.logMessage = (msg) => {
                    console.log('Parser:', msg);
                };
                parser.logError = (msg) => {
                    console.error('Parser:', msg);
                };
                if (isDebugMode) {
                    parser.logDebug = (msg) => {
                        console.log('Parser:', msg);
                    };
                }

                await parseAndDisplay(true);
                setDeviceStatus('Connected to ' + deviceFlasher.current_chip + '. Firmware loaded and parsed.', 'success');
                setToggleButtonState(true);

                /* Hide file drop/browse when in device mode */
                const dropZone = document.getElementById('dropZone');
                if (dropZone) dropZone.style.display = 'none';
            } catch (e) {
                if (deviceFlasher) {
                    try {
                        deviceFlasher.disconnect();
                    } catch (disconnectError) {
                        //console.warn('Error during disconnect:', disconnectError);
                    }
                }
                setDeviceStatus('Connection failed: ' + e.message, 'error');
                setDeviceButtons({ connected: false });
                setToggleButtonState(false);
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
                /* Update memory map after all reads complete */
                updateMemoryMap();
            }
        }

        async function disconnectDeviceSession() {
            intentionalDisconnect = true;
            if (deviceFlasher) {
                try {
                    await deviceFlasher.disconnect();
                } catch (e) {
                    console.warn('Device disconnect error:', e);
                }
            }

            clearDeviceState();
        }

        function handleUnexpectedDeviceDisconnect() {
            /* Called when device is unexpectedly disconnected (pulled out, lost connection, etc) */
            if (!intentionalDisconnect) {
                setDeviceStatus('Device unexpectedly disconnected. Please reconnect.', 'error');
            }

            /* Hide any active overlays */
            hideFetchOverlay();
            hideWriteOverlay();

            clearDeviceState();
        }

        function closeFile() {
            /* Close the currently loaded file and reset UI to initial state */
            parser = null;
            currentFile = null;
            deviceMode = false;

            /* Hide file info section */
            const fileInfo = document.getElementById('fileInfo');
            if (fileInfo) {
                fileInfo.classList.remove('visible');
            }

            /* Hide tab container */
            const tabContainer = document.getElementById('tabContainer');
            if (tabContainer) {
                tabContainer.style.display = 'none';
            }

            /* Hide memory map */
            const memoryMapContainer = document.getElementById('memoryMapContainer');
            if (memoryMapContainer) {
                memoryMapContainer.style.display = 'none';
            }

            /* Clear content divs */
            const contentDivs = [
                document.getElementById('bootloaderContent'),
                document.getElementById('partitionsContent'),
                document.getElementById('rawContent')
            ];
            contentDivs.forEach(div => {
                if (div) div.innerHTML = '';
            });

            /* Hide Save Image and Close File buttons */
            const saveBtn = document.getElementById('saveImageBtn');
            if (saveBtn) saveBtn.style.display = 'none';
            const closeBtn = document.getElementById('closeFileBtn');
            if (closeBtn) closeBtn.style.display = 'none';

            /* Show file drop/browse zone */
            const dropZone = document.getElementById('dropZone');
            if (dropZone) dropZone.style.display = 'block';
        }

        function clearDeviceState() {
            /* Clear all device information and reset to disconnected state */
            deviceFlasher = null;
            deviceMode = false;
            deviceMac = null;
            parser = null;

            setDeviceButtons({ connected: false, synced: false, stub: false });
            setToggleButtonState(false);

            /* Hide file info section */
            const fileInfo = document.getElementById('fileInfo');
            if (fileInfo) {
                fileInfo.classList.remove('visible');
            }

            /* Hide tab container */
            const tabContainer = document.getElementById('tabContainer');
            if (tabContainer) {
                tabContainer.style.display = 'none';
            }

            /* Hide memory map */
            const memoryMapContainer = document.getElementById('memoryMapContainer');
            if (memoryMapContainer) {
                memoryMapContainer.style.display = 'none';
            }

            /* Clear content in all tabs */
            const contentDivs = document.querySelectorAll('[id$="Content"]');
            contentDivs.forEach(div => {
                div.innerHTML = '';
            });

            /* Keep Save Image button visible even when disconnected */
            const saveBtn = document.getElementById('saveImageBtn');
            if (saveBtn) {
                saveBtn.style.display = 'inline-block';
            }

            /* Show file drop/browse when disconnected */
            const dropZone = document.getElementById('dropZone');
            if (dropZone) dropZone.style.display = 'block';

            const popup = document.getElementById('devicePopup');
            if (popup) {
                popup.style.display = 'none';
                popup.classList.remove('secure-warning');
            }
            devicePopupContent = '';
            if (devicePopupTimer) {
                clearTimeout(devicePopupTimer);
                devicePopupTimer = null;
            }
        }

        /**
         * Update memory map visualization
         */
        async function updateMemoryMap() {
            if (!parser) return;

            const container = document.getElementById('memoryMapContainer');
            const map = document.getElementById('memoryMap');

            if (!container || !map) return;

            /* Show the map */
            container.style.display = 'block';

            /* Clear existing segments */
            map.innerHTML = '';

            let totalSize = 0;
            let readBuffer = [];
            let writeBuffer = [];

            /* Get data based on mode */
            if (parser.sparseImage) {
                /* Device mode or sparse image */
                totalSize = parser.sparseImage.size;
                readBuffer = parser.sparseImage.readBuffer || [];
                writeBuffer = parser.sparseImage.writeBuffer || [];
            } else {
                container.style.display = 'none';
                return;
            }

            /* Create a coverage map */
            const segmentSize = Math.max(1, Math.floor(totalSize / 1000)); /* 1000 segments max */
            const segments = [];

            for (let i = 0; i < totalSize; i += segmentSize) {
                const end = Math.min(i + segmentSize, totalSize);
                segments.push({ start: i, end: end, type: 'unread' });
            }

            /* Mark cached regions (readBuffer) */
            for (const read of readBuffer) {
                const readStart = read.address;
                const readEnd = read.address + read.data.length;

                for (let seg of segments) {
                    if (seg.end <= readStart || seg.start >= readEnd) continue;

                    /* Check if this segment is all 0xFF (erased) by examining 512-byte blocks */
                    const segStart = Math.max(seg.start, readStart);
                    const segEnd = Math.min(seg.end, readEnd);
                    const blockSize = 512;
                    let isAllFF = true;

                    /* Check 512-byte blocks within this segment */
                    for (let blockAddr = Math.floor(segStart / blockSize) * blockSize; blockAddr < segEnd; blockAddr += blockSize) {
                        const blockEnd = Math.min(blockAddr + blockSize, segEnd);
                        if (blockEnd <= blockAddr) continue;

                        /* Get data for this block from readBuffer */
                        const offsetInRead = Math.max(blockAddr - readStart, 0);
                        const blockDataLen = blockEnd - Math.max(blockAddr, readStart);

                        /* Check if block data is available and all 0xFF */
                        if (offsetInRead < read.data.length) {
                            const blockData = read.data.slice(offsetInRead, offsetInRead + blockDataLen);
                            let blockIsFF = blockData.length > 0 && Array.from(blockData).every(byte => byte === 0xFF);

                            if (!blockIsFF) {
                                isAllFF = false;
                                break;
                            }
                        }
                    }

                    /* Mark segment as 'cached' (normal green) or 'cached-ff' (darker green) */
                    seg.type = isAllFF ? 'cached-ff' : 'cached';
                }
            }

            /* Mark modified regions (writeBuffer) - these override cached */
            for (const write of writeBuffer) {
                const writeStart = write.address;
                const writeEnd = write.address + write.data.length;

                for (let seg of segments) {
                    if (seg.end <= writeStart || seg.start >= writeEnd) continue;

                    const overlapStart = Math.max(seg.start, writeStart);
                    const overlapEnd = Math.min(seg.end, writeEnd);
                    const off = overlapStart - writeStart;
                    const len = overlapEnd - overlapStart;

                    let isAllFF = true;
                    for (let i = 0; i < len; i++) {
                        if (write.data[off + i] !== 0xFF) {
                            isAllFF = false;
                            break;
                        }
                    }

                    seg.type = isAllFF ? 'modified-ff' : 'modified';
                }
            }

            /* Render segments - merge adjacent segments of same type to avoid gaps */
            const mergedSegments = [];
            for (let i = 0; i < segments.length; i++) {
                const seg = segments[i];
                if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === seg.type) {
                    /* Extend previous segment */
                    mergedSegments[mergedSegments.length - 1].end = seg.end;
                } else {
                    /* New segment */
                    mergedSegments.push({ start: seg.start, end: seg.end, type: seg.type });
                }
            }

            for (const seg of mergedSegments) {
                const div = document.createElement('div');
                div.className = `memory-segment ${seg.type}`;
                const leftPercent = (seg.start / totalSize) * 100;
                const widthPercent = ((seg.end - seg.start) / totalSize) * 100;
                div.style.left = leftPercent + '%';
                div.style.width = widthPercent + '%';
                div.title = `0x${seg.start.toString(16).toUpperCase()} - 0x${seg.end.toString(16).toUpperCase()} (${seg.type})`;
                map.appendChild(div);
            }

            /* Collect all labeled areas: bootloader + partitions */
            const areas = [];

            /* Add bootloader */
            if (bootloaderInfo && bootloaderInfo.bootloaderStart !== undefined && bootloaderInfo.bootloaderEnd !== undefined) {
                areas.push({
                    label: 'bootloader',
                    start: bootloaderInfo.bootloaderStart,
                    end: bootloaderInfo.bootloaderEnd,
                    color: '#8B4513'
                });
            }

            /* Add partitions */
            if (parser.partitions && parser.partitions.length > 0) {
                parser.partitions.forEach(part => {
                    areas.push({
                        label: part.label,
                        start: part.offset,
                        end: part.offset + part.length,
                        color: part.type === 0 ? '#60FFFF' : '#7F30FF'
                    });
                });
            }

            /* Sort by start offset */
            areas.sort((a, b) => a.start - b.start);

            /* Set up container for absolute positioning of popups */
            map.parentNode.style.position = 'relative';

            const MIN_WIDTH_FOR_INLINE = 100; /* pixels for inline label */

            /* Create inline labels for large partitions */
            areas.forEach(area => {
                const leftPercent = (area.start / totalSize) * 100;
                const widthPercent = ((area.end - area.start) / totalSize) * 100;
                const mapWidth = map.offsetWidth || 800; /* fallback */
                const areaPixelWidth = (widthPercent / 100) * mapWidth;
                const isInline = areaPixelWidth >= MIN_WIDTH_FOR_INLINE;

                if (isInline) {
                    /* Inline label with vertical borders - always visible */
                    const labelDiv = document.createElement('div');
                    labelDiv.style.position = 'absolute';
                    labelDiv.style.left = leftPercent + '%';
                    labelDiv.style.width = widthPercent + '%';
                    labelDiv.style.top = '0';
                    labelDiv.style.bottom = '0';
                    labelDiv.style.display = 'flex';
                    labelDiv.style.alignItems = 'center';
                    labelDiv.style.justifyContent = 'center';
                    labelDiv.style.borderLeft = `2px solid ${area.color}`;
                    labelDiv.style.borderRight = `2px solid ${area.color}`;
                    labelDiv.style.color = area.color;
                    labelDiv.style.textShadow = '0 0 9px rgba(128,128,128,0.9)';
                    labelDiv.style.fontSize = '12px';
                    labelDiv.style.fontWeight = 'bold';
                    labelDiv.style.pointerEvents = 'none';
                    labelDiv.style.zIndex = '20';
                    labelDiv.textContent = area.label;
                    map.appendChild(labelDiv);

                    /* Create highlight overlay for hover effect */
                    const highlightDiv = document.createElement('div');
                    highlightDiv.style.position = 'absolute';
                    highlightDiv.style.left = leftPercent + '%';
                    highlightDiv.style.width = widthPercent + '%';
                    highlightDiv.style.top = '0';
                    highlightDiv.style.bottom = '0';
                    highlightDiv.style.backgroundColor = area.color;
                    highlightDiv.style.opacity = '0.3';
                    highlightDiv.style.display = 'none';
                    highlightDiv.style.pointerEvents = 'none';
                    highlightDiv.style.zIndex = '15';
                    map.appendChild(highlightDiv);

                    /* Create hover area that covers full height */
                    const hoverDiv = document.createElement('div');
                    hoverDiv.style.position = 'absolute';
                    hoverDiv.style.left = leftPercent + '%';
                    hoverDiv.style.width = widthPercent + '%';
                    hoverDiv.style.top = '0';
                    hoverDiv.style.bottom = '0';
                    hoverDiv.style.cursor = 'pointer';
                    hoverDiv.style.zIndex = '21';

                    hoverDiv.addEventListener('mouseenter', () => {
                        highlightDiv.style.display = 'block';
                    });
                    hoverDiv.addEventListener('mouseleave', () => {
                        highlightDiv.style.display = 'none';
                    });

                    map.appendChild(hoverDiv);
                }
            });

            /* Create single global popup for all partitions */
            const globalPopup = document.createElement('div');
            globalPopup.style.position = 'absolute';
            globalPopup.style.display = 'none';
            globalPopup.style.background = '#303030';
            globalPopup.style.border = '1px solid #333';
            globalPopup.style.padding = '4px 8px';
            globalPopup.style.borderRadius = '3px';
            globalPopup.style.whiteSpace = 'nowrap';
            globalPopup.style.color = '#333';
            globalPopup.style.fontSize = '12px';
            globalPopup.style.fontWeight = 'bold';
            globalPopup.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
            globalPopup.style.pointerEvents = 'none';
            globalPopup.style.zIndex = '30';
            map.parentNode.appendChild(globalPopup);

            /* Create global connecting line */
            const globalLine = document.createElement('div');
            globalLine.style.position = 'absolute';
            globalLine.style.width = '1px';
            globalLine.style.height = '8px';
            globalLine.style.backgroundColor = '#333';
            globalLine.style.display = 'none';
            globalLine.style.pointerEvents = 'none';
            globalLine.style.zIndex = '25';
            map.parentNode.appendChild(globalLine);

            /* Add mousemove handler to show single popup with current address and partition */
            /* Remove old listeners first to prevent duplicates */
            map.removeEventListener('mousemove', map._memoryMapMoveListener);
            map.removeEventListener('mouseleave', map._memoryMapLeaveListener);

            /* Create new listener function and store reference to remove later */
            map._memoryMapMoveListener = function (e) {
                const mapRect = map.getBoundingClientRect();
                const containerRect = map.parentNode.getBoundingClientRect();
                const cursorX = e.clientX - mapRect.left;
                const cursorPercent = cursorX / mapRect.width;
                const addressAtCursor = Math.floor(cursorPercent * totalSize);

                /* Find which partition contains this address */
                const currentArea = areas.find(area => addressAtCursor >= area.start && addressAtCursor < area.end);

                //console.log(`Address: 0x${addressAtCursor.toString(16).toUpperCase()}, Partition: ${currentArea ? currentArea.label : 'NONE'}`);

                if (currentArea) {
                    /* Show popup for the current partition */
                    globalPopup.style.display = 'block';
                    globalLine.style.display = 'block';
                    globalPopup.textContent = `${currentArea.label} @ 0x${addressAtCursor.toString(16).toUpperCase()}`;
                    globalPopup.style.borderColor = currentArea.color;
                    globalPopup.style.color = currentArea.color;
                    globalLine.style.backgroundColor = currentArea.color;

                    /* Position popup above cursor */
                    const cursorXRelativeToContainer = e.clientX - containerRect.left;
                    globalPopup.style.left = cursorXRelativeToContainer + 'px';
                    globalPopup.style.transform = 'translateX(-50%)';
                    globalPopup.style.top = (mapRect.top - containerRect.top - 22) + 'px';

                    /* Position line above bar at cursor */
                    globalLine.style.left = cursorXRelativeToContainer + 'px';
                    globalLine.style.transform = 'translateX(-50%)';
                    globalLine.style.top = (mapRect.top - containerRect.top - 8) + 'px';
                } else {
                    /* No partition at cursor, hide popup */
                    globalPopup.style.display = 'none';
                    globalLine.style.display = 'none';
                }
            };

            map._memoryMapLeaveListener = function () {
                globalPopup.style.display = 'none';
                globalLine.style.display = 'none';
            };

            map.addEventListener('mousemove', map._memoryMapMoveListener);
            map.addEventListener('mouseleave', map._memoryMapLeaveListener);

            /* Add click handler to show segments in console */
            map.onclick = () => {
                console.log('=== Memory Map Segments ===');
                console.log(`Total Size: 0x${totalSize.toString(16).toUpperCase()} (${formatBytes(totalSize)})`);
                console.log('\nRead Buffer Segments:');
                readBuffer.forEach((seg, idx) => {
                    console.log(`  [${idx}] 0x${seg.address.toString(16).toUpperCase()} - 0x${(seg.address + seg.data.length).toString(16).toUpperCase()} (${formatBytes(seg.data.length)})`);
                });
                console.log('\nWrite Buffer Segments:');
                writeBuffer.forEach((seg, idx) => {
                    console.log(`  [${idx}] 0x${seg.address.toString(16).toUpperCase()} - 0x${(seg.address + seg.data.length).toString(16).toUpperCase()} (${formatBytes(seg.data.length)})`);
                });
                console.log('\nMerged Display Segments:');
                mergedSegments.forEach((seg, idx) => {
                    console.log(`  [${idx}] 0x${seg.start.toString(16).toUpperCase()} - 0x${seg.end.toString(16).toUpperCase()} (${seg.type})`);
                });
            };
        }

        function setToggleButtonState(connected) {
            const btn = document.getElementById('connectToggleBtn');
            if (!btn) return;
            if (connected) {
                btn.textContent = 'Disconnect';
                btn.style.background = 'linear-gradient(135deg, #b71c1c 0%, #ef5350 100%)';
                btn.dataset.state = 'connected';
            } else {
                btn.textContent = 'Connect to ESP32';
                btn.style.background = 'linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%)';
                btn.dataset.state = 'disconnected';
            }
        }

        function toggleTargetActions() {
            const targetActions = document.getElementById('targetActionsButtons');
            if (targetActions) {
                const isVisible = targetActions.style.display !== 'none';
                targetActions.style.display = isVisible ? 'none' : 'block';
            }
        }

        function setDeviceButtons({ connected = false, synced = false, stub = false }) {
            const targetActions = document.getElementById('targetActions');
            if (targetActions) {
                targetActions.style.display = connected ? 'block' : 'none';
            }

            const btnReset = document.getElementById('targetResetBtn');
            const btnSync = document.getElementById('targetSyncBtn');
            const btnStub = document.getElementById('targetStubBtn');
            const btnFetch = document.getElementById('targetFetchBtn');
            const btnDisconnect = document.getElementById('deviceDisconnectBtn');

            if (btnReset) btnReset.disabled = !connected;
            if (btnSync) btnSync.disabled = !connected;
            if (btnStub) btnStub.disabled = !synced || stub;
            if (btnFetch) btnFetch.disabled = !synced;
            if (btnDisconnect) btnDisconnect.style.display = connected ? 'block' : 'none';
        }

        function setDeviceStatus(text, cls = 'success') {
            const el = document.getElementById('deviceStatusText');
            const container = document.getElementById('deviceStatusContainer');
            if (el && container) {
                el.className = cls;
                el.textContent = text;
                container.style.display = 'block';
                container.style.opacity = '1';
                container.style.transition = 'opacity 0.5s ease-out';

                /* Fade out after 5 seconds */
                setTimeout(() => {
                    container.style.opacity = '0';
                    setTimeout(() => {
                        container.style.display = 'none';
                    }, 500);
                }, 10000);
            } else {
                console.log(`[${cls}] ${text}`);
            }
        }

        function setupAdvancedControls() {
            const group = document.getElementById('advancedBaudGroup');
            const select = document.getElementById('advancedBaudSelect');

            if (!group || !select) {
                return;
            }

            if (!isAdvancedMode) {
                group.style.display = 'none';
                return;
            }

            group.style.display = 'block';
            select.value = selectedBaudRate.toString();

            select.addEventListener('change', () => {
                const nextBaud = parseInt(select.value, 10);
                if (!Number.isFinite(nextBaud)) {
                    return;
                }
                selectedBaudRate = nextBaud;
                if (deviceFlasher) {
                    deviceFlasher.initialBaudRate = selectedBaudRate;
                }
                setDeviceStatus(`Baud set to ${selectedBaudRate} (advanced)`, 'info');
            });

            setDeviceStatus('Advanced baud selector enabled (#advanced).', 'info');
        }

        function showDevicePopup(message, state = null) {
            const popup = document.getElementById('devicePopup');
            if (!popup) {
                return;
            }

            if (popup.style.display !== 'none' && devicePopupContent) {
                devicePopupContent += '\n' + message;
            } else {
                devicePopupContent = message;
            }

            popup.innerHTML = '<strong>Device Info</strong><br>' + devicePopupContent.replace(/\n/g, '<br>');
            if (state === 'secure') {
                popup.classList.add('secure-warning');
            } else {
                popup.classList.remove('secure-warning');
            }
            popup.style.display = 'block';

            if (devicePopupTimer) {
                clearTimeout(devicePopupTimer);
            }
            devicePopupTimer = setTimeout(() => {
                popup.style.display = 'none';
                devicePopupContent = '';
            }, 5000);
        }

        function formatDeviceStateMessage(state, data) {
            if (state === 'secure') {
                return 'âš ï¸ Warning: Device is secured, this tool won\'t work with it';
            }
            if (state === 'download') {
                return 'Device waiting for download (ROM bootloader)';
            }
            if (state === 'reboot' && data) {
                const rstHex = '0x' + (data.rst ?? 0).toString(16);
                const rstName = data.rstName || 'UNKNOWN';
                const bootHex = '0x' + (data.boot ?? 0).toString(16);
                return `Reboot: ${rstName} (${rstHex}), boot=${bootHex}`;
            }
            return `Device state: ${state}`;
        }

        function showFetchOverlay(text) {
            const overlay = document.getElementById('fetchOverlay');
            const label = document.getElementById('fetchOverlayText');

            setFetchOverlayReason(text);
            if (overlay) {
                overlay.style.display = 'flex';
            }
            readStartTime = Date.now();
            readSlowWarningShown = false;
            lastProgressPercent = -1; /* Reset percentage tracker for new operation */
        }

        function setFetchOverlayReason(reason) {
            fetchOverlayReason = reason || '';
            const overlay = document.getElementById('fetchOverlay');
            const label = document.getElementById('fetchOverlayText');
            if (overlay && label && overlay.style.display === 'flex') {
                label.textContent = fetchOverlayReason || label.textContent || 'Fetching firmware...';
            }
        }

        function isFetchOverlayVisible() {
            const overlay = document.getElementById('fetchOverlay');
            return overlay && overlay.style.display === 'flex';
        }

        let lastProgressPercent = -1;
        let pendingProgressUpdate = null;
        let lastProgressUpdateTime = 0;
        let lastMemoryMapUpdateTime = 0;
        const UPDATE_THROTTLE_MS = 50;

        async function updateFetchOverlayProgress(address, bytesRead, totalBytes) {
            const pct = totalBytes > 0 ? Math.min(100, Math.round((bytesRead / totalBytes) * 100)) : 0;

            /* Skip update if percentage hasn't changed (reduces redundant DOM updates) */
            if (pct === lastProgressPercent && pct !== 0 && pct !== 100) {
                return;
            }

            /* Reset speed calculation if progress went backwards (new read started) */
            if (pct < lastProgressPercent) {
                readStartTime = Date.now();
            }
            lastProgressPercent = pct;


            /* Defer DOM update to next animation frame to avoid blocking WebUSB loop */
            if (pendingProgressUpdate) {
                cancelAnimationFrame(pendingProgressUpdate);
            }
            pendingProgressUpdate = requestAnimationFrame(() => {
                pendingProgressUpdate = null;
                const label = document.getElementById('fetchOverlayText');
                if (!label) {
                    return;
                }

                const kbRead = Math.round(bytesRead / 1024);
                const kbTotal = Math.round(totalBytes / 1024);

                let text = `Reading 0x${address.toString(16).toUpperCase()} (${pct}% â€“ ${kbRead} / ${kbTotal} KB)`;
                let addWarning = false;

                /* Calculate speed if operation has been running > 1 second */
                if (readStartTime) {
                    const elapsedMs = Date.now() - readStartTime;
                    if (elapsedMs > SPEED_CHECK_DELAY && bytesRead > 0) {
                        const speedBytesPerSec = (bytesRead / elapsedMs) * 1000;
                        const speedKiBPerSec = Math.round(speedBytesPerSec / 1024);
                        text += ` - ${speedKiBPerSec} KiB/s`;

                        /* Show warning if speed is too slow */
                        if (speedBytesPerSec < SLOW_SPEED_THRESHOLD) {
                            addWarning = true;
                            if (!readSlowWarningShown) {
                                readSlowWarningShown = true;
                                readWarningShownTime = Date.now();
                            }
                        }
                    }
                } else if (readSlowWarningShown && readWarningShownTime) {
                    /* Keep showing warning if still within minimum display time */
                    const warningElapsedMs = Date.now() - readWarningShownTime;
                    if (warningElapsedMs < WARNING_MIN_DISPLAY_TIME) {
                        addWarning = true;
                    }
                }
                if (addWarning) {
                    text += `<br><br>âš ï¸ SLOW: due to hardware/stub bug, ESP32-S3 and C3 are very slow with onchip USB-JTAG`;
                }

                label.innerHTML = text;
            });
        }

        function hideFetchOverlay() {
            const overlay = document.getElementById('fetchOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            fetchOverlayActiveReads = 0;
            readStartTime = null;
            /* Clear any existing timeout and set new one for warning minimum display time */
            if (readWarningHideTimeout) {
                clearTimeout(readWarningHideTimeout);
            }
            if (readSlowWarningShown && readWarningShownTime) {
                const timeElapsed = Date.now() - readWarningShownTime;
                const timeRemaining = Math.max(0, WARNING_MIN_DISPLAY_TIME - timeElapsed);
                readWarningHideTimeout = setTimeout(() => {
                    readSlowWarningShown = false;
                    readWarningShownTime = null;
                    readWarningHideTimeout = null;
                }, timeRemaining);
            }
        }

        function showWriteOverlay(text) {
            const overlay = document.getElementById('writeOverlay');
            const label = document.getElementById('writeOverlayText');
            if (label) {
                label.textContent = text || 'Writing to device...';
            }
            if (overlay) {
                overlay.style.display = 'flex';
            }
            writeStartTime = Date.now();
            writeSlowWarningShown = false;
            writeWarningShownTime = null;
        }

        function updateWriteOverlayProgress(address, bytesWritten, totalBytes, statusText = '') {
            const label = document.getElementById('writeOverlayText');
            if (!label) {
                return;
            }

            const kbWritten = Math.round(bytesWritten / 1024);
            const kbTotal = Math.round(totalBytes / 1024);
            const pct = totalBytes > 0 ? Math.min(100, Math.round((bytesWritten / totalBytes) * 100)) : 0;

            let text = `${statusText} 0x${address.toString(16).toUpperCase()} (${pct}% â€“ ${kbWritten} / ${kbTotal} KB)`;
            let addWarning = false;

            /* Calculate speed if operation has been running > 1 second */
            if (writeStartTime) {
                const elapsedMs = Date.now() - writeStartTime;
                if (elapsedMs > SPEED_CHECK_DELAY && bytesWritten > 0) {
                    const speedBytesPerSec = (bytesWritten / elapsedMs) * 1000;
                    const speedKiBPerSec = Math.round(speedBytesPerSec / 1024);
                    text += ` - ${speedKiBPerSec} KiB/s`;

                    /* Show warning if speed is too slow */
                    if (speedBytesPerSec < SLOW_SPEED_THRESHOLD) {
                        addWarning = true;
                        if (!writeSlowWarningShown) {
                            writeSlowWarningShown = true;
                            writeWarningShownTime = Date.now();
                        }
                    }
                }
            } else if (writeSlowWarningShown && writeWarningShownTime) {
                /* Keep showing warning if still within minimum display time */
                const warningElapsedMs = Date.now() - writeWarningShownTime;
                if (warningElapsedMs < WARNING_MIN_DISPLAY_TIME) {
                    addWarning = true;
                }
            }
            if (addWarning) {
                text += `<br><br>âš ï¸ SLOW: due to hardware/stub bug, ESP32-S3 and C3 are very slow with onchip USB-JTAG`;
            }

            label.innerHTML = text;
        }

        function hideWriteOverlay() {
            const overlay = document.getElementById('writeOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            writeStartTime = null;
            /* Clear any existing timeout and set new one for warning minimum display time */
            if (writeWarningHideTimeout) {
                clearTimeout(writeWarningHideTimeout);
            }
            if (writeSlowWarningShown && writeWarningShownTime) {
                const timeElapsed = Date.now() - writeWarningShownTime;
                const timeRemaining = Math.max(0, WARNING_MIN_DISPLAY_TIME - timeElapsed);
                writeWarningHideTimeout = setTimeout(() => {
                    writeSlowWarningShown = false;
                    writeWarningShownTime = null;
                    writeWarningHideTimeout = null;
                }, timeRemaining);
            }
        }

        function showSecureModError(msg) {
            /* If overlay exists, update its message and keep it visible */
            const existing = document.getElementById('secureModErrorOverlay');
            if (existing) {
                const msgEl = document.getElementById('secureModErrorMessage');
                if (msgEl) {
                    msgEl.innerHTML = `
                        <p>This ESP32 device has been programmed with secure fuses.</p>
                        <p><strong>${msg || 'Secure mode active'}</strong></p>
                        <p>The device's security features prevent any useful access to its firmware.</p>
                    `;
                }
                existing.style.display = 'flex';
                return;
            }

            /* Create overlay */
            const overlay = document.createElement('div');
            overlay.id = 'secureModErrorOverlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'rgba(0, 0, 0, 0.8)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '10002';

            /* Create error box */
            const errorBox = document.createElement('div');
            errorBox.style.background = '#3d1f1f';
            errorBox.style.border = '3px solid #ff4444';
            errorBox.style.borderRadius = '12px';
            errorBox.style.padding = '40px';
            errorBox.style.maxWidth = '600px';
            errorBox.style.textAlign = 'center';
            errorBox.style.boxShadow = '0 0 40px rgba(255, 68, 68, 0.6)';

            /* Error title */
            const title = document.createElement('div');
            title.style.fontSize = '32px';
            title.style.fontWeight = 'bold';
            title.style.color = '#ff6b6b';
            title.style.marginBottom = '20px';
            title.textContent = 'ðŸ”’ Device is Secured';
            errorBox.appendChild(title);

            /* Error message */
            const msgEl = document.createElement('div');
            msgEl.id = 'secureModErrorMessage';
            msgEl.style.fontSize = '16px';
            msgEl.style.color = '#ffcccc';
            msgEl.style.lineHeight = '1.6';
            msgEl.style.marginBottom = '20px';
            msgEl.innerHTML = `
                <p>This ESP32 device has been programmed with secure fuses.</p>
                <p><strong>${msg || 'Secure mode active'}</strong></p>
                <p>The device's security features prevent any useful access to its firmware.</p>
            `;
            errorBox.appendChild(msgEl);

            /* Close button */
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.style.background = '#ff4444';
            closeBtn.style.color = '#fff';
            closeBtn.style.border = 'none';
            closeBtn.style.padding = '12px 30px';
            closeBtn.style.fontSize = '16px';
            closeBtn.style.borderRadius = '6px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.marginTop = '20px';
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.body.removeChild(overlay);
            });
            errorBox.appendChild(closeBtn);

            /* Stop propagation on errorBox to prevent closing when clicking inside */
            errorBox.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            /* Close when clicking on overlay background */
            overlay.addEventListener('click', () => {
                document.body.removeChild(overlay);
            });

            overlay.appendChild(errorBox);
            document.body.appendChild(overlay);
        }

        async function deviceConnect() {
            try {
                setDeviceStatus('Requesting serial port...', 'loading');
                deviceFlasher = new ESPFlasher({
                    initialBaudRate: selectedBaudRate,
                    logMessage: (msg) => console.log('[Flasher]', msg),
                    logWarning: (msg) => console.warn('[Flasher WARNING]', msg),
                    logError: (msg) => console.error('[Flasher ERROR]', msg),
                    logDebug: (msg) => { isDebugMode ?? console.log('[Flasher DEBUG]', msg); },
                    logPackets: isDebugMode,
                });
                await deviceFlasher.openPort();
                setDeviceStatus('Connected. You may Hard Reset, then Sync.', 'success');
                setDeviceButtons({ connected: true });
            } catch (e) {
                setDeviceStatus('Connection failed: ' + e.message, 'error');
                setDeviceButtons({ connected: false });
            }
        }

        async function deviceHardReset() {
            if (!deviceFlasher) return;
            try {
                setDeviceStatus('Resetting...', 'loading');
                await deviceFlasher.hardReset(true);
                setDeviceStatus('Reset sequence sent.', 'success');
            } catch (e) {
                setDeviceStatus('Reset failed: ' + e.message, 'error');
            }
        }

        async function deviceSync() {
            if (!deviceFlasher) return;
            try {
                setDeviceStatus('Syncing...', 'loading');
                await deviceFlasher.sync();

                // Read MAC address
                try {
                    deviceMac = await deviceFlasher.readMac();
                } catch (macErr) {
                    console.warn('Could not read device MAC:', macErr);
                    deviceMac = null;
                }

                setDeviceStatus('Synced to ' + deviceFlasher.current_chip + '.', 'success');
                setDeviceButtons({ connected: true, synced: true, stub: await deviceFlasher.isStubLoader() });
            } catch (e) {
                setDeviceStatus('Sync failed: ' + e.message, 'error');
            }
        }

        async function deviceLoadStub() {
            if (!deviceFlasher) return;
            try {
                setDeviceStatus('Loading stub...', 'loading');
                const ok = await deviceFlasher.downloadStub();
                setDeviceButtons({ connected: true, synced: true, stub: ok });
                setDeviceStatus(ok ? 'Stub loaded.' : 'Stub load failed', ok ? 'success' : 'error');
            } catch (e) {
                setDeviceStatus('Stub error: ' + e.message, 'error');
            }
        }

        async function deviceRefresh() {
            if (!deviceFlasher) return;
            try {
                deviceMode = true;
                setDeviceStatus('Fetching bootloader and partition table...', 'loading');
                setFetchOverlayReason('Reading flash from ESP32');
                showFetchOverlay('Reading flash from ESP32...');
                deviceReadProgressTotal = deviceFlashSizeBytes;
                deviceReadProgressDone = 0;
                const totalSize = deviceFlashSizeBytes;

                await parser.sparseImage.clear();

                /* Fake file info for UI */
                displaySourceInfo({
                    name: 'ESP32 Device',
                    size: totalSize,
                    type: `device/${deviceFlasher.current_chip || 'esp32'}`,
                    lastModified: Date.now()
                });

                await parseAndDisplay();
                setDeviceStatus('Fetched and parsed. You can explore partitions.', 'success');
            } catch (e) {
                setDeviceStatus('Fetch failed: ' + e.message, 'error');
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
            }
        }

        // File drop handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        setupAdvancedControls();

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
                // Reset input value to allow selecting the same file again
                e.target.value = '';
            }
        });

        const partitionFileInput = document.getElementById('partitionFileInput');
        partitionFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0 && replaceTargetPartition !== null) {
                handlePartitionReplaceFile(e.target.files[0], replaceTargetPartition);
                // Reset input value to allow selecting the same file again
                e.target.value = '';
            }
        });

        async function handleFile(file) {
            currentFile = file;
            console.log('Loading file:', file.name, 'size:', file.size, 'type:', file.type);
            await disconnectDeviceSession();
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const sparse = SparseImage.fromBuffer(e.target.result);
                    parser = new ESP32Parser(sparse, {
                        sizeHint: sparse.size,
                        logMessage: (msg) => console.log('[Parser]', msg),
                        logWarning: (msg) => console.warn('[Parser WARNING]', msg),
                        logError: (msg) => console.error('[Parser ERROR]', msg),
                        logDebug: (msg) => { },
                    });
                    displaySourceInfo(file);
                    parseAndDisplay(true).then(() => {
                        updateMemoryMap();
                        // Hide drop zone and show close button when file is loaded
                        const dropZone = document.getElementById('dropZone');
                        if (dropZone) dropZone.style.display = 'none';
                        const closeBtn = document.getElementById('closeFileBtn');
                        if (closeBtn) closeBtn.style.display = 'inline-block';
                    }).catch(err => {
                        console.error('Error parsing file:', err);
                        showError('Error parsing file: ' + err.message);
                    });
                } catch (error) {
                    console.error('Error parsing file:', error);
                    showError('Error parsing file: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function displaySourceInfo(file) {
            const fileInfo = document.getElementById('fileInfo');
            const grid = document.getElementById('fileInfoGrid');

            const typeLabel = (() => {
                const t = file.type || 'application/octet-stream';
                if (t.startsWith('device/') && deviceFlasher && deviceFlasher.current_chip) {
                    return `device/${deviceFlasher.current_chip}`;
                }
                return t;
            })();

            const isDevice = deviceMode || (file.type && file.type.startsWith('device/'));
            const sizeValueBytes = isDevice ? deviceFlashSizeBytes : file.size;
            const sizeMarkup = isDevice
                ? `<select id="deviceSizeSelect" class="size-select" title="Select device flash size">
                        <option value="1">1 MiB</option>
                        <option value="2">2 MiB</option>
                        <option value="4">4 MiB</option>
                        <option value="8">8 MiB</option>
                        <option value="16">16 MiB</option>
                   </select>`
                : `<span>${formatBytes(sizeValueBytes)}</span>`;

            // Build MAC address row for device mode
            const macRow = isDevice && deviceMac
                ? `<div class="info-item">
                    <label>MAC Address</label>
                    <span class="mono">${deviceMac}</span>
                </div>`
                : '';

            grid.innerHTML = `
                <div class="info-item">
                    <label>Filename</label>
                    <span>${file.name}</span>
                </div>
                <div class="info-item">
                    <label>Size</label>
                    ${sizeMarkup}
                </div>
                <div class="info-item">
                    <label>Type</label>
                    <span>${typeLabel}</span>
                </div>
                ${macRow}
                <div class="info-item">
                    <label>Last Modified</label>
                    <span>${new Date(file.lastModified).toLocaleString()}</span>
                </div>
            `;

            if (isDevice) {
                const sel = document.getElementById('deviceSizeSelect');
                if (sel) {
                    const currentMiB = Math.round(deviceFlashSizeBytes / (1024 * 1024));
                    sel.value = String(currentMiB);
                    sel.addEventListener('change', () => {
                        const parsed = parseInt(sel.value, 10);
                        applyDeviceFlashSize(parsed * 1024 * 1024);
                    });
                }
            }

            fileInfo.classList.add('visible');

            // Show/hide buttons based on mode
            const importBtn = document.getElementById('importBinBtn');
            if (importBtn) {
                importBtn.style.display = 'inline-block';
            }
            const eraseBtn = document.getElementById('eraseFlashBtn');
            if (eraseBtn) {
                eraseBtn.style.display = 'inline-block';
            }
            const writeBtn = document.getElementById('writeToDeviceBtn');
            if (writeBtn) {
                writeBtn.style.display = isDevice ? 'inline-block' : 'none';
            }

            // Always show Save Image button for both file and device modes
            const saveBtn = document.getElementById('saveImageBtn');
            if (saveBtn) {
                saveBtn.style.display = 'inline-block';
            }
        }

        async function applyDeviceFlashSize(sizeBytes) {
            if (!deviceFlasher) {
                return;
            }

            console.log('Applying device flash size: ', sizeBytes);

            deviceMode = true;

            deviceFlashSizeBytes = sizeBytes;
            parser.sparseImage.size = sizeBytes;

            displaySourceInfo({
                name: 'ESP32 Device',
                size: deviceFlashSizeBytes,
                type: `device/${deviceFlasher.current_chip || 'esp32'}`,
                lastModified: Date.now()
            });
        }

        async function parseAndDisplay(focusBootloader = false) {
            // Parse bootloader first to detect partition table offset
            bootloaderInfo = await parseBootloader(0x1000);
            if (!bootloaderInfo || bootloaderInfo.error) {
                bootloaderInfo = await parseBootloader(0x0000);
            }
            console.log("Bootloader parsed:", bootloaderInfo);

            // Auto-detect partition table offset based on bootloader end/FF padding
            const detectedOffset = await parser.detectPartitionTableOffset(bootloaderInfo);
            console.log("Detected partition table offset: ", detectedOffset ? `0x${detectedOffset.toString(16)}` : 'not found');

            partitionTableOffset = detectedOffset;
            if (detectedOffset) {
                await parser.parsePartitions(detectedOffset);
            } else {
                // No partition table detected, clear the list
                parser.partitions = [];
            }

            // Compute SHA-1 only in file mode to avoid heavy device reads
            if (!deviceMode) {
                await Promise.all(parser.partitions.map(async (part) => {
                    part.sha1 = await parser.computePartitionSHA1(part);
                }));
            }

            await displayPartitions();
            await updateMemoryMap();

            // Show tabs
            document.getElementById('tabContainer').style.display = 'block';

            if (focusBootloader) {
                switchTab('bootloader');
            }
        }

        async function parseBootloader(offset = 0x0000) {
            const contentDiv = document.getElementById('bootloaderContent');
            const maxBootloaderLength = parser.sparseImage.length - offset;
            const partition = { offset: offset, length: maxBootloaderLength, label: 'bootloader' };

            contentDiv.innerHTML = '<div class="loading">â³ Parsing bootloader...</div>';

            try {
                const image = await parser.parseImage(partition.offset, partition.length);

                const fmtHex = (val, width = 0) => Number.isFinite(val) ? '0x' + val.toString(16).toUpperCase().padStart(width, '0') : 'n/a';
                const fmtText = (val, fallback = 'n/a') => (val !== undefined && val !== null && val !== '') ? val : fallback;

                const magicValid = image && !image.error && image.magic === 0xE9;
                if (!magicValid) {
                    const msg = fmtText(image.error, `Invalid magic or non-bootloader image: ${image.error}`);
                    const minimalHtml = `<div class="error" style="margin-bottom: 15px;"><strong>âš ï¸ Not a bootloader at ${fmtHex(offset, 4)}</strong><br>${msg}</div>`;
                    contentDiv.innerHTML = minimalHtml;

                    /* Provide reasonable start/end markers so callers can continue */
                    image.bootloaderStart = partition.offset;
                    image.bootloaderEnd = Number.isFinite(image.endOffset)
                        ? image.endOffset
                        : partition.offset + (image.length || 0);
                    return image;
                }

                // Validate SHA256 (appended) and compute region/full hashes
                let sha256Validation = null;
                let sha256RegionCalc = null;

                if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined && image.sha256DataEnd > image.sha256DataStart) {
                    console.log(`Bootloader SHA256 region: start=0x${image.sha256DataStart.toString(16)}, end=0x${image.sha256DataEnd.toString(16)}, length=${image.sha256DataEnd - image.sha256DataStart}`);
                    const regionData = await parser.sparseImage.slice_async(image.sha256DataStart, image.sha256DataEnd);
                    const regionHash = await ESP32Parser.calculateSHA256(regionData);
                    sha256RegionCalc = ESP32Parser.bytesToHex(regionHash);
                }

                if (image.sha256) {
                    sha256Validation = await parser.validateImageSHA256(image);
                    if (sha256Validation && !sha256Validation.calculated && sha256RegionCalc) {
                        sha256Validation.calculated = sha256RegionCalc;
                    }
                }

                let html = '';

                if (image.error) {
                    html += `<div class="error" style="margin-bottom: 15px;"><strong>âš ï¸ Parsing Error:</strong> ${image.error}</div>`;
                }

                //html += '<div class="success">Bootloader parsed successfully</div>';

                html += '<h4 style="margin-top: 15px;">Basic Information</h4>';
                html += '<div class="info-grid">';
                html += `<div class="info-item"><label>Flash Offset:</label><span class="mono">${fmtHex(offset, 4)}</span></div>`;
                html += `<div class="info-item"><label>Magic:</label><span class="mono">${fmtHex(image.magic, 2)}</span></div>`;
                html += `<div class="info-item"><label>Segment Count:</label><span>${fmtText(image.segmentCount)}</span></div>`;
                html += `<div class="info-item"><label>Entry Address:</label><span class="mono">${fmtHex(image.entryAddr, 8)}</span></div>`;
                html += `<div class="info-item"><label>Chip:</label><span>${fmtText(image.chipName, 'Unknown')} (${fmtHex(image.chipId, 4)})</span></div>`;
                html += '</div>';

                html += '<h4 style="margin-top: 15px;">Flash Configuration</h4>';
                html += '<div class="info-grid">';
                html += `<div class="info-item"><label>SPI Mode:</label><span>${fmtText(image.spiModeName, 'Unknown')} (${fmtText(image.spiMode, 'n/a')})</span></div>`;
                html += `<div class="info-item"><label>SPI Speed:</label><span>${fmtText(image.spiSpeedName, 'Unknown')}</span></div>`;
                html += `<div class="info-item"><label>Flash Size:</label><span>${fmtText(image.spiSizeName, 'Unknown')}</span></div>`;
                html += `<div class="info-item"><label>WP Pin:</label><span>${image.wpPinDisabled ? 'Disabled (0xEE)' : fmtHex(image.wpPin, 2)}</span></div>`;
                html += '</div>';

                // App Description (if found)
                if (image.appDesc && image.appDesc.found) {
                    html += '<h4 style="margin-top: 15px;">Application Description</h4>';
                    html += '<div class="info-grid">';
                    if (image.appDesc.projectName) {
                        html += `<div class="info-item"><label>Project Name:</label><span>${image.appDesc.projectName}</span></div>`;
                    }
                    if (image.appDesc.version) {
                        html += `<div class="info-item"><label>Version:</label><span>${image.appDesc.version}</span></div>`;
                    }
                    if (image.appDesc.idfVer) {
                        html += `<div class="info-item"><label>ESP-IDF Version:</label><span>${image.appDesc.idfVer}</span></div>`;
                    }
                    html += `<div class="info-item"><label>Secure Version:</label><span>${image.appDesc.secureVersion}</span></div>`;
                    if (image.appDesc.date && image.appDesc.time) {
                        html += `<div class="info-item"><label>Build Date/Time:</label><span>${image.appDesc.date} ${image.appDesc.time}</span></div>`;
                    }
                    if (image.appDesc.appElfSha256) {
                        html += `<div class="info-item" style="grid-column: 1 / -1;"><label>App ELF SHA256:</label><span class="mono" title="Reference only - ELF file not available for validation">${image.appDesc.appElfSha256} <span style="color: #9a9a9a;">â„¹ï¸</span></span></div>`;
                    }
                    html += '</div>';
                }

                /* Calculate expected checksum */
                let calculatedChecksum = null;
                let checksumMismatch = false;
                try {
                    const checksumInfo = await parser.calculateImageChecksum(image.offset);
                    calculatedChecksum = checksumInfo.checksum;
                    checksumMismatch = (checksumInfo.checksum !== image.checksum);
                } catch (e) {
                    console.warn('Could not calculate checksum:', e.message);
                }

                html += '<h4 style="margin-top: 15px;">Validation</h4>';
                html += '<div class="info-grid">';

                /* Checksum display */
                const checksumColor = checksumMismatch ? '#e88888' : '#6ec589';
                const checksumIcon = checksumMismatch ? 'âœ—' : 'âœ“';
                html += `<div class="info-item"><label>Checksum:</label><span class="mono" style="color: ${checksumColor};">0x${(image.checksum || 0).toString(16).toUpperCase().padStart(2, '0')} ${checksumIcon}</span></div>`;
                if (checksumMismatch && calculatedChecksum !== null) {
                    html += `<div class="info-item"><label>Checksum (calculated):</label><span class="mono">0x${calculatedChecksum.toString(16).toUpperCase().padStart(2, '0')}</span></div>`;
                }
                html += `<div class="info-item"><label>Hash Appended:</label><span>${image.hasHash ? 'Yes' : 'No'}</span></div>`;

                /* SHA256 display */
                const sha256Match = image.sha256 && sha256RegionCalc && image.sha256.toLowerCase() === sha256RegionCalc.toLowerCase();
                const sha256Valid = sha256Validation && sha256Validation.valid === true;
                const sha256Invalid = sha256Validation && sha256Validation.valid === false;
                const sha256Color = sha256Valid ? '#6ec589' : sha256Invalid ? '#e88888' : '#9a9a9a';
                const sha256Icon = sha256Valid ? 'âœ“' : sha256Invalid ? 'âœ—' : 'â³';

                if (image.sha256) {
                    html += `<div class="info-item" style="grid-column: 1 / -1;"><label>SHA256:</label><span class="mono" style="color: ${sha256Color};">${image.sha256} ${sha256Icon}</span></div>`;
                    if (sha256Invalid && sha256RegionCalc) {
                        html += `<div class="info-item" style="grid-column: 1 / -1;"><label>SHA256 (calculated):</label><span class="mono">${sha256RegionCalc}</span></div>`;
                    }
                }
                if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined) {
                    const regionLen = image.sha256DataEnd - image.sha256DataStart;
                    html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Hash region:</label><span class="mono">0x${image.sha256DataStart.toString(16).toUpperCase()} - 0x${image.sha256DataEnd.toString(16).toUpperCase()} (${regionLen} bytes)</span></div>`;
                }

                html += '</div>';
                html += '<h4 style="margin-top: 15px;">Segments</h4>';
                html += '<table><thead><tr><th>#</th><th>Load Address</th><th>Length</th><th>Offset</th></tr></thead><tbody>';
                const segments = Array.isArray(image.segmentList) ? image.segmentList : [];
                segments.forEach((seg, sidx) => {
                    html += '<tr>';
                    html += `<td>${sidx}</td>`;
                    html += `<td class="mono">${fmtHex(seg.loadAddress, 8)}</td>`;
                    html += `<td>${formatBytes(seg.length || 0)}</td>`;
                    html += `<td class="mono">${fmtHex(seg.offset)}</td>`;
                    html += '</tr>';
                });
                html += '</tbody></table>';

                html += '<h4 style="margin-top: 15px;">Actions</h4>';
                html += '<div style="display: flex; gap: 10px; flex-wrap: wrap;">';
                html += '<button class="hex-btn" onclick="viewPartitionHex(-1)">Hex View</button>';
                html += '<button class="download-btn" onclick="downloadPartition(-1)">Download</button>';
                html += '<button class="replace-btn" onclick="replaceBootloader()">Replace</button>';
                html += '<button class="replace-btn" onclick="clearBootloader()">Clear</button>';
                if (checksumMismatch) {
                    html += '<button class="btn" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);" onclick="fixChecksums(\'bootloader\')">Fix Checksums</button>';
                }
                html += '</div>';

                contentDiv.innerHTML = html;

                // Find bootloader end (where 0xFF padding starts)
                let bootloaderEnd = Number.isFinite(image.endOffset) ? image.endOffset : 0;
                // Scan forward from endOffset to find where 0xFF padding begins
                // Limit scan to actual file size
                const actualSize = parser.sparseImage.size;
                const scanLimit = Math.min(maxBootloaderLength, actualSize);
                const scanSize = 256; // Check in 256-byte blocks
                for (let pos = bootloaderEnd; pos < scanLimit; pos += scanSize) {
                    let allFF = true;
                    const checkLen = Math.min(scanSize, scanLimit - pos);
                    for (let i = 0; i < checkLen; i++) {
                        if ((await parser.view.getUint8(pos + i)) !== 0xFF) {
                            allFF = false;
                            bootloaderEnd = pos + i + 1;
                            break;
                        }
                    }
                    if (allFF) {
                        // Found start of 0xFF region, bootloader ends here
                        break;
                    }
                }

                image.bootloaderStart = partition.offset;
                image.bootloaderEnd = bootloaderEnd;

                /* Auto-apply detected flash size in device mode */
                if (deviceMode && image.spiSizeName) {
                    /* Extract flash size from spiSizeName (e.g., "2 MiB", "4 MiB") */
                    const flashSizeMatch = image.spiSizeName.match(/(\d+)\s*([KMG]i?B)/i);
                    if (flashSizeMatch) {
                        let sizeBytes = parseInt(flashSizeMatch[1], 10);
                        const unit = flashSizeMatch[2].toUpperCase();

                        if (unit === 'KIB' || unit === 'KB') sizeBytes *= 1024;
                        else if (unit === 'MIB' || unit === 'MB') sizeBytes *= 1024 * 1024;
                        else if (unit === 'GIB' || unit === 'GB') sizeBytes *= 1024 * 1024 * 1024;

                        if (sizeBytes > 0 && sizeBytes !== deviceFlashSizeBytes) {
                            console.log(`Detected flash size from bootloader: ${image.spiSizeName} (${sizeBytes} bytes)`);
                            await applyDeviceFlashSize(sizeBytes);
                        }
                    }
                }

                return image;
            } catch (error) {
                console.error('Bootloader parsing error:', error);
                contentDiv.innerHTML = `<div class="error">Error parsing bootloader: ${error.message}</div>`;
                return null;
            }
        }

        async function displayPartitions() {
            const content = document.getElementById('partitionsContent');
            const partitions = parser.partitions;

            if (partitions.length === 0) {
                content.innerHTML = '<div class="error">No partitions found in this firmware image.</div>';
                return;
            }

            // Parse OTA data to determine boot partition
            let bootPartitionSubType = null;
            const otaDataPartition = partitions.find(p => p.type === 1 && p.subType === 0x00);
            if (otaDataPartition) {
                try {
                    const otaResult = (await parser.parseOTAData(otaDataPartition)).otaInfo;
                    if (otaResult.activeEntry !== null) {
                        const active = otaResult.entries[otaResult.activeEntry];
                        // Count OTA partitions
                        const otaPartitions = partitions.filter(p => p.type === 0 && p.subType >= 0x10 && p.subType <= 0x1F);
                        const otaCount = otaPartitions.length;
                        if (otaCount > 0) {
                            // Calculate boot slot: (ota_seq - 1) % ota_app_count
                            const bootSlot = (active.sequence - 1) % otaCount;
                            // OTA partition subType = 0x10 + slot number
                            bootPartitionSubType = 0x10 + bootSlot;
                        }
                    }
                } catch (error) {
                    console.error('Error parsing OTA data for boot partition:', error);
                }
            }

            let html = '';
            if (partitionTableOffset !== null) {
                html += '<div class="info-grid" style="margin-bottom: 20px;">';
                html += `<div class="info-item"><label>Flash Offset:</label><span class="mono">0x${partitionTableOffset.toString(16).toUpperCase().padStart(4, '0')}</span></div>`;
                html += '</div>';
            }
            html += '<table><thead><tr>';
            html += '<th>#</th><th>Label</th><th>Type</th><th>Offset</th><th>End Offset</th><th>Size</th><th>Actions</th>';
            html += '</tr></thead><tbody>';

            for (let idx = 0; idx < partitions.length; idx++) {
                const part = partitions[idx];
                const badgeClass = part.type === 0 ? 'app' : 'data';

                // Check if APP partition has valid magic and boot status
                let magicIndicator = '';
                if (part.type === 0) { // APP partition
                    const hasValidMagic = await parser.hasValidImageMagic(part);
                    if (hasValidMagic) {
                        magicIndicator = '<span style="color: #6ec589; font-size: 1.1em; margin-left: 5px;" title="Valid ESP32 image magic (0xE9)">âœ“</span>';
                    } else {
                        magicIndicator = '<span style="color: #e88888; font-size: 1.1em; margin-left: 5px;" title="Invalid or missing ESP32 image magic">âœ—</span>';
                    }

                    // Mark boot partition
                    if (bootPartitionSubType !== null && part.subType === bootPartitionSubType) {
                        magicIndicator += '<span style="color: #ffd700; font-weight: bold; margin-left: 5px; background: #3d3d1f; padding: 2px 6px; border-radius: 3px;" title="This partition will boot according to OTA data">[BOOT]</span>';
                    } else if (part.subType === 0x00 && bootPartitionSubType === null) {
                        // Factory partition with no OTA data
                        magicIndicator += '<span style="color: #ffd700; font-weight: bold; margin-left: 5px; background: #3d3d1f; padding: 2px 6px; border-radius: 3px;" title="Factory partition (default boot)">[BOOT]</span>';
                    }
                }

                html += `<tr class="expandable" onclick="togglePartitionDetails(${idx})">`;
                html += `<td>${part.num}</td>`;
                html += `<td><strong>${part.label}${magicIndicator}</strong></td>`;
                html += `<td><span class="badge ${badgeClass}">${part.typeName}</span></td>`;
                html += `<td class="mono">0x${part.offset.toString(16).toUpperCase().padStart(6, '0')}</td>`;
                html += `<td class="mono">0x${(part.offset + part.length).toString(16).toUpperCase().padStart(6, '0')}</td>`;
                html += `<td>${formatBytes(part.length)}</td>`;
                html += `<td>
                    <button class="hex-btn" onclick="event.stopPropagation(); viewPartitionHex(${idx})">Hex View</button>
                    <button class="download-btn" onclick="event.stopPropagation(); downloadPartition(${idx})">Download</button>
                    <button class="replace-btn" onclick="event.stopPropagation(); replacePartition(${idx})">Replace</button>
                    <button class="replace-btn" onclick="event.stopPropagation(); clearPartition(${idx})">Clear</button>
                </td>`;
                html += '</tr>';

                // Details row
                html += `<tr class="details-row" id="details-${idx}">`;
                html += `<td colspan="7"><div class="details-content">`;
                html += `<div class="details-grid">`;
                html += `<div class="detail-item"><strong>Type Code:</strong> 0x${part.type.toString(16).toUpperCase()}</div>`;
                html += `<div class="detail-item"><strong>SubType Code:</strong> 0x${part.subType.toString(16).toUpperCase()}</div>`;
                html += `<div class="detail-item"><strong>Offset (decimal):</strong> ${part.offset}</div>`;
                html += `<div class="detail-item"><strong>Size (decimal):</strong> ${part.length} bytes</div>`;
                html += `<div class="detail-item"><strong>End Offset:</strong> 0x${(part.offset + part.length).toString(16).toUpperCase()}</div>`;

                // Add parse buttons for specific partition types
                if (part.subType === 0x02) { // NVS
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseNVSPartition(${idx})">Parse NVS</button></div>`;
                } else if (part.subType === 0x00 && part.type === 1) { // OTA data
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseOTADataPartition(${idx})">Parse OTA Data</button></div>`;
                } else if (part.type === 0) { // APP
                    html += `<div class="detail-item">
                        <button class="btn" onclick="event.stopPropagation(); parseImagePartitionInline(${idx})">Parse Image</button>
                        <button class="btn" id="save_ota_${idx}" onclick="event.stopPropagation(); downloadOTAImage(${idx})">Save OTA Image</button>
                        <button class="btn" id="fix_check_${idx}" style="display: none; background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); cursor: pointer;" onclick="event.stopPropagation(); (async () => { await fixChecksums('ota', ${part.offset}, ${part.length}); parseImagePartitionInline(${idx}); })();">Fix Checksums</button>
                        </div>`;
                } else if (part.subType === 0x81) { // FAT
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseFATPartition(${idx})">Parse FAT</button></div>`;
                } else if (part.subType === 0x82) { // SPIFFS
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseSPIFFSPartition(${idx})">Parse SPIFFS</button></div>`;
                }
                //html += `<div class="detail-item" style="grid-column: 1 / -1;"><strong>SHA-1:</strong> <span class="mono">${part.sha1 || 'n/a'}</span></div>`;

                html += `</div>`;

                // Add content area for inline parsed data
                html += `<div id="parsed-content-${idx}" style="margin-top: 15px;"></div>`;

                html += `</div></td></tr>`;
            }

            html += '</tbody></table>';
            content.innerHTML = html;
        }

        function replacePartition(idx) {
            if (!parser || !parser.partitions || !parser.partitions[idx]) {
                alert('Partition not found.');
                return;
            }
            const part = parser.partitions[idx];
            const start = part.offset;
            const length = part.length;

            showImportPopup(start, length, false, async () => {
                try {
                    console.log(`Replaced partition ${idx}, refreshing view...`);
                    if (!deviceMode) {
                        part.sha1 = await parser.computePartitionSHA1(part);
                    }
                    await displayPartitions();
                    const parsedContent = document.getElementById('parsed-content-' + idx);
                    if (parsedContent) {
                        parsedContent.innerHTML = '';
                    }
                    const rawTab = document.querySelector('.tab.active');
                    if (rawTab && rawTab.textContent.toLowerCase().includes('raw')) {
                        await updateHexView();
                    }
                    await updateMemoryMap();
                } catch (err) {
                    console.error('Post-import refresh error:', err);
                }
            });
        }

        function replaceBootloader() {
            if (!parser || !bootloaderInfo || bootloaderInfo.bootloaderStart === undefined || bootloaderInfo.bootloaderEnd === undefined) {
                alert('Bootloader not parsed correctly. Cannot replace bootloader.');
                return;
            }

            const start = bootloaderInfo.bootloaderStart;
            const length = bootloaderInfo.bootloaderEnd - bootloaderInfo.bootloaderStart;

            showImportPopup(start, length, false, async () => {
                try {
                    await parseBootloader();
                    updateMemoryMap();
                } catch (err) {
                    console.error('Post-import bootloader refresh error:', err);
                }
            });
        }

        async function clearBootloader() {
            if (!parser) {
                alert('No firmware file loaded.');
                return;
            }

            try {
                const start = 0;
                // Use same size calculation as download
                let length;
                if (bootloaderInfo && bootloaderInfo.bootloaderEnd) {
                    length = bootloaderInfo.bootloaderEnd;
                } else {
                    length = partitionTableOffset || 0x8000;
                }
                const end = start + length;

                if (end > parser.sparseImage.size) {
                    alert('Bootloader region exceeds firmware image size.');
                    return;
                }

                /* Fill bootloader with 0xFF */
                parser.sparseImage.fill(0xFF, start, end);

                if (!deviceMode) {
                    /* Recompute bootloader in file mode */
                    await parseBootloader();
                }

                updateMemoryMap();
            } catch (err) {
                console.error('Error clearing bootloader:', err);
                alert('Error clearing bootloader: ' + err.message);
            }
        }

        async function fixChecksums(imageType = null, otaOffset = null, otaLength = null) {
            if (!parser) {
                setDeviceStatus('No firmware file loaded', 'error');
                return;
            }

            try {
                setDeviceStatus('Fixing checksums...', 'info');
                const result = await parser.fixAllChecksums(imageType, otaOffset, otaLength);

                let statusParts = [];

                if (result.bootloader) {
                    if (result.bootloader.fixed) {
                        const fixes = [];
                        if (result.bootloader.checksumFixed) {
                            fixes.push(`checksum fixed`);
                        }
                        if (result.bootloader.sha256Fixed) {
                            fixes.push(`SHA256 fixed`);
                        }
                        statusParts.push(`Bootloader: ${fixes.join(', ')}`);
                    }
                }
                if (result.otaApp) {
                    if (result.otaApp.fixed) {
                        const fixes = [];
                        if (result.otaApp.checksumFixed) {
                            fixes.push(`checksum fixed`);
                        }
                        if (result.otaApp.sha256Fixed) {
                            fixes.push(`SHA256 fixed`);
                        }
                        statusParts.push(`OTA app: ${fixes.join(', ')}`);
                    }
                }

                updateMemoryMap();
                await parseBootloader();

                if (statusParts.length > 0) {
                    setDeviceStatus(statusParts.join(' | '), 'success');
                } else {
                    setDeviceStatus('Already valid, no fixes needed', 'success');
                }
            } catch (err) {
                console.error('Error fixing checksums:', err);
                setDeviceStatus('Error fixing checksums: ' + err.message, 'error');
                setDeviceStatus('Failed to fix checksums', 'error');
            }
        }

        async function clearPartition(idx) {
            if (!parser) {
                alert('No firmware file loaded.');
                return;
            }

            const part = parser.partitions[idx];
            if (!part) {
                alert('Partition not found.');
                return;
            }

            try {
                const start = part.offset;
                const end = start + part.length;

                const totalSize = parser.sparseImage.size;
                if (end > totalSize) {
                    alert('Partition range exceeds firmware image size.');
                    return;
                }

                // Fill partition with 0xFF
                parser.sparseImage.fill(0xFF, start, end);

                if (!deviceMode) {
                    part.sha1 = await parser.computePartitionSHA1(part);
                }

                await displayPartitions();

                const parsedContent = document.getElementById('parsed-content-' + idx);
                if (parsedContent) {
                    parsedContent.innerHTML = '';
                }

                const rawTab = document.querySelector('.tab.active');
                if (rawTab && rawTab.textContent.toLowerCase().includes('raw')) {
                    updateHexView();
                }

                updateMemoryMap();
            } catch (err) {
                console.error('Error clearing partition:', err);
                alert('Error clearing partition: ' + err.message);
            }
        }

        function handlePartitionReplaceFile(file, idx) {
            if (!parser) {
                alert('No firmware file loaded.');
                return;
            }

            /* Handle bootloader (-1) and regular partitions */
            let part;
            if (idx === -1) {
                // Only allow if bootloader was successfully parsed
                if (!bootloaderInfo || bootloaderInfo.bootloaderStart === undefined || bootloaderInfo.bootloaderEnd === undefined) {
                    alert('Bootloader not parsed correctly. Cannot replace bootloader.');
                    return;
                }
                const bootloaderStart = bootloaderInfo.bootloaderStart;
                const bootloaderLength = bootloaderInfo.bootloaderEnd - bootloaderInfo.bootloaderStart;
                part = { label: 'bootloader', offset: bootloaderStart, length: bootloaderLength };
            } else {
                part = parser.partitions[idx];
                if (!part) {
                    alert('Partition not found.');
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = async function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    if (data.length > part.length) {
                        alert('Selected file is larger than the partition size.');
                        return;
                    }

                    const start = part.offset;
                    const end = start + part.length;

                    const totalSize = parser.sparseImage.size;
                    if (end > totalSize) {
                        alert('Partition range exceeds firmware image size.');
                        return;
                    }

                    parser.sparseImage.fill(0xFF, start, end);
                    parser.sparseImage.write(start, data);

                    if (!deviceMode && idx !== -1) {
                        part.sha1 = await parser.computePartitionSHA1(part);
                    }

                    /* Refresh bootloader or partitions */
                    if (idx === -1) {
                        await parseBootloader();
                    } else {
                        await displayPartitions();
                    }

                    const parsedContent = document.getElementById('parsed-content-' + idx);
                    if (parsedContent) {
                        parsedContent.innerHTML = '';
                    }

                    const rawTab = document.querySelector('.tab.active');
                    if (rawTab && rawTab.textContent.toLowerCase().includes('raw')) {
                        updateHexView();
                    }

                    updateMemoryMap();
                } catch (err) {
                    console.error('Error replacing partition:', err);
                    alert('Error replacing partition: ' + err.message);
                } finally {
                    replaceTargetPartition = null;
                    const inputEl = document.getElementById('partitionFileInput');
                    if (inputEl) {
                        inputEl.value = '';
                    }
                }
            };
            reader.onerror = function () {
                alert('Failed to read the selected file.');
            };
            reader.readAsArrayBuffer(file);
        }

        async function saveImage() {
            if (!parser || !parser.sparseImage) {
                alert('No firmware image loaded.');
                return;
            }

            showFetchOverlay('Preparing image download...');
            try {
                const data = await parser.sparseImage.slice_async(0, parser.sparseImage.size);
                const blob = new Blob([data], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // Generate meaningful filename
                let filename;
                if (deviceMode && deviceFlasher) {
                    // Device mode: use chip type and MAC
                    const chipName = deviceFlasher.current_chip || 'esp32';
                    const macPart = deviceMac ? '_' + deviceMac.replace(/:/g, '') : '';
                    filename = `${chipName}${macPart}_dump.bin`;
                } else if (currentFile && currentFile.name) {
                    // File mode: use original filename as base
                    const baseName = currentFile.name.replace(/\.bin$/i, '');
                    filename = `${baseName}_modified.bin`;
                } else {
                    // Fallback
                    filename = 'firmware_modified.bin';
                }
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                alert('Error preparing image: ' + error.message);
            } finally {
                hideFetchOverlay();
            }
        }

        async function eraseFlash() {
            if (!parser || !parser.sparseImage) {
                alert('No device connected or firmware loaded.');
                return;
            }

            try {
                setDeviceStatus('Erasing flash...', 'loading');
                const deviceSize = parser.sparseImage.size;
                // Clear existing write buffers first, then fill with 0xFF
                parser.sparseImage.writeBuffer = [];
                parser.sparseImage.fill(0xFF, 0, deviceSize);
                await parseAndDisplay(true);
                setDeviceStatus('Flash erased (ready to write)', 'success');
            } catch (error) {
                console.error('Erase error:', error);
                setDeviceStatus('Erase failed: ' + error.message, 'error');
                alert('Error erasing flash: ' + error.message);
            }
        }

        async function writeToDevice() {
            if (!deviceFlasher || !deviceMode) {
                alert('No device connected.');
                return;
            }

            if (!parser || !parser.sparseImage) {
                alert('No firmware image loaded.');
                return;
            }

            // Check if there are any pending writes
            if (!parser.sparseImage.writeBuffer || parser.sparseImage.writeBuffer.length === 0) {
                alert('No changes to write. Please modify partitions first.');
                return;
            }

            const writeCount = parser.sparseImage.writeBuffer.length;
            const totalBytes = parser.sparseImage.writeBuffer.reduce((sum, seg) => sum + seg.data.length, 0);

            showWriteOverlay('Writing modified segments...');

            try {
                setDeviceStatus('Writing modified segments to device...', 'loading');
                updateWriteOverlayProgress(0, 0, totalBytes);
                await parser.sparseImage.flush();
            } catch (error) {
                console.error('Write error:', error);
                setDeviceStatus('Write failed: ' + error.message, 'error');
                alert('Error writing to device: ' + error.message);
            } finally {
                hideWriteOverlay();
            }

            await updateMemoryMap();
        }

        /* Import binary file functions */
        let importFile = null;
        let importIsJson = false;
        let importJsonData = null;
        let importBaseUrl = null; // For resolving relative paths in JSON manifests
        let importRangeStart = 0;
        let importRangeLength = 0;
        let importAddressEditable = true;
        let importCallback = null;

        function switchImportTab(tab) {
            const tabs = document.querySelectorAll('.import-tab');
            const contents = document.querySelectorAll('.import-tab-content');

            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));

            if (tab === 'file') {
                tabs[0].classList.add('active');
                document.getElementById('importTabFile').classList.add('active');
            } else {
                tabs[1].classList.add('active');
                document.getElementById('importTabUrl').classList.add('active');
            }
        }

        async function loadImportUrl() {
            const urlInput = document.getElementById('importUrlInput');
            const url = urlInput.value.trim();

            if (!url) {
                alert('Please enter a URL');
                return;
            }

            try {
                setDeviceStatus('Downloading from URL...', 'loading');
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const blob = await response.blob();
                const filename = url.split('/').pop() || 'download.bin';
                importFile = new File([blob], filename, { type: blob.type });

                const fileNameSpan = document.getElementById('importFileName');
                if (fileNameSpan) fileNameSpan.textContent = importFile.name + ' (from URL)';

                // Check if JSON
                if (filename.toLowerCase().endsWith('.json') || blob.type.includes('json')) {
                    // Store base URL for resolving relative paths
                    const urlParts = url.split('/');
                    urlParts.pop(); // Remove filename
                    importBaseUrl = urlParts.join('/');
                    await handleJsonManifest(importFile);
                } else {
                    importBaseUrl = null;
                    updateImportPreview();
                }

                setDeviceStatus('URL loaded successfully', 'success');
            } catch (error) {
                console.error('URL load error:', error);

                // Check if it's a CORS error
                if (error.message.includes('CORS') || error.message.includes('cross-origin') ||
                    error.name === 'TypeError' && !error.message.includes('HTTP')) {
                    const corsMsg = 'CORS Error: The server does not allow cross-origin requests.\n\n' +
                        'The server at this URL has not enabled CORS (Cross-Origin Resource Sharing).\n' +
                        'To fix this, either:\n' +
                        '  â€¢ Download the files manually and use the File tab\n' +
                        '  â€¢ Ask the server administrator to enable CORS\n' +
                        '  â€¢ Use a CORS proxy service\n' +
                        '  â€¢ Run Edge with security disabled:\n' +
                        '    msedge.exe --user-data-dir=C:\\temp\\msedge-dev-data\\ --disable-web-security';
                    setDeviceStatus('CORS blocked: Server does not allow cross-origin requests', 'error');
                    alert(corsMsg);
                } else {
                    setDeviceStatus('Failed to load URL: ' + error.message, 'error');
                    alert('Error loading URL: ' + error.message);
                }
            }
        }

        async function handleJsonManifest(file) {
            try {
                const text = await file.text();
                const manifest = JSON.parse(text);

                // Detect manifest format and normalize to common structure
                let flashEntries = [];
                let manifestType = '';
                let availableBuilds = [];

                if (manifest.flash && Array.isArray(manifest.flash)) {
                    // Format 1: { flash: [ { url, address } ] }
                    manifestType = 'esptool';
                    flashEntries = manifest.flash.map(entry => ({
                        url: entry.url,
                        address: entry.address ? parseInt(entry.address, 16) : 0,
                        path: entry.url,
                        isApp: entry.app || false
                    }));
                } else if (manifest.builds && Array.isArray(manifest.builds) && manifest.builds.length > 0) {
                    // Format 2: { builds: [ { chipFamily, parts: [], ota: {} } ] }
                    manifestType = 'esp-web-tools';

                    // Collect available builds
                    availableBuilds = manifest.builds.map((build, idx) => ({
                        chipFamily: build.chipFamily || `Build ${idx + 1}`,
                        index: idx
                    }));

                    // Try to auto-select build based on connected device chip
                    let selectedBuildIdx = 0;
                    if (deviceFlasher && deviceFlasher.current_chip) {
                        const deviceChip = deviceFlasher.current_chip.toUpperCase();
                        const matchIdx = manifest.builds.findIndex(build => {
                            const chipFam = (build.chipFamily || '').toUpperCase();
                            return chipFam.includes(deviceChip) || deviceChip.includes(chipFam);
                        });
                        if (matchIdx >= 0) selectedBuildIdx = matchIdx;
                    }

                    const build = manifest.builds[selectedBuildIdx];

                    // Collect parts
                    if (build.parts && Array.isArray(build.parts)) {
                        flashEntries = build.parts.map(part => ({
                            path: part.path,
                            url: part.path,
                            address: part.offset || 0,
                            isApp: false
                        }));
                    }

                    // Add OTA file if present (usually for OTA updates, not initial flash)
                    // But we'll include it at offset 0 if no parts exist
                    if (build.ota && build.ota.path) {
                        if (flashEntries.length === 0) {
                            // No parts, use OTA file at offset 0
                            flashEntries.push({
                                path: build.ota.path,
                                url: build.ota.path,
                                address: 0,
                                isApp: true
                            });
                        }
                    }
                } else {
                    throw new Error('Invalid manifest: missing "flash" or "builds" array');
                }

                if (flashEntries.length === 0) {
                    throw new Error('No flash entries found in manifest');
                }

                importIsJson = true;
                importJsonData = { ...manifest, flashEntries, manifestType, availableBuilds };

                // Update preview to show JSON manifest details
                const previewDiv = document.getElementById('importPreview');
                const applyBtn = document.getElementById('importApplyBtn');
                const addressInput = document.getElementById('importAddress');

                // Hide address input for JSON manifests
                if (addressInput && addressInput.parentElement) {
                    addressInput.parentElement.style.display = 'none';
                }

                // Show erase flash option for JSON manifests
                const eraseOption = document.getElementById('importEraseOption');
                if (eraseOption) {
                    eraseOption.style.display = 'block';
                }

                let html = `<div style="line-height: 1.8;">`;
                html += `<strong style="color: #7a8bdc;">JSON Manifest Detected</strong><br>`;
                if (manifest.name) html += `Name: <strong>${manifest.name}</strong><br>`;
                if (manifest.version) html += `Version: <strong>${manifest.version}</strong><br>`;
                if (manifest.chip) html += `Chip: <strong>${manifest.chip}</strong><br>`;

                // Show selected build info
                if (availableBuilds.length > 0) {
                    const selectedBuild = manifest.builds[0]; // We used index 0 above after auto-selection
                    html += `Build: <strong>${selectedBuild.chipFamily || 'Unknown'}</strong>`;
                    if (availableBuilds.length > 1) {
                        html += ` <span style="color: #888; font-size: 0.9em;">(${availableBuilds.length} builds available)</span>`;
                    }
                    html += `<br>`;
                }

                html += `<br><strong>Flash Entries (${flashEntries.length}):</strong><br>`;

                for (let i = 0; i < flashEntries.length; i++) {
                    const entry = flashEntries[i];
                    const addr = `0x${entry.address.toString(16).toUpperCase()}`;
                    const filename = entry.path.split('/').pop();
                    html += `${i + 1}. ${addr}: ${filename}`;
                    if (entry.isApp) html += ` <span style="color: #ffa726;">(app)</span>`;
                    html += `<br>`;
                }

                html += `</div>`;
                previewDiv.innerHTML = html;

                if (applyBtn) applyBtn.disabled = false;

            } catch (error) {
                console.error('JSON parse error:', error);
                alert('Error parsing JSON manifest: ' + error.message);
                importIsJson = false;
                importJsonData = null;
            }
        }

        function showImportPopup(startAddr = 0, length = deviceFlashSizeBytes, addressEditable = true, onImported = null) {
            importRangeStart = startAddr;
            importRangeLength = length;
            importAddressEditable = !!addressEditable;
            importCallback = onImported;

            console.log(`Showing import popup: start=0x${startAddr.toString(16)}, length=${length}, editable=${importAddressEditable}, callback=${importCallback ? 'yes' : 'no'}`);

            const popup = document.getElementById('importPopup');
            const addressInput = document.getElementById('importAddress');
            if (addressInput) {
                addressInput.value = '0x' + importRangeStart.toString(16).toUpperCase();
                addressInput.parentElement.style.display = importAddressEditable ? 'block' : 'none';
            }
            if (popup) {
                popup.style.display = 'flex';
                updateImportPreview();
            }
        }

        function hideImportPopup() {
            const popup = document.getElementById('importPopup');
            if (popup) {
                popup.style.display = 'none';
            }
            importFile = null;
            importIsJson = false;
            importJsonData = null;
            importBaseUrl = null;
            importRangeStart = 0;
            importRangeLength = 0;
            importAddressEditable = true;
            importCallback = null;
            const fileNameSpan = document.getElementById('importFileName');
            if (fileNameSpan) fileNameSpan.textContent = 'None';
            const applyBtn = document.getElementById('importApplyBtn');
            if (applyBtn) applyBtn.disabled = true;
            const addressInput = document.getElementById('importAddress');
            if (addressInput && addressInput.parentElement) {
                addressInput.parentElement.style.display = 'block';
            }
            const eraseOption = document.getElementById('importEraseOption');
            if (eraseOption) {
                eraseOption.style.display = 'none';
            }
            /* Reset file inputs to allow re-selecting the same file */
            const importFileInput = document.getElementById('importFileInput');
            if (importFileInput) {
                importFileInput.value = '';
            }
            const importUrlInput = document.getElementById('importUrlInput');
            if (importUrlInput) {
                importUrlInput.value = '';
            }
        }

        function updateImportPreview() {
            const previewDiv = document.getElementById('importPreview');
            const applyBtn = document.getElementById('importApplyBtn');
            const addressInput = document.getElementById('importAddress');

            if (!importFile || !addressInput || !previewDiv) {
                if (previewDiv) previewDiv.innerHTML = 'Select a file and enter an address to see preview';
                if (applyBtn) applyBtn.disabled = true;
                return;
            }

            const allowedStart = importRangeStart;
            const allowedEnd = importRangeStart + importRangeLength;

            let addressStr = addressInput.value.trim();
            if (!importAddressEditable) {
                addressStr = '0x' + allowedStart.toString(16).toUpperCase();
                addressInput.value = addressStr;
            }

            let address;
            try {
                address = parseInt(addressStr, 16);
                if (isNaN(address) || address < 0) {
                    throw new Error('Invalid address');
                }
            } catch (e) {
                previewDiv.innerHTML = '<span style="color: #ff6b6b;">Invalid address format. Use hex format like 0x10000</span>';
                if (applyBtn) applyBtn.disabled = true;
                return;
            }

            const fileSize = importFile.size;
            const endAddress = address + fileSize;
            const deviceSize = parser.sparseImage ? parser.sparseImage.size : deviceFlashSizeBytes;

            let html = `<div style="line-height: 1.8;">`;
            html += `File: <strong>${importFile.name}</strong><br>`;
            html += `Size: <strong>${formatBytes(fileSize)}</strong> (${fileSize} bytes)<br>`;
            html += `Start: <strong>0x${address.toString(16).toUpperCase()}</strong><br>`;
            html += `End: <strong>0x${endAddress.toString(16).toUpperCase()}</strong><br>`;
            html += `Allowed: <strong>0x${allowedStart.toString(16).toUpperCase()} - 0x${allowedEnd.toString(16).toUpperCase()}</strong><br>`;

            // Check if it fits in device flash
            if (endAddress > deviceSize) {
                html += `<br><span style="color: #ff6b6b;">âš ï¸ Warning: File extends beyond device flash size (0x${deviceSize.toString(16).toUpperCase()})</span>`;
                if (applyBtn) applyBtn.disabled = true;
            } else if (address < allowedStart || endAddress > allowedEnd) {
                html += `<br><span style="color: #ff6b6b;">âš ï¸ Warning: File exceeds allowed range</span>`;
                if (applyBtn) applyBtn.disabled = true;
            } else {
                // Check which partitions will be affected
                const affectedPartitions = [];
                if (parser.partitions) {
                    for (const part of parser.partitions) {
                        const partStart = part.offset;
                        const partEnd = part.offset + part.length;
                        // Check if ranges overlap
                        if (address < partEnd && endAddress > partStart) {
                            affectedPartitions.push(part.label);
                        }
                    }
                }

                if (affectedPartitions.length > 0) {
                    html += `<br>Affected partitions: <strong style="color: #ffa726;">${affectedPartitions.join(', ')}</strong>`;
                } else {
                    html += `<br><span style="color: #7a8bdc;">Will write to unpartitioned area</span>`;
                }

                if (applyBtn) applyBtn.disabled = false;
            }
            html += `</div>`;
            previewDiv.innerHTML = html;
        }

        async function applyImport() {
            if (!parser) {
                return;
            }

            // Handle JSON manifest
            if (importIsJson && importJsonData) {
                try {
                    // Check if erase flash is requested
                    const eraseFlashCheckbox = document.getElementById('importEraseFlash');
                    const shouldEraseFlash = eraseFlashCheckbox && eraseFlashCheckbox.checked;

                    if (shouldEraseFlash) {
                        setDeviceStatus('Erasing flash...', 'loading');
                        const deviceSize = parser.sparseImage ? parser.sparseImage.size : deviceFlashSizeBytes;
                        // Clear existing write buffers first, then fill with 0xFF
                        parser.sparseImage.writeBuffer = [];
                        parser.sparseImage.fill(0xFF, 0, deviceSize);
                        console.log(`Erased flash: 0x0 - 0x${deviceSize.toString(16).toUpperCase()}`);
                    }

                    setDeviceStatus('Downloading and importing manifest files...', 'loading');

                    let importCount = 0;
                    const rangeStart = importRangeStart;
                    const rangeEnd = importRangeStart + importRangeLength;
                    const deviceSize = parser.sparseImage ? parser.sparseImage.size : deviceFlashSizeBytes;
                    for (const entry of importJsonData.flashEntries) {
                        let url = entry.url || entry.path;

                        // Resolve relative URLs
                        if (importBaseUrl && !url.startsWith('http://') && !url.startsWith('https://')) {
                            url = importBaseUrl + '/' + url;
                        }

                        if (!url) {
                            console.warn('Skipping entry without URL:', entry);
                            continue;
                        }

                        console.log(`Downloading ${url} for address 0x${entry.address.toString(16).toUpperCase()}`);

                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`Failed to download ${url}: HTTP ${response.status}`);
                        }

                        const arrayBuffer = await response.arrayBuffer();
                        const data = new Uint8Array(arrayBuffer);

                        const entryStart = entry.address >>> 0;
                        const entryEnd = entryStart + data.length;
                        if (entryEnd > deviceSize) {
                            throw new Error(`Entry at 0x${entryStart.toString(16).toUpperCase()} exceeds device size 0x${deviceSize.toString(16).toUpperCase()}`);
                        }
                        if (entryStart < rangeStart || entryEnd > rangeEnd) {
                            throw new Error(`Entry at 0x${entryStart.toString(16).toUpperCase()} exceeds allowed range 0x${rangeStart.toString(16).toUpperCase()} - 0x${rangeEnd.toString(16).toUpperCase()}`);
                        }

                        // Write data to sparse image
                        await parser.sparseImage.write(entry.address, data);

                        console.log(`Imported ${formatBytes(data.length)} at 0x${entry.address.toString(16).toUpperCase()}`);
                        importCount++;
                    }

                    const didErase = shouldEraseFlash;
                    const eraseMsg = didErase ? ' (flash erased and rebuilt)' : '';
                    setDeviceStatus(`Imported ${importCount} files from manifest${eraseMsg}.`, 'success');

                    if (importCallback) {
                        await importCallback();
                    }

                    hideImportPopup();
                } catch (error) {
                    console.error('Manifest import error:', error);

                    // Check if it's a CORS error
                    if (error.message.includes('CORS') || error.message.includes('cross-origin') ||
                        error.name === 'TypeError' && !error.message.includes('HTTP')) {
                        const corsMsg = 'CORS Error: The server does not allow cross-origin requests.\n\n' +
                            'The server hosting these files has not enabled CORS.\n' +
                            'To fix this, either:\n' +
                            '  â€¢ Download the files manually and import them individually\n' +
                            '  â€¢ Ask the server administrator to enable CORS\n' +
                            '  â€¢ Use a CORS proxy service\n' +
                            '  â€¢ Run Edge with security disabled:\n' +
                            '    msedge.exe --user-data-dir=C:\\temp\\msedge-dev-data\\ --disable-web-security';
                        setDeviceStatus('CORS blocked: Server does not allow cross-origin requests', 'error');
                        alert(corsMsg);
                    } else {
                        setDeviceStatus('Manifest import failed: ' + error.message, 'error');
                        alert('Error importing manifest: ' + error.message);
                    }
                }
                return;
            }

            // Handle single binary file
            if (!importFile) {
                console.error('No import file selected');
                return;
            }

            console.log(`Importing file ${importFile.name}`);

            const addressInput = document.getElementById('importAddress');
            const addressStr = addressInput.value.trim();
            let address;
            try {
                address = parseInt(addressStr, 16);
                if (isNaN(address) || address < 0) {
                    throw new Error('Invalid address');
                }
            } catch (e) {
                alert('Invalid address format. Use hex format like 0x10000');
                return;
            }

            const fileSize = importFile.size;
            const endAddress = address + fileSize;
            const deviceSize = parser.sparseImage ? parser.sparseImage.size : deviceFlashSizeBytes;
            const rangeStart = importRangeStart;
            const rangeEnd = importRangeStart + importRangeLength;

            if (endAddress > deviceSize) {
                alert(`File extends beyond device flash size (0x${deviceSize.toString(16).toUpperCase()})`);
                return;
            }

            if (address < rangeStart || endAddress > rangeEnd) {
                alert(`File exceeds allowed range 0x${rangeStart.toString(16).toUpperCase()} - 0x${rangeEnd.toString(16).toUpperCase()}`);
                return;
            }

            try {
                const arrayBuffer = await importFile.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);

                // Write data to sparse image
                await parser.sparseImage.write(address, data);

                setDeviceStatus(`Imported ${formatBytes(fileSize)} at 0x${address.toString(16).toUpperCase()}. Use "Write to Device" to flash.`, 'success');
                if (importCallback) {
                    await importCallback();
                }
                hideImportPopup();
            } catch (error) {
                console.error('Import error:', error);
                alert('Error importing file: ' + error.message);
            }
        }

        // Setup import popup event handlers
        document.addEventListener('DOMContentLoaded', () => {
            const importDropZone = document.getElementById('importDropZone');
            const importFileInput = document.getElementById('importFileInput');
            const importAddress = document.getElementById('importAddress');

            if (importFileInput) {
                importFileInput.addEventListener('change', async (e) => {
                    if (e.target.files.length > 0) {
                        importFile = e.target.files[0];
                        const fileNameSpan = document.getElementById('importFileName');
                        if (fileNameSpan) fileNameSpan.textContent = importFile.name;

                        // Check if JSON
                        if (importFile.name.toLowerCase().endsWith('.json')) {
                            importBaseUrl = null; // No base URL for local files
                            await handleJsonManifest(importFile);
                        } else {
                            importIsJson = false;
                            importJsonData = null;
                            importBaseUrl = null;
                            updateImportPreview();
                        }
                    }
                });
            }

            if (importAddress) {
                importAddress.addEventListener('input', () => {
                    updateImportPreview();
                });
            }

            if (importDropZone) {
                importDropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    importDropZone.classList.add('drag-over');
                });

                importDropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    importDropZone.classList.remove('drag-over');
                });

                importDropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    importDropZone.classList.remove('drag-over');

                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        importFile = files[0];
                        const fileNameSpan = document.getElementById('importFileName');
                        if (fileNameSpan) fileNameSpan.textContent = importFile.name;

                        // Check if JSON
                        if (importFile.name.toLowerCase().endsWith('.json')) {
                            importBaseUrl = null; // No base URL for local files
                            await handleJsonManifest(importFile);
                        } else {
                            importIsJson = false;
                            importJsonData = null;
                            importBaseUrl = null;
                            updateImportPreview();
                        }
                    }
                });
            }

            // Close popup when clicking outside
            const importPopup = document.getElementById('importPopup');
            if (importPopup) {
                importPopup.addEventListener('click', (e) => {
                    if (e.target === importPopup) {
                        hideImportPopup();
                    }
                });
            }
        });

        function togglePartitionDetails(idx) {
            const row = document.getElementById(`details-${idx}`);
            row.classList.toggle('visible');
        }

        async function parseOTADataPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            if (!contentDiv) {
                console.error(`Content div parsed-content-${idx} not found`);
                return;
            }

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing OTA data...</div>';

            try {
                const result = (await parser.parseOTAData(partition)).otaInfo;
                console.log('OTA data result:', result);
                const { entries, activeEntry } = result;

                // Count OTA partitions
                const otaPartitions = parser.partitions.filter(p =>
                    p.type === 0 && p.subType >= 0x10 && p.subType <= 0x1F
                );
                const otaCount = otaPartitions.length;

                // Build HTML display
                let html = '<div style="margin-top: 15px;">';

                html += `<div class="info-section" style="margin-bottom: 20px;">`;
                html += `<h4 style="margin: 0 0 10px 0; color: #7a8bdc;">OTA Boot Selection</h4>`;
                html += `<div style="font-size: 0.9em; color: #aaa; margin-bottom: 15px;">`;
                html += `Two redundant entries (sectors) store which OTA partition should boot. The valid entry with the highest sequence number is used.`;
                html += `</div>`;

                if (activeEntry !== null) {
                    const active = entries[activeEntry];
                    // Calculate which OTA partition will boot: (ota_seq - 1) % ota_app_count
                    const bootSlot = otaCount > 0 ? ((active.sequence - 1) % otaCount) : 0;
                    const bootPartition = otaPartitions[bootSlot];

                    html += `<div class="success" style="margin-bottom: 15px; padding: 15px;">`;
                    html += `<strong style="font-size: 1.1em;">Boot Partition:</strong> <span style="color: #88d899; font-size: 1.1em;">${bootPartition ? bootPartition.label : 'ota_' + bootSlot}</span><br>`;
                    html += `<div style="margin-top: 8px; font-size: 0.95em;">`;
                    html += `<strong>Active Entry:</strong> otadata[${activeEntry}]<br>`;
                    html += `<strong>Sequence:</strong> ${active.sequence}<br>`;
                    html += `<strong>OTA State:</strong> ${active.otaStateName}<br>`;
                    html += `<strong>OTA Slot:</strong> ${bootSlot} (calculated as (seq-1) % ${otaCount})`;
                    html += `</div>`;
                    html += `</div>`;
                } else {
                    html += '<div class="error" style="margin-bottom: 15px;">No valid OTA data entries - will boot factory partition or first OTA partition</div>';
                }

                html += `</div>`;

                // Show both entries with detailed status
                html += `<h4 style="margin: 20px 0 10px 0; color: #7a8bdc;">OTA Data Entries (Sectors)</h4>`;
                entries.forEach(entry => {
                    const isActive = entry.index === activeEntry;
                    const bgColor = isActive ? '#1f3d24' : '#2a2a2a';
                    const borderColor = isActive ? '#50a05e' : '#404040';

                    html += `<div style="background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 5px; padding: 15px; margin-bottom: 10px;">`;
                    html += `<strong style="color: ${isActive ? '#88d899' : '#aaa'};">otadata[${entry.index}]${isActive ? ' âœ“ ACTIVE' : ''}</strong>`;

                    if (entry.isEmpty) {
                        html += '<div style="margin-top: 8px; color: #888;">Empty (uninitialized - all 0xFF)</div>';
                    } else {
                        html += `<div style="margin-top: 8px; font-size: 0.9em;">`;
                        html += `<strong>Sequence:</strong> ${entry.sequence}<br>`;
                        html += `<strong>OTA State:</strong> ${entry.otaStateName} (0x${entry.otaState.toString(16).toUpperCase()})<br>`;
                        html += `<strong>CRC32:</strong> <span class="mono">0x${entry.crc.toString(16).toUpperCase().padStart(8, '0')}</span><br>`;
                        html += `<strong>Calculated:</strong> <span class="mono">0x${entry.calculatedCRC.toString(16).toUpperCase().padStart(8, '0')}</span><br>`;

                        const statusColor = entry.isValid ? '#81c784' : '#e57373';
                        const statusIcon = entry.isValid ? 'âœ“' : 'âœ—';
                        let statusText = entry.isValid ? 'Valid' : 'Invalid';
                        if (!entry.crcValid) {
                            statusText = 'CRC Mismatch';
                        } else if (!entry.isValid) {
                            statusText = 'Invalid State';
                        }
                        html += `<strong>Status:</strong> <span style="color: ${statusColor};">${statusIcon} ${statusText}</span>`;
                        html += `</div>`;
                    }

                    html += '</div>';
                });

                html += '</div>';
                contentDiv.innerHTML = html;

            } catch (error) {
                contentDiv.innerHTML = `<div class="error">Error parsing OTA data: ${error.message}</div>`;
                console.error('OTA data parse error:', error);
            }
        }

        function parseNVSPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            if (!contentDiv) {
                console.error(`Content div parsed-content-${idx} not found`);
                return;
            }

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing NVS data...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const nvsParser = await parser.parseNVS(partition);
                    currentNVSParser = nvsParser;
                    currentNVSPartition = partition;
                    const pages = nvsParser.pages;

                    console.log('NVS pages:', pages);

                    let html = '<div class="success" style="margin-bottom: 10px;">Found ' + pages.length + ' NVS pages <button class="nvs-add-btn" onclick="event.stopPropagation(); showNVSAddNamespaceDialog(' + idx + ')">âž• Add Namespace</button></div>';

                    const allNamespaces = {};
                    let totalItems = 0;

                    pages.forEach(page => {
                        page.items.forEach(item => {
                            if (item.nsIndex === 0) {
                                /* Collect namespace definitions */
                                if (item.namespace) {
                                    item.variables = [];
                                    allNamespaces[item.value] = item;
                                    totalItems++;
                                }
                            }
                        });
                    });
                    console.log('allNamespaces:', allNamespaces);

                    pages.forEach(page => {
                        page.items.forEach(item => {
                            if (item.nsIndex != 0) {
                                console.log('item:', item);
                                if (!allNamespaces[item.nsIndex]) {
                                    console.warn(`Namespace ${item.nsIndex} not found for item ${item.key}`);
                                    return;
                                }
                                allNamespaces[item.nsIndex].variables.push(item);
                            }
                            totalItems++;
                        });
                    });

                    if (allNamespaces.size === 0) {
                        html += '<div class="error">No namespaces found in this partition.</div>';
                    } else {
                        Object.keys(allNamespaces).forEach(nsKey => {
                            const nsObj = allNamespaces[nsKey];
                            const nsName = nsObj.namespace || nsKey;
                            console.log('Namespace:', nsName);
                            html += `<div class="nvs-namespace">Namespace: [${nsObj.value}] ${nsName} (${nsObj.variables.length} items)<button class="nvs-add-btn" onclick="event.stopPropagation(); showNVSAddDialog(${idx}, '${nsName}')">âž• Add Item</button></div>`;
                            nsObj.variables.forEach(item => {
                                const tooltip = `Offset: 0x${item.offset.toString(16).toUpperCase()} (${item.offset}), Size: ${item.entrySize} bytes`;
                                const crcBad = (item.headerCrcValid === false) || (item.dataCrcValid === false);
                                html += `<div class="nvs-item ${crcBad ? 'crc-bad' : ''}" title="${tooltip}" style="padding-right: 80px;">`;
                                html += `<button class="nvs-edit-btn" onclick="event.stopPropagation(); showNVSEditDialog(${idx}, '${nsName}', '${item.key}', '${item.typeName}', ${JSON.stringify(item.value).replace(/\"/g, '&quot;')})">âœï¸</button>`;
                                html += `<button class="nvs-delete-btn" onclick="event.stopPropagation(); deleteNVSItem(${idx}, '${nsName}', '${item.key}')">âŒ</button>`;
                                html += `<strong>${item.key}</strong> <span class="badge">${item.typeName}</span><br>`;
                                html += `Value: <span class="mono">${formatNVSValue(item)}</span>`;

                                if (item.headerCrcCalc !== undefined || item.dataCrcCalc !== undefined) {
                                    const headerValid = item.headerCrcCalc === undefined || item.headerCrcValid;
                                    const dataValid = item.dataCrcCalc === undefined || item.dataCrcValid;
                                    const allValid = headerValid && dataValid;

                                    if (allValid) {
                                        /* Both CRCs OK - show compact version with hover info */
                                        let hoverText = '';
                                        if (item.headerCrcCalc !== undefined) {
                                            const storedHex = (item.crc32 >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.headerCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            hoverText += `Header CRC: stored 0x${storedHex}, calc 0x${calcHex}`;
                                        }
                                        if (item.dataCrcCalc !== undefined) {
                                            const storedHex = (item.dataCrcStored >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.dataCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            if (hoverText) hoverText += '\\n';
                                            hoverText += `Data CRC: stored 0x${storedHex}, calc 0x${calcHex}`;
                                        }
                                        html += `<div class="crc-info" title="${hoverText}">CRCs: <span class="ok">OK</span> <span style="color: #9a9a9a;">â„¹ï¸</span></div>`;
                                    } else {
                                        /* At least one CRC failed - show full details */
                                        if (item.headerCrcCalc !== undefined) {
                                            const headerStatus = item.headerCrcValid ? '<span class="ok">OK</span>' : '<span class="bad">BAD</span>';
                                            const storedHex = (item.crc32 >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.headerCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            html += `<div class="crc-info">Header CRC: ${headerStatus} (stored 0x${storedHex}, calc 0x${calcHex})</div>`;
                                        }
                                        if (item.dataCrcCalc !== undefined) {
                                            const dataStatus = item.dataCrcValid ? '<span class="ok">OK</span>' : '<span class="bad">BAD</span>';
                                            const storedHex = (item.dataCrcStored >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.dataCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            html += `<div class="crc-info">Data CRC: ${dataStatus} (stored 0x${storedHex}, calc 0x${calcHex})</div>`;
                                        }
                                    }
                                }
                                html += `</div>`;
                            });
                        });
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('NVS parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing NVS: ${error.message}</div>`;
                }
            }, 100);
        }

        function formatNVSValue(item) {
            if (item.value === null) return 'null';
            if (typeof item.value === 'object') return JSON.stringify(item.value);
            if (item.typeName === 'String') return `"${item.value}"`;

            // For Blob chunks, show chunk info and data
            if (item.typeName === 'Blob' && item.chunkIndex !== undefined && item.chunkIndex !== 0xFF) {
                const chunkInfo = `<span style="color: #888;">[Chunk ${item.chunkIndex}]</span> `;

                if (item.rawValue) {
                    let hexLines = [];
                    let asciiLines = [];
                    const width = 32;

                    for (let i = 0; i < item.rawValue.length; i += width) {
                        const chunk = item.rawValue.slice(i, i + width);
                        const hexLine = Array.from(chunk)
                            .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                            .join(' ');
                        hexLines.push(hexLine);

                        let asciiLine = '';
                        for (let j = 0; j < chunk.length; j++) {
                            const byte = chunk[j];
                            asciiLine += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                        }
                        asciiLines.push(asciiLine);
                    }

                    return chunkInfo + `Hex:<br>${hexLines.join('<br>')}<br><span style="color: #d4a574;">ASCII:<br>${asciiLines.join('<br>')}</span>`;
                }
                return chunkInfo + item.value;
            }

            // For regular Blobs with raw data
            if (item.typeName === 'Blob' && item.rawValue) {
                let hexLines = [];
                let asciiLines = [];

                for (let i = 0; i < item.rawValue.length; i += 16) {
                    const chunk = item.rawValue.slice(i, i + 16);
                    const hexLine = Array.from(chunk)
                        .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                        .join(' ');
                    hexLines.push(hexLine);

                    let asciiLine = '';
                    for (let j = 0; j < chunk.length; j++) {
                        const byte = chunk[j];
                        asciiLine += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                    }
                    asciiLines.push(asciiLine);
                }

                return `Hex:<br>${hexLines.join('<br>')}<br><span style="color: #d4a574;">ASCII:<br>${asciiLines.join('<br>')}</span>`;
            }

            return item.value;
        }

        let currentFATParser = null;
        let currentFATPartition = null;
        let currentNVSParser = null;
        let currentNVSPartition = null;
        let currentSPIFFSParser = null;
        let currentSPIFFSPartition = null;

        function parseSPIFFSPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing SPIFFS filesystem...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const spiffsParser = await parser.parseSPIFFS(partition);
                    currentSPIFFSParser = spiffsParser;
                    currentSPIFFSPartition = partition;
                    const spiffsInfo = spiffsParser.spiffsInfo;

                    console.log('SPIFFS info:', spiffsInfo);

                    let html = '';

                    if (!spiffsInfo.valid) {
                        html += '<div class="error" style="margin-bottom: 10px;">âš ï¸ SPIFFS header not found. The partition may be empty, corrupted, or using a different filesystem.</div>';
                    } else {
                        html += '<div class="success" style="margin-bottom: 10px;">SPIFFS filesystem detected</div>';
                    }

                    // Filesystem info
                    html += '<h4 style="margin-top: 15px;">SPIFFS Information</h4>';
                    html += '<div class="info-grid">';
                    html += `<div class="info-item"><label>Valid Header:</label><span>${spiffsInfo.valid ? 'Yes' : 'No (estimated)'}</span></div>`;
                    if (spiffsInfo.magic) {
                        html += `<div class="info-item"><label>Magic:</label><span class="mono">0x${spiffsInfo.magic.toString(16).toUpperCase()}</span></div>`;
                    }
                    html += `<div class="info-item"><label>Block Size:</label><span>${spiffsInfo.blockSize} bytes (0x${spiffsInfo.blockSize.toString(16).toUpperCase()})</span></div>`;
                    html += `<div class="info-item"><label>Page Size:</label><span>${spiffsInfo.pageSize} bytes</span></div>`;
                    html += `<div class="info-item"><label>Total Size:</label><span>${formatBytes(spiffsInfo.totalSize)}</span></div>`;
                    html += `<div class="info-item"><label>Files Found:</label><span>${spiffsInfo.filesCount}</span></div>`;
                    html += '</div>';

                    // Files list with grouping: active vs deleted/old versions
                    if (spiffsInfo.files.length > 0) {
                        const activeFiles = spiffsInfo.files.filter(f => !f.deleted);
                        const deletedFiles = spiffsInfo.files.filter(f => f.deleted);

                        // Active files
                        html += `<h4 style="margin-top: 15px;">Files (${activeFiles.length} active${deletedFiles.length ? `, ${deletedFiles.length} deleted` : ''})</h4>`;
                        if (activeFiles.length > 0) {
                            html += '<table style="margin-top: 10px;"><thead><tr>';
                            html += '<th>Name</th><th>Object ID</th><th>Size</th><th>Block</th>';
                            html += '</tr></thead><tbody>';

                            activeFiles.forEach((file, fileIdx) => {
                                const fileId = `spiffsFile_${idx}_act_${fileIdx}`;
                                window[fileId] = file;
                                const clickable = file.size > 0;
                                const cursorStyle = clickable ? 'cursor: pointer;' : '';
                                const hoverClass = clickable ? 'class="fat-file-row"' : '';

                                html += `<tr ${hoverClass} style="${cursorStyle}" ${clickable ? `onclick="downloadSPIFFSFile('${fileId}')"` : ''}>`;
                                html += `<td><strong>${escapeHtml(file.name)}</strong></td>`;
                                html += `<td class="mono">0x${file.objId.toString(16).toUpperCase().padStart(4, '0')}</td>`;
                                html += `<td>${file.size > 0 ? formatBytes(file.size) : 'Unknown'}</td>`;
                                html += `<td>${file.blockIdx}</td>`;
                                html += '</tr>';
                            });

                            html += '</tbody></table>';
                        } else {
                            html += '<div style="margin-top: 10px; color: #888;">No active files found</div>';
                        }

                        // Deleted / old versions (collapsed group)
                        html += `<div style="margin-top: 18px;">
                                    <div class="expandable" style="padding:10px; border:1px solid #444; border-radius:6px; background:#2a2a2a;" onclick="(function(){
                                        const el=document.getElementById('spiffsDeletedGroup-${idx}');
                                        const ic=document.getElementById('spiffsDeletedToggle-${idx}');
                                        if(!el||!ic) return; 
                                        const vis=el.style.display!=='none';
                                        el.style.display= vis ? 'none' : 'block';
                                        ic.textContent = vis ? 'â–¶' : 'â–¼';
                                    })()">
                                        <span id="spiffsDeletedToggle-${idx}">â–¶</span>
                                        <strong style="margin-left:6px;">Deleted / old versions</strong>
                                        <span style="color:#aaa; margin-left:8px;">(${deletedFiles.length})</span>
                                    </div>
                                    <div id="spiffsDeletedGroup-${idx}" style="display:none; margin-top:8px;">
                                `;
                        if (deletedFiles.length > 0) {
                            html += '<table style="margin-top: 6px;"><thead><tr>';
                            html += '<th>Name</th><th>Object ID</th><th>Size</th><th>Block</th>';
                            html += '</tr></thead><tbody>';

                            deletedFiles.forEach((file, fileIdx) => {
                                const fileId = `spiffsFile_${idx}_del_${fileIdx}`;
                                window[fileId] = file;
                                const clickable = file.size > 0;
                                const cursorStyle = clickable ? 'cursor: pointer;' : '';
                                const hoverClass = clickable ? 'class="fat-file-row"' : '';

                                html += `<tr ${hoverClass} style="${cursorStyle}" ${clickable ? `onclick="downloadSPIFFSFile('${fileId}')"` : ''}>`;
                                html += `<td><strong>${escapeHtml(file.name)}</strong></td>`;
                                html += `<td class="mono">0x${file.objId.toString(16).toUpperCase().padStart(4, '0')}</td>`;
                                html += `<td>${file.size > 0 ? formatBytes(file.size) : (file.size === 0 ? '0' : 'Unknown')}</td>`;
                                html += `<td>${file.blockIdx}</td>`;
                                html += '</tr>';
                            });

                            html += '</tbody></table>';
                        } else {
                            html += '<div style="margin-top: 8px; color: #888;">No deleted entries</div>';
                        }
                        html += '</div></div>';
                    } else {
                        html += '<div style="margin-top: 15px; color: #888;">No files found. The filesystem may be empty or the partition is not SPIFFS.</div>';
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('SPIFFS parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing SPIFFS: ${error.message}</div>`;
                }
            }, 100);
        }

        async function downloadSPIFFSFile(fileId) {
            const file = window[fileId];
            if (!file || !currentSPIFFSParser) {
                alert('File data not available');
                return;
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'spiffs-loading-indicator';
            loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
            loadingDiv.textContent = `Loading ${file.name}...`;
            document.body.appendChild(loadingDiv);

            try {
                const fileData = await currentSPIFFSParser.readFile(file);
                const blob = new Blob([fileData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file: ' + error.message);
            } finally {
                // Remove loading indicator
                const indicator = document.getElementById('spiffs-loading-indicator');
                if (indicator) {
                    document.body.removeChild(indicator);
                }
            }
        }

        function parseFATPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing FAT filesystem...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const fatParser = await parser.parseFATFilesystem(partition);

                    if (fatParser.fatInfo.error) {
                        contentDiv.innerHTML = `<div class="error">${fatParser.fatInfo.error}</div>`;
                        return;
                    }

                    // Store parser instance for file downloads
                    currentFATParser = fatParser;
                    currentFATPartition = partition;

                    let html = '<div class="success" style="margin-bottom: 10px;">FAT filesystem parsed successfully</div>';

                    // Filesystem info
                    html += '<h4 style="margin-top: 15px;">Filesystem Information</h4>';
                    html += '<div class="info-grid">';
                    html += `<div class="info-item"><label>Type:</label><span>${fatParser.fatInfo.fatType}</span></div>`;
                    html += `<div class="info-item"><label>Volume Label:</label><span>${fatParser.fatInfo.volumeLabel}</span></div>`;
                    html += `<div class="info-item"><label>Bytes/Sector:</label><span>${fatParser.fatInfo.bytesPerSector}</span></div>`;
                    html += `<div class="info-item"><label>Sectors/Cluster:</label><span>${fatParser.fatInfo.sectorsPerCluster}</span></div>`;
                    html += `<div class="info-item"><label>Total Sectors:</label><span>${fatParser.fatInfo.totalSectors}</span></div>`;
                    html += `<div class="info-item"><label>Total Clusters:</label><span>${fatParser.fatInfo.totalClusters}</span></div>`;
                    html += '</div>';

                    // Wear leveling info
                    if (fatParser.fatInfo.wearLeveling && fatParser.fatInfo.wearLeveling.wlState) {
                        const wl = fatParser.fatInfo.wearLeveling.wlState;
                        html += '<h4 style="margin-top: 15px;">Wear Leveling</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Move Count:</label><span>${wl.moveCount}</span></div>`;
                        html += `<div class="info-item"><label>Access Count:</label><span>${wl.accessCount}</span></div>`;
                        html += `<div class="info-item"><label>Max Count:</label><span>${wl.maxCount}</span></div>`;
                        html += `<div class="info-item"><label>Block Size:</label><span>0x${wl.blockSize.toString(16).toUpperCase()}</span></div>`;
                        html += `<div class="info-item"><label>Version:</label><span>${wl.version}</span></div>`;
                        html += `<div class="info-item"><label>Device ID:</label><span>0x${wl.deviceId.toString(16).toUpperCase()}</span></div>`;
                        html += '</div>';
                    }

                    // Files list
                    html += '<h4 style="margin-top: 15px;">Files (' + countTotalFiles(fatParser.fatInfo.files) + ' total entries) <button class="add-btn" onclick="addFATFile(\'/\')" title="Add file to root directory">+</button></h4>';
                    if (fatParser.fatInfo.files.length > 0) {
                        html += '<table style="margin-top: 10px;"><thead><tr>';
                        html += '<th>Path</th><th>Size</th><th>Attributes</th><th>Date</th><th>Time</th><th>Cluster</th><th>Actions</th>';
                        html += '</tr></thead><tbody>';

                        renderFATFiles(fatParser.fatInfo.files, 0).forEach(row => {
                            html += row;
                        });

                        html += '</tbody></table>';
                    } else {
                        html += '<div style="margin-top: 10px; color: #888;">No files found</div>';
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('FAT parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing FAT: ${error.message}</div>`;
                }
            }, 100);
        }

        async function downloadFATFile(fileId) {
            const file = window[fileId];
            if (!file || !currentFATParser) {
                alert('File data not available');
                return;
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'fat-loading-indicator';
            loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
            loadingDiv.textContent = `Loading ${file.name}...`;
            document.body.appendChild(loadingDiv);

            try {
                const blob = await currentFATParser.extractFile(file);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file: ' + error.message);
            } finally {
                // Remove loading indicator
                const indicator = document.getElementById('fat-loading-indicator');
                if (indicator) {
                    document.body.removeChild(indicator);
                }
            }
        }

        async function deleteFATFile(fileId) {
            const file = window[fileId];
            if (!file || !currentFATParser || !currentFATPartition) {
                alert('File data not available');
                return;
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'fat-delete-indicator';
            loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
            loadingDiv.textContent = `Deleting ${file.name}...`;
            document.body.appendChild(loadingDiv);

            try {
                const result = await currentFATParser.deleteFile(file);

                if (result.success) {
                    console.log(`File "${file.name}" deleted successfully!\n${result.clustersCleared} clusters cleared.`);

                    // Re-parse the partition to refresh the file list
                    const partitionIdx = parser.partitions.indexOf(currentFATPartition);
                    if (partitionIdx !== -1) {
                        parseFATPartition(partitionIdx);
                    }
                } else {
                    alert('Error deleting file: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Delete error:', error);
                alert('Error deleting file: ' + error.message);
            } finally {
                // Remove loading indicator
                const indicator = document.getElementById('fat-delete-indicator');
                if (indicator) {
                    document.body.removeChild(indicator);
                }
            }
        }

        async function addFATFile(dirPath) {
            if (!currentFATParser || !currentFATPartition) {
                alert('FAT parser not available');
                return;
            }

            // Create modal dialog for file input
            const modal = document.createElement('div');
            modal.id = 'add-file-modal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center;';

            const dialog = document.createElement('div');
            dialog.style.cssText = 'background: #2a2b35; padding: 30px; border-radius: 8px; max-width: 500px; width: 90%;';

            const dirDisplayPath = dirPath || '(root)';
            dialog.innerHTML = `
                <h3 style="margin-top: 0;">Add File to ${dirDisplayPath}</h3>
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 5px;">Filename (8.3 format):</label>
                    <input type="text" id="add-file-name" placeholder="e.g., config.txt" style="width: 100%; padding: 8px; background: #1e1f29; border: 1px solid #444; color: #e0e0e0; border-radius: 4px;" />
                    <div style="font-size: 12px; color: #888; margin-top: 5px;">Max 8 characters for name, 3 for extension</div>
                </div>
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 5px;">File:</label>
                    <input type="file" id="add-file-input" style="width: 100%; padding: 8px; background: #1e1f29; border: 1px solid #444; color: #e0e0e0; border-radius: 4px;" />
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="add-file-cancel" style="padding: 10px 20px; background: #555; border: none; color: white; border-radius: 4px; cursor: pointer;">Cancel</button>
                    <button id="add-file-submit" style="padding: 10px 20px; background: #44cc44; border: none; color: white; border-radius: 4px; cursor: pointer;">Add File</button>
                </div>
            `;

            modal.appendChild(dialog);
            document.body.appendChild(modal);

            // Handle cancel
            document.getElementById('add-file-cancel').onclick = () => {
                document.body.removeChild(modal);
            };

            // Handle submit
            document.getElementById('add-file-submit').onclick = async () => {
                const filenameInput = document.getElementById('add-file-name');
                const fileInput = document.getElementById('add-file-input');

                let filename = filenameInput.value.trim();
                const file = fileInput.files[0];

                if (!file) {
                    alert('Please select a file');
                    return;
                }

                // Use uploaded filename if no custom name provided
                if (!filename) {
                    filename = file.name;
                }

                // Construct full path
                const fullPath = dirPath ? `${dirPath}/${filename}` : filename;

                // Close modal
                document.body.removeChild(modal);

                // Show loading indicator
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'fat-add-indicator';
                loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
                loadingDiv.textContent = `Adding ${filename}...`;
                document.body.appendChild(loadingDiv);

                try {
                    // Read file data
                    const arrayBuffer = await file.arrayBuffer();
                    const data = new Uint8Array(arrayBuffer);

                    // Add file to FAT
                    const result = await currentFATParser.addFile(fullPath, data);

                    if (result.success) {
                        alert(`File "${result.filename}" added successfully!\nSize: ${result.size} bytes\nClusters: ${result.clusters}\nStart cluster: 0x${result.startCluster.toString(16).toUpperCase()}`);

                        // Re-parse the partition to refresh the file list
                        const partitionIdx = parser.partitions.indexOf(currentFATPartition);
                        if (partitionIdx !== -1) {
                            parseFATPartition(partitionIdx);
                        }
                    } else {
                        alert('Error adding file: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Add file error:', error);
                    alert('Error adding file: ' + error.message);
                } finally {
                    // Remove loading indicator
                    const indicator = document.getElementById('fat-add-indicator');
                    if (indicator) {
                        document.body.removeChild(indicator);
                    }
                }
            };

            // Handle ESC key to close modal
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('add-file-modal');
                    if (modal) {
                        document.body.removeChild(modal);
                    }
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }

        function countTotalFiles(files) {
            let count = files.length;
            files.forEach(file => {
                if (file.children && file.children.length > 0) {
                    count += countTotalFiles(file.children);
                }
            });
            return count;
        }

        function renderFATFiles(files, depth) {
            const rows = [];
            const indent = '&nbsp;&nbsp;&nbsp;&nbsp;'.repeat(depth);

            files.forEach((file, fileIdx) => {
                const fileId = `fat-file-${depth}-${fileIdx}-${file.cluster}`;
                const clickable = !file.isDirectory && file.size > 0;
                const cursorStyle = clickable ? 'cursor: pointer;' : '';
                const hoverClass = clickable ? 'class="fat-file-row"' : '';

                let row = `<tr ${hoverClass} style="${cursorStyle}" ${clickable ? `onclick="downloadFATFile('${fileId}')"` : ''}>`;

                // Path column with indentation
                const icon = file.isDirectory ? 'ðŸ“' : 'ðŸ“„';
                row += `<td>${indent}${icon} <strong>${file.path || file.name}</strong></td>`;

                // Size (show - for directories)
                row += `<td>${file.isDirectory ? '-' : formatBytes(file.size)}</td>`;

                // Attributes
                row += `<td>${file.attributes.join(', ') || 'None'}</td>`;

                // Date & Time
                row += `<td class="mono">${file.date}</td>`;
                row += `<td class="mono">${file.time}</td>`;

                // Store file data for download
                if (clickable) {
                    window[fileId] = file;
                }

                // Cluster
                row += `<td class="mono">0x${file.cluster.toString(16).toUpperCase()}</td>`;

                // Actions (delete/add button)
                if (!file.isDirectory) {
                    row += `<td><button class="delete-btn" onclick="event.stopPropagation(); deleteFATFile('${fileId}')" title="Delete file">âœ•</button></td>`;
                } else {
                    // Store directory info for adding files
                    window[fileId] = file;
                    row += `<td><button class="add-btn" onclick="event.stopPropagation(); addFATFile('${file.path}')" title="Add file to this directory">+</button></td>`;
                }

                row += '</tr>';

                rows.push(row);

                // Add children if directory
                if (file.children && file.children.length > 0) {
                    rows.push(...renderFATFiles(file.children, depth + 1));
                }
            });

            return rows;
        }

        function parseImagePartitionInline(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            // Show loading
            contentDiv.innerHTML = '<div class="loading">â³ Parsing firmware image...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const image = await parser.parseImage(partition.offset, partition.length);

                    // Validate SHA256 (appended) and compute region hash
                    let sha256Validation = null;
                    let sha256RegionCalc = null;

                    if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined && image.sha256DataEnd > image.sha256DataStart) {
                        console.log(`Image SHA256 region: start=0x${image.sha256DataStart.toString(16)}, end=0x${image.sha256DataEnd.toString(16)}, length=${image.sha256DataEnd - image.sha256DataStart}`);

                        // Process in chunks to avoid allocation failures on large images
                        const MAX_CHUNK = 1024 * 1024; // 1 MB
                        const regionLength = image.sha256DataEnd - image.sha256DataStart;

                        if (regionLength <= MAX_CHUNK) {
                            // Small enough to process at once
                            const regionData = await parser.sparseImage.slice_async(image.sha256DataStart, image.sha256DataEnd);
                            const regionHash = await ESP32Parser.calculateSHA256(regionData);
                            sha256RegionCalc = ESP32Parser.bytesToHex(regionHash);
                        } else {
                            // Process in chunks using streaming hash
                            const hashBuffer = new Uint8Array(regionLength);
                            let offset = 0;
                            let remaining = regionLength;

                            while (remaining > 0) {
                                const chunkSize = Math.min(remaining, MAX_CHUNK);
                                const chunk = await parser.sparseImage.slice_async(
                                    image.sha256DataStart + offset,
                                    image.sha256DataStart + offset + chunkSize
                                );
                                hashBuffer.set(chunk, offset);
                                offset += chunkSize;
                                remaining -= chunkSize;
                            }

                            const regionHash = await ESP32Parser.calculateSHA256(hashBuffer);
                            sha256RegionCalc = ESP32Parser.bytesToHex(regionHash);
                        }
                    }

                    if (image.sha256) {
                        sha256Validation = await parser.validateImageSHA256(image);
                        // If validation didn't compute, reuse region calc
                        if (sha256Validation && !sha256Validation.calculated && sha256RegionCalc) {
                            sha256Validation.calculated = sha256RegionCalc;
                        }
                    }

                    let html = '';

                    if (image.error) {
                        html += `<div class="error" style="margin-bottom: 15px;"><strong>âš ï¸ Parsing Error:</strong> ${image.error}</div>`;
                    } else {

                        /* Check if OTA app checksum needs fixing */
                        let otaCheckNeedsFix = false;
                        try {
                            const checksumInfo = await parser.calculateImageChecksum(partition.offset, partition.length);
                            if (checksumInfo.checksum !== image.checksum) {
                                otaCheckNeedsFix = true;

                                const button = document.getElementById(`fix_check_${idx}`);
                                button.style.display = 'inline-block';
                            }
                        } catch (e) {
                            console.warn('Could not check OTA checksum:', e.message);
                        }

                        html += '<h4 style="margin-top: 15px;">Basic Information</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Magic:</label><span class="mono">0x${image.magic.toString(16).toUpperCase()}</span></div>`;
                        html += `<div class="info-item"><label>Segment Count:</label><span>${image.segmentCount}</span></div>`;
                        html += `<div class="info-item"><label>Entry Address:</label><span class="mono">0x${image.entryAddr.toString(16).toUpperCase().padStart(8, '0')}</span></div>`;
                        html += `<div class="info-item"><label>Chip:</label><span>${image.chipName} (0x${image.chipId.toString(16).toUpperCase().padStart(4, '0')})</span></div>`;
                        html += '</div>';

                        html += '<h4 style="margin-top: 15px;">Flash Configuration</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>SPI Mode:</label><span>${image.spiModeName} (${image.spiMode})</span></div>`;
                        html += `<div class="info-item"><label>SPI Speed:</label><span>${image.spiSpeedName}</span></div>`;
                        html += `<div class="info-item"><label>Flash Size:</label><span>${image.spiSizeName}</span></div>`;
                        html += `<div class="info-item"><label>WP Pin:</label><span>${image.wpPinDisabled ? 'Disabled (0xEE)' : '0x' + image.wpPin.toString(16).toUpperCase()}</span></div>`;
                        html += '</div>';

                        html += '<h4 style="margin-top: 15px;">Chip Revision</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Min Chip Rev:</label><span>v${image.minChipRevMajor}.${image.minChipRevMinor} (${image.minChipRevFull})</span></div>`;
                        html += `<div class="info-item"><label>Max Chip Rev:</label><span>v${image.maxChipRevMajor}.${image.maxChipRevMinor} (${image.maxChipRevFull})</span></div>`;
                        html += `<div class="info-item"><label>Legacy Min Rev:</label><span>${image.minChipRev}</span></div>`;
                        html += '</div>';

                        // App Description (if found)
                        if (image.appDesc && image.appDesc.found) {
                            html += '<h4 style="margin-top: 15px;">Application Description</h4>';
                            html += '<div class="info-grid">';
                            if (image.appDesc.projectName) {
                                html += `<div class="info-item"><label>Project Name:</label><span>${image.appDesc.projectName}</span></div>`;
                            }
                            if (image.appDesc.version) {
                                html += `<div class="info-item"><label>Version:</label><span>${image.appDesc.version}</span></div>`;
                            }
                            if (image.appDesc.idfVer) {
                                html += `<div class="info-item"><label>ESP-IDF Version:</label><span>${image.appDesc.idfVer}</span></div>`;
                            }
                            html += `<div class="info-item"><label>Secure Version:</label><span>${image.appDesc.secureVersion}</span></div>`;
                            if (image.appDesc.date && image.appDesc.time) {
                                html += `<div class="info-item"><label>Build Date/Time:</label><span>${image.appDesc.date} ${image.appDesc.time}</span></div>`;
                            }
                            if (image.appDesc.appElfSha256) {
                                html += `<div class="info-item" style="grid-column: 1 / -1;"><label>App ELF SHA256:</label><span class="mono" title="Reference only - ELF file not available for validation">${image.appDesc.appElfSha256} <span style="color: #9a9a9a;">â„¹ï¸</span></span></div>`;
                            }
                            html += '</div>';
                        }

                        html += '<h4 style="margin-top: 15px;">Validation</h4>';
                        html += '<div class="info-grid">';

                        /* Calculate expected checksum for OTA app */
                        let otaChecksumMismatch = false;
                        let otaCalculatedChecksum = null;
                        try {
                            const checksumInfo = await parser.calculateImageChecksum(partition.offset, partition.length);
                            otaCalculatedChecksum = checksumInfo.checksum;
                            otaChecksumMismatch = (checksumInfo.checksum !== image.checksum);
                        } catch (e) {
                            console.warn('Could not calculate OTA checksum:', e.message);
                        }

                        /* Checksum display */
                        const otaChecksumColor = otaChecksumMismatch ? '#e88888' : '#6ec589';
                        const otaChecksumIcon = otaChecksumMismatch ? 'âœ—' : 'âœ“';
                        html += `<div class="info-item"><label>Checksum:</label><span class="mono" style="color: ${otaChecksumColor};">0x${(image.checksum || 0).toString(16).toUpperCase().padStart(2, '0')} ${otaChecksumIcon}</span></div>`;
                        if (otaChecksumMismatch && otaCalculatedChecksum !== null) {
                            html += `<div class="info-item"><label>Checksum (calculated):</label><span class="mono">0x${otaCalculatedChecksum.toString(16).toUpperCase().padStart(2, '0')}</span></div>`;
                        }
                        html += `<div class="info-item"><label>Hash Appended:</label><span>${image.hasHash ? 'Yes' : 'No'}</span></div>`;

                        /* SHA256 display */
                        const otaSha256Match = image.sha256 && sha256RegionCalc && image.sha256.toLowerCase() === sha256RegionCalc.toLowerCase();
                        const otaSha256Valid = sha256Validation && sha256Validation.valid === true;
                        const otaSha256Invalid = sha256Validation && sha256Validation.valid === false;
                        const otaSha256Color = otaSha256Valid ? '#6ec589' : otaSha256Invalid ? '#e88888' : '#9a9a9a';
                        const otaSha256Icon = otaSha256Valid ? 'âœ“' : otaSha256Invalid ? 'âœ—' : 'â³';

                        if (image.sha256) {
                            html += `<div class="info-item" style="grid-column: 1 / -1;"><label>SHA256:</label><span class="mono" style="color: ${otaSha256Color};">${image.sha256} ${otaSha256Icon}</span></div>`;
                            if (otaSha256Invalid && sha256RegionCalc) {
                                html += `<div class="info-item" style="grid-column: 1 / -1;"><label>SHA256 (calculated):</label><span class="mono">${sha256RegionCalc}</span></div>`;
                            }
                        }
                        if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined) {
                            const regionLen = image.sha256DataEnd - image.sha256DataStart;
                            html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Hash region:</label><span class="mono">0x${image.sha256DataStart.toString(16).toUpperCase()} - 0x${image.sha256DataEnd.toString(16).toUpperCase()} (${regionLen} bytes)</span></div>`;
                        }
                        html += '</div>';

                        html += '<h4 style="margin-top: 15px;">Segments</h4>';
                        html += '<table><thead><tr><th>#</th><th>Load Address</th><th>Length</th><th>Offset</th></tr></thead><tbody>';
                        image.segmentList.forEach((seg, sidx) => {
                            html += '<tr>';
                            html += `<td>${sidx}</td>`;
                            html += `<td class="mono">0x${seg.loadAddress.toString(16).toUpperCase().padStart(8, '0')}</td>`;
                            html += `<td>${formatBytes(seg.length)}</td>`;
                            html += `<td class="mono">0x${seg.offset.toString(16).toUpperCase()}</td>`;
                            html += '</tr>';
                        });
                        html += '</tbody></table>';
                    }

                    contentDiv.innerHTML = html;

                    // Update the Save OTA Image button to show actual size
                    if (image.sha256DataEnd !== undefined) {
                        const imageSize = image.sha256DataEnd - partition.offset;
                        const saveButton = document.getElementById(`save_ota_${idx}`);
                        if (saveButton) {
                            saveButton.textContent = `Save OTA Image (${formatBytes(imageSize)})`;
                        }
                    }
                } catch (error) {
                    console.error('Image parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing image: ${error.message}</div>`;
                }
            }, 100);
        }

        async function downloadPartition(idx) {
            /* Handle bootloader (-1) and regular partitions */
            let partition;
            if (idx === -1) {
                // Use parsed bootloader bounds if available, otherwise fall back to partition table offset
                if (bootloaderInfo && bootloaderInfo.bootloaderEnd) {
                    partition = { label: 'bootloader', offset: 0x0000, length: bootloaderInfo.bootloaderEnd };
                } else {
                    const bootloaderEnd = partitionTableOffset || 0x8000;
                    partition = { label: 'bootloader', offset: 0x0000, length: bootloaderEnd };
                }
            } else {
                partition = parser.partitions[idx];
            }

            setFetchOverlayReason(`Download ${partition.label}`);
            showFetchOverlay(`Downloading ${partition.label}...`);
            try {
                const blob = await parser.exportPartitionData(partition);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${partition.label}_0x${partition.offset.toString(16)}.bin`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Partition download error:', error);
                alert('Error downloading partition: ' + error.message);
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
            }
        }

        async function downloadOTAImage(idx) {
            const partition = parser.partitions[idx];
            if (!partition) {
                alert('Partition not found.');
                return;
            }

            setFetchOverlayReason(`Save OTA image (${partition.label})`);
            showFetchOverlay(`Preparing OTA image from header...`);
            try {
                // Re-parse to get precise header-defined bounds
                const image = await parser.parseImage(partition.offset, partition.length);

                if (image && image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined) {
                    const start = partition.offset;
                    // If appended SHA256 present, include it (32 bytes)
                    const hasAppendedHash = !!image.sha256;
                    const end = image.sha256DataEnd + (hasAppendedHash ? 32 : 0);

                    const bytes = await parser.sparseImage.slice_async(start, end);

                    const blob = new Blob([bytes], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${partition.label}_ota_0x${start.toString(16)}-0x${end.toString(16)}.bin`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else {
                    alert('Unable to determine OTA image bounds from header.');
                }
            } catch (error) {
                console.error('OTA image download error:', error);
                alert('Error saving OTA image: ' + error.message);
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
            }
        }

        async function viewPartitionHex(idx) {
            /* Handle bootloader (-1) and regular partitions */
            let partition;
            if (idx === -1) {
                partition = { label: 'bootloader', offset: 0, length: 0x10000 };
            } else {
                partition = parser.partitions[idx];
            }
            document.getElementById('hexOffset').value = '0x' + partition.offset.toString(16).toUpperCase();
            document.getElementById('hexLength').value = '0x' + Math.min(partition.length, 0x1000).toString(16).toUpperCase();
            switchTab('raw');
            updateHexView();
        }

        async function updateHexView() {
            const offsetStr = document.getElementById('hexOffset').value.trim();
            const lengthStr = document.getElementById('hexLength').value.trim();
            const rawContent = document.getElementById('rawContent');

            if (!parser) {
                rawContent.innerHTML = '<div class="error">No firmware loaded</div>';
                return;
            }

            // Show loading indicator
            rawContent.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading hex view...</div>';

            try {
                const offset = parseInt(offsetStr, 16);
                const length = parseInt(lengthStr, 16);

                if (isNaN(offset) || isNaN(length)) {
                    rawContent.innerHTML = '<div class="error">Invalid offset or length. Use hex format (e.g., 0x1000)</div>';
                    return;
                }

                const totalLen = parser.sparseImage.size;

                if (offset < 0 || offset >= totalLen) {
                    rawContent.innerHTML = '<div class="error">Offset out of range</div>';
                    return;
                }

                const actualLength = Math.min(length, totalLen - offset);
                if (actualLength > 0x100000) {
                    rawContent.innerHTML = '<div class="error">Length too large. Maximum is 0x100000 (1MB)</div>';
                    return;
                }

                const hexView = await generateHexView(offset, actualLength);
                rawContent.innerHTML = hexView;
            } catch (error) {
                rawContent.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }

        async function generateHexView(offset, length) {
            const bytes = await parser.sparseImage.subarray_async(offset, offset + length);
            const widthInput = document.getElementById('hexWidth');
            const bytesPerLine = widthInput ? parseInt(widthInput.value) || 16 : 16;

            let html = '<div class="hex-viewer">';

            for (let i = 0; i < bytes.length; i += bytesPerLine) {
                const lineOffset = offset + i;
                const lineBytes = bytes.slice(i, Math.min(i + bytesPerLine, bytes.length));

                html += '<div>';

                // Offset (colored)
                html += `<span class="hex-offset">${lineOffset.toString(16).toUpperCase().padStart(8, '0')}</span>  `;

                // Hex bytes (colored)
                let hexPart = '';
                for (let j = 0; j < bytesPerLine; j++) {
                    if (j < lineBytes.length) {
                        const byte = lineBytes[j];
                        hexPart += byte.toString(16).toUpperCase().padStart(2, '0') + ' ';
                    } else {
                        hexPart += '   ';
                    }

                    if (j === Math.floor(bytesPerLine / 2) - 1) {
                        hexPart += ' ';
                    }
                }
                html += `<span class="hex-bytes">${hexPart}</span>`;

                // Add spacing before ASCII
                html += '   ';

                // ASCII representation (colored)
                let asciiPart = '';
                for (let j = 0; j < lineBytes.length; j++) {
                    const byte = lineBytes[j];
                    asciiPart += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                }
                html += `<span class="hex-ascii">${asciiPart}</span>`;

                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        function switchTab(tabName, event) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            if (event?.target) {
                event.target.classList.add('active');
            } else {
                // Find and activate by tab name if no event
                document.querySelectorAll('.tab').forEach(tab => {
                    if (tab.textContent.toLowerCase().includes(tabName)) {
                        tab.classList.add('active');
                    }
                });
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }

        function showError(message) {
            console.error('showError:', message);
            const content = document.getElementById('partitionsContent');
            if (content) {
                content.innerHTML = `<div class="error">${message}</div>`;
            }
        }

        async function deleteNVSItem(partitionIdx, namespace, key) {
            if (!currentNVSParser) {
                alert('No NVS partition loaded.');
                return;
            }

            try {
                await currentNVSParser.deleteItem(namespace, key);

                // Refresh the NVS display
                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Deleted NVS item: ${namespace}.${key}`, 'success');
            } catch (error) {
                alert('Error deleting NVS item: ' + error.message);
            }
        }

        let currentNVSAddPartition = null;
        let currentNVSAddNamespace = null;

        function showNVSAddDialog(partitionIdx, namespace) {
            currentNVSAddPartition = partitionIdx;
            currentNVSAddNamespace = namespace;

            const overlay = document.createElement('div');
            overlay.className = 'nvs-popup-overlay';
            overlay.onclick = closeNVSAddDialog;

            const popup = document.createElement('div');
            popup.className = 'nvs-popup';
            popup.onclick = (e) => e.stopPropagation();

            popup.innerHTML = `
                <h3>Add NVS Item to ${namespace}</h3>
                <label for="nvs-add-key">Key:</label>
                <input type="text" id="nvs-add-key" maxlength="15" placeholder="Key name (max 15 chars)">
                
                <label for="nvs-add-type">Type:</label>
                <select id="nvs-add-type" onchange="updateNVSAddValueInput()">
                    <option value="U8">U8 (Unsigned 8-bit)</option>
                    <option value="U16">U16 (Unsigned 16-bit)</option>
                    <option value="U32">U32 (Unsigned 32-bit)</option>
                    <option value="U64">U64 (Unsigned 64-bit)</option>
                    <option value="I8">I8 (Signed 8-bit)</option>
                    <option value="I16">I16 (Signed 16-bit)</option>
                    <option value="I32">I32 (Signed 32-bit)</option>
                    <option value="I64">I64 (Signed 64-bit)</option>
                    <option value="String">String</option>
                    <option value="BlobSmall">Blob Small (Hex, â‰¤32 bytes)</option>
                    <option value="BlobSmallString">Blob Small (String, â‰¤32 bytes)</option>
                    <option value="Blob">Blob (Hex)</option>
                    <option value="BlobString">Blob (String)</option>
                </select>
                
                <label for="nvs-add-value">Value:</label>
                <input type="text" id="nvs-add-value" placeholder="Enter value">
                <div id="nvs-add-value-hint" style="font-size: 0.85em; color: #888; margin-top: 5px;">Enter a number (0-255)</div>
                
                <div class="nvs-popup-buttons">
                    <button class="btn" onclick="closeNVSAddDialog()">Cancel</button>
                    <button class="btn" onclick="submitNVSAddDialog()" style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Add</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Initialize value input hint
            setTimeout(() => {
                updateNVSAddValueInput();
                document.getElementById('nvs-add-key').focus();
            }, 100);
        }

        function showNVSAddNamespaceDialog(partitionIdx) {
            currentNVSAddPartition = partitionIdx;

            const overlay = document.createElement('div');
            overlay.className = 'nvs-popup-overlay';
            overlay.onclick = closeNVSAddDialog;

            const popup = document.createElement('div');
            popup.className = 'nvs-popup';
            popup.onclick = (e) => e.stopPropagation();

            popup.innerHTML = `
                <h3>Add New Namespace</h3>
                <label for="nvs-namespace-name">Namespace Name:</label>
                <input type="text" id="nvs-namespace-name" maxlength="15" placeholder="Namespace name (max 15 chars)">
                <div style="font-size: 0.85em; color: #888; margin-top: 5px;">Enter a unique namespace name</div>
                
                <div class="nvs-popup-buttons">
                    <button class="btn" onclick="closeNVSAddDialog()">Cancel</button>
                    <button class="btn" onclick="submitNVSAddNamespaceDialog()" style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Create</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            setTimeout(() => {
                document.getElementById('nvs-namespace-name').focus();
            }, 100);
        }

        function showNVSEditDialog(partitionIdx, namespace, key, type, value) {
            currentNVSAddPartition = partitionIdx;
            currentNVSAddNamespace = namespace;
            window.currentNVSEditKey = key;

            const overlay = document.createElement('div');
            overlay.className = 'nvs-popup-overlay';
            overlay.onclick = closeNVSAddDialog;

            const popup = document.createElement('div');
            popup.className = 'nvs-popup';
            popup.onclick = (e) => e.stopPropagation();

            // Format value for display in input
            let displayValue = value;
            if (type === 'String') {
                displayValue = value.replace(/^"|"$/g, '');
            } else if (type === 'Blob') {
                // Extract hex from formatted blob value
                if (typeof value === 'string') {
                    const hexMatch = value.match(/Hex: ([0-9A-F ]+)/i);
                    if (hexMatch) {
                        displayValue = hexMatch[1];
                    }
                }
            }

            popup.innerHTML = `
                <h3>Edit NVS Item: ${key}</h3>
                <label>Key: <strong>${key}</strong> (read-only)</label>
                
                <label for="nvs-add-type">Type:</label>
                <select id="nvs-add-type" onchange="updateNVSAddValueInput()">
                    <option value="U8" ${type === 'U8' ? 'selected' : ''}>U8 (Unsigned 8-bit)</option>
                    <option value="U16" ${type === 'U16' ? 'selected' : ''}>U16 (Unsigned 16-bit)</option>
                    <option value="U32" ${type === 'U32' ? 'selected' : ''}>U32 (Unsigned 32-bit)</option>
                    <option value="U64" ${type === 'U64' ? 'selected' : ''}>U64 (Unsigned 64-bit)</option>
                    <option value="I8" ${type === 'I8' ? 'selected' : ''}>I8 (Signed 8-bit)</option>
                    <option value="I16" ${type === 'I16' ? 'selected' : ''}>I16 (Signed 16-bit)</option>
                    <option value="I32" ${type === 'I32' ? 'selected' : ''}>I32 (Signed 32-bit)</option>
                    <option value="I64" ${type === 'I64' ? 'selected' : ''}>I64 (Signed 64-bit)</option>
                    <option value="String" ${type === 'String' ? 'selected' : ''}>String</option>
                    <option value="BlobSmall" ${type === 'BlobSmall' ? 'selected' : ''}>Blob Small (Hex, â‰¤32 bytes)</option>
                    <option value="BlobSmallString" ${type === 'BlobSmallString' ? 'selected' : ''}>Blob Small (String, â‰¤32 bytes)</option>
                    <option value="Blob" ${type === 'Blob' ? 'selected' : ''}>Blob (Hex)</option>
                    <option value="BlobString" ${type === 'BlobString' ? 'selected' : ''}>Blob (String)</option>
                </select>
                
                <label for="nvs-add-value">Value:</label>
                <input type="text" id="nvs-add-value" placeholder="Enter value" value="${displayValue}">
                <div id="nvs-add-value-hint" style="font-size: 0.85em; color: #888; margin-top: 5px;">Enter a number (0-255)</div>
                
                <div class="nvs-popup-buttons">
                    <button class="btn" onclick="closeNVSAddDialog()">Cancel</button>
                    <button class="btn" onclick="submitNVSEditDialog()" style="background: linear-gradient(135deg, #d49f37 0%, #b58f30 100%);">Save</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Initialize value input hint
            setTimeout(() => {
                updateNVSAddValueInput();
                document.getElementById('nvs-add-value').focus();
                document.getElementById('nvs-add-value').select();
            }, 100);
        }

        function updateNVSAddValueInput() {
            const typeSelect = document.getElementById('nvs-add-type');
            const valueInput = document.getElementById('nvs-add-value');
            const hint = document.getElementById('nvs-add-value-hint');

            if (!typeSelect || !valueInput || !hint) return;

            const type = typeSelect.value;

            switch (type) {
                case 'U8':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (0-255)';
                    hint.textContent = 'Range: 0 to 255';
                    break;
                case 'U16':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (0-65535)';
                    hint.textContent = 'Range: 0 to 65535';
                    break;
                case 'U32':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (0-4294967295)';
                    hint.textContent = 'Range: 0 to 4294967295';
                    break;
                case 'U64':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter number (0-18446744073709551615)';
                    hint.textContent = 'Range: 0 to 18446744073709551615';
                    break;
                case 'I8':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (-128 to 127)';
                    hint.textContent = 'Range: -128 to 127';
                    break;
                case 'I16':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (-32768 to 32767)';
                    hint.textContent = 'Range: -32768 to 32767';
                    break;
                case 'I32':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (-2147483648 to 2147483647)';
                    hint.textContent = 'Range: -2147483648 to 2147483647';
                    break;
                case 'I64':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter number (-9223372036854775808 to 9223372036854775807)';
                    hint.textContent = 'Range: -9223372036854775808 to 9223372036854775807';
                    break;
                case 'String':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter string value';
                    hint.textContent = 'Enter any text (max 1984 bytes)';
                    break;
                case 'BlobSmall':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter hex bytes (e.g., 01 02 03 FF)';
                    hint.textContent = 'Enter hex bytes separated by spaces (max 32 bytes)';
                    break;
                case 'BlobSmallString':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter string value';
                    hint.textContent = 'Enter string to be stored as small blob (max 32 bytes)';
                    break;
                case 'Blob':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter hex bytes (e.g., 01 02 03 FF)';
                    hint.textContent = 'Enter hex bytes separated by spaces (max 1984 bytes)';
                    break;
                case 'BlobString':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter string value';
                    hint.textContent = 'Enter string to be stored as blob (max 1984 bytes)';
                    break;
            }
        }

        function closeNVSAddDialog() {
            const overlay = document.querySelector('.nvs-popup-overlay');
            if (overlay) {
                document.body.removeChild(overlay);
            }
            currentNVSAddPartition = null;
            currentNVSAddNamespace = null;
        }

        async function submitNVSAddDialog() {
            const key = document.getElementById('nvs-add-key').value.trim();
            let type = document.getElementById('nvs-add-type').value;
            let value = document.getElementById('nvs-add-value').value.trim();

            if (!key) {
                alert('Please enter a key name.');
                return;
            }

            if (key.length > 15) {
                alert('Key name must be 15 characters or less.');
                return;
            }

            if (!value) {
                alert('Please enter a value.');
                return;
            }

            // Convert BlobString to Blob with hex bytes
            if (type === 'BlobString') {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(value);
                value = Array.from(bytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                type = 'Blob';
            }

            // Convert BlobSmallString to BlobSmall with hex bytes
            if (type === 'BlobSmallString') {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(value);
                value = Array.from(bytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                type = 'BlobSmall';
            }

            // Save partition index and namespace before closing dialog
            const partitionIdx = currentNVSAddPartition;
            const namespace = currentNVSAddNamespace;

            try {
                if (!currentNVSParser) {
                    alert('No NVS partition loaded.');
                    return;
                }

                await currentNVSParser.addItem(namespace, key, type, value);

                closeNVSAddDialog();

                // Ensure the details row is visible before parsing
                const detailsRow = document.getElementById(`details-${partitionIdx}`);
                if (detailsRow && !detailsRow.classList.contains('visible')) {
                    detailsRow.classList.add('visible');
                }

                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Added NVS item: ${namespace}.${key}`, 'success');
            } catch (error) {
                alert('Error adding NVS item: ' + error.message);
            }
        }

        async function submitNVSEditDialog() {
            const oldKey = window.currentNVSEditKey;
            let type = document.getElementById('nvs-add-type').value;
            let value = document.getElementById('nvs-add-value').value.trim();

            if (!value) {
                alert('Please enter a value.');
                return;
            }

            // Convert BlobString to Blob with hex bytes
            if (type === 'BlobString') {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(value);
                value = Array.from(bytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                type = 'Blob';
            }

            // Convert BlobSmallString to BlobSmall with hex bytes
            if (type === 'BlobSmallString') {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(value);
                value = Array.from(bytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                type = 'BlobSmall';
            }

            // Save partition index and namespace before closing dialog
            const partitionIdx = currentNVSAddPartition;
            const namespace = currentNVSAddNamespace;

            try {
                if (!currentNVSParser) {
                    alert('No NVS partition loaded.');
                    return;
                }

                // Update using the updateItem method (delete + add)
                await currentNVSParser.updateItem(namespace, oldKey, type, value);
                console.log(`Updated NVS item: ${namespace}/${oldKey} = ${value} (${type})`);

                closeNVSAddDialog();

                // Ensure the details row is visible before parsing
                const detailsRow = document.getElementById(`details-${partitionIdx}`);
                if (detailsRow && !detailsRow.classList.contains('visible')) {
                    detailsRow.classList.add('visible');
                }

                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Updated NVS item: ${namespace}.${oldKey}`, 'success');
            } catch (error) {
                alert('Error updating NVS item: ' + error.message);
            }
        }

        async function submitNVSAddNamespaceDialog() {
            const namespaceName = document.getElementById('nvs-namespace-name').value.trim();

            if (!namespaceName) {
                alert('Please enter a namespace name.');
                return;
            }

            if (namespaceName.length > 15) {
                alert('Namespace name must be 15 characters or less.');
                return;
            }

            // Save partition index before closing dialog
            const partitionIdx = currentNVSAddPartition;

            try {
                if (!currentNVSParser) {
                    alert('No NVS partition loaded.');
                    return;
                }

                await currentNVSParser.addNamespace(namespaceName);
                console.log(`Added namespace: ${namespaceName}`);

                closeNVSAddDialog();

                // Ensure the details row is visible before parsing
                const detailsRow = document.getElementById(`details-${partitionIdx}`);
                if (detailsRow && !detailsRow.classList.contains('visible')) {
                    detailsRow.classList.add('visible');
                }

                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Created namespace: ${namespaceName}`, 'success');
            } catch (error) {
                alert('Error creating namespace: ' + error.message);
            }
        }
    </script>
</body>

</html>
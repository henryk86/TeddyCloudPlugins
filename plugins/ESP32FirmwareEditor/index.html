<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Firmware Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            color: #d4d4d4;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1f35 0%, #1c1424 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1900px;
            margin: 0 auto;
            background: #2a2a2a;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #3d4a7a 0%, #2d1f3d 100%);
            color: #e0e0e0;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .drop-zone {
            border: 3px dashed #5a6bb8;
            border-radius: 10px;
            padding: 10px 10px;
            text-align: center;
            background: #333333;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }

        .drop-zone:hover {
            background: #3a3f5a;
            border-color: #7a6bb8;
        }

        .drop-zone.drag-over {
            background: #404560;
            border-color: #8a7bc8;
            transform: scale(1.02);
        }

        .drop-zone i {
            font-size: 4em;
            color: #7a8bdc;
            margin-bottom: 20px;
            display: block;
        }

        .drop-zone p {
            font-size: 1.2em;
            color: #a0a0a0;
            margin: 10px 0;
        }

        .drop-zone .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #5a6bb8 0%, #6a5294 100%);
            color: #e8e8e8;
            border: none;
            padding: 12px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(90, 107, 184, 0.5);
        }

        .file-info {
            background: #333333;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .file-info.visible {
            display: block;
        }

        .file-info h3 {
            color: #7a8bdc;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: #252525;
            padding: 5px 8px;
            border-radius: 5px;
            border-left: 3px solid #5a6bb8;
        }

        .info-item label {
            font-weight: bold;
            color: #9a9a9a;
            font-size: 0.9em;
            display: block;
            margin-bottom: 5px;
        }

        .info-item span {
            color: #c8c8c8;
            font-size: 1em;
            word-break: break-all;
        }

        .size-selector {
            cursor: pointer;
            text-decoration: underline dotted;
            color: #6ec589;
        }

        .size-selector:hover {
            color: #8bf0a8;
        }

        .size-select {
            background: #252525;
            color: #c8c8c8;
            border: 1px solid #5a6bb8;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 0.95em;
            outline: none;
        }

        .size-select:focus {
            border-color: #8bf0a8;
            box-shadow: 0 0 0 2px rgba(139, 240, 168, 0.2);
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid #404040;
            margin-bottom: 20px;
            gap: 10px;
        }

        .tab {
            padding: 15px 30px;
            background: #2a2a2a;
            border: none;
            cursor: pointer;
            font-size: 1em;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s ease;
        }

        .tab:hover {
            background: #3a3a3a;
        }

        .tab.active {
            background: linear-gradient(135deg, #3d4565 0%, #3a2e4a 100%);
            color: #e8e8e8;
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: #2d2d2d;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        th {
            background: linear-gradient(135deg, #3d4565 0%, #3a2e4a 100%);
            color: #e0e0e0;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 4px 4px;
            border-bottom: 1px solid #404040;
        }

        tr:hover {
            background: #383840;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .fat-file-row {
            cursor: pointer;
        }

        .fat-file-row:hover {
            background: #3d3e48;
            box-shadow: inset 0 0 10px rgba(100, 100, 255, 0.2);
        }

        .delete-btn {
            background: #ff4444;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            padding: 0;
            transition: background 0.2s;
        }

        .delete-btn:hover {
            background: #ff6666;
        }

        .add-btn {
            background: #44cc44;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            line-height: 1;
            padding: 0;
            transition: background 0.2s;
        }

        .add-btn:hover {
            background: #66ee66;
        }

        .expandable {
            cursor: pointer;
        }

        .expandable:hover {
            background: #3d3e48;
        }

        .details-row {
            display: none;
            background: #333338;
        }

        .details-row.visible {
            display: table-row;
        }

        .details-content {
            padding: 15px;
            border-left: 3px solid #5a6bb8;
        }

        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
        }

        .detail-item {
            background: #3a3a3a;
            padding: 4px 8px;
            border-radius: 5px;
        }

        .detail-item strong {
            color: #7a8bdc;
            display: block;
            margin-bottom: 5px;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
            background: #404040;
        }

        .badge.app {
            color: #6b9aeb;
        }

        .badge.data {
            color: #b883d8;
        }

        .badge.nvs {
            color: #f39c63;
        }

        .badge.fat {
            color: #6ec589;
        }

        .code-block {
            background: #1e1e1e;
            color: #7a8bdc;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin: 10px 0;
        }

        .nvs-namespace {
            background: linear-gradient(90deg, #5a6bb8 0%, #6a5294 100%);
            color: #e8e8e8;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 5px;
            font-weight: bold;
        }

        .nvs-item {
            background: #2d2d2d;
            padding: 5px 8px;
            margin: 5px 0;
            border-left: 3px solid #5a6bb8;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .nvs-item:hover {
            background: #353535;
        }

        .nvs-item .mono {
            word-break: break-all;
            display: inline-block;
            max-width: calc(100% - 100px);
        }

        .nvs-item.crc-bad {
            border-left-color: #e57373;
            background: #3a2b2b;
        }

        .nvs-delete-btn {
            background: #c05050;
            color: #ffffff;
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            position: absolute;
            right: 8px;
            top: 8px;
        }

        .nvs-delete-btn:hover {
            background: #d06060;
        }

        .nvs-add-btn {
            background: #5a6bb8;
            color: #ffffff;
            border: none;
            padding: 4px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 8px;
        }

        .nvs-add-btn:hover {
            background: #6a7bc8;
        }

        .nvs-edit-btn {
            background: #63d437;
            color: #ffffff;
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            position: absolute;
            right: 40px;
            top: 8px;
        }

        .nvs-edit-btn:hover {
            background: #e0af47;
        }

        .nvs-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 2px solid #5a6bb8;
            border-radius: 8px;
            padding: 20px;
            z-index: 10001;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            min-width: 400px;
        }

        .nvs-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
        }

        .nvs-popup h3 {
            margin-bottom: 15px;
            color: #7a8bdc;
        }

        .nvs-popup label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
            color: #c8c8c8;
        }

        .nvs-popup input,
        .nvs-popup select {
            width: 100%;
            padding: 8px;
            border: 1px solid #5a6bb8;
            border-radius: 4px;
            background: #333333;
            color: #d4d4d4;
            font-size: 1em;
        }

        .nvs-popup-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .crc-info {
            font-size: 0.85em;
            color: #b0b0b0;
            margin-top: 4px;
        }

        .crc-info .bad {
            color: #e57373;
            font-weight: 600;
        }

        .crc-info .ok {
            color: #81c784;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7a8bdc;
            font-size: 1.2em;
        }

        .error {
            background: #3d1f1f;
            color: #e88888;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #c05050;
            margin: 10px 0;
        }

        .success {
            background: #1f3d24;
            color: #88d899;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #50a05e;
            margin: 10px 0;
        }

        .mono {
            font-family: 'Courier New', monospace;
            background: #3a3a3a;
            color: #d0d0d0;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .download-btn {
            background: #4d8f52;
            color: #e8e8e8;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
        }

        .download-btn:hover {
            background: #5aa05e;
        }

        .replace-btn {
            background: #8f4d4d;
            color: #e8e8e8;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
        }

        .replace-btn:hover {
            background: #a05a5a;
        }

        .hex-btn {
            background: #5a6bb8;
            color: #e8e8e8;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
        }

        .hex-btn:hover {
            background: #6a7bc8;
        }

        .hex-viewer {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .hex-line {
            display: flex;
            margin: 2px 0;
        }

        .hex-offset {
            color: #7a8bb8;
            margin-right: 15px;
            min-width: 80px;
        }

        .hex-bytes {
            color: #88d899;
            margin-right: 15px;
            flex: 1;
        }

        .hex-ascii {
            color: #d4a574;
        }

        .hex-controls {
            background: #3a3a3a;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .hex-controls label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .hex-controls input {
            width: 100%;
            padding: 8px;
            border: 1px solid #5a5a5a;
            border-radius: 4px;
            background: #2a2a2a;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
        }

        /* Fetch overlay */
        #fetchOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .fetch-overlay-box {
            background: #1f1f1f;
            color: #e0e0e0;
            padding: 20px 28px;
            border-radius: 10px;
            border: 1px solid #444;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
            text-align: center;
            min-width: 260px;
        }

        .fetch-overlay-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .fetch-overlay-text {
            font-size: 14px;
            color: #c9d1d9;
        }

        /* Import popup */
        #importPopup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .import-popup-box {
            background: #2a2a2a;
            color: #e0e0e0;
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #5a6bb8;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            min-width: 500px;
            max-width: 600px;
        }

        .import-popup-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #7a8bdc;
        }

        .import-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #444;
        }

        .import-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .import-tab:hover {
            color: #c9d1d9;
        }

        .import-tab.active {
            color: #7a8bdc;
            border-bottom-color: #7a8bdc;
        }

        .import-tab-content {
            display: none;
        }

        .import-tab-content.active {
            display: block;
        }

        .import-drop-zone {
            border: 2px dashed #5a6bb8;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            background: #333;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .import-drop-zone:hover {
            background: #3a3f5a;
            border-color: #7a6bb8;
        }

        .import-drop-zone.drag-over {
            background: #404560;
            border-color: #8a7bc8;
        }

        .import-field {
            margin-bottom: 20px;
        }

        .import-field label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #c9d1d9;
        }

        .import-field input {
            width: 100%;
            padding: 10px;
            background: #1f1f1f;
            border: 1px solid #444;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }

        .import-preview {
            background: #1f1f1f;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #444;
            margin-bottom: 20px;
            min-height: 80px;
        }

        .import-preview-label {
            font-weight: 600;
            margin-bottom: 10px;
            color: #7a8bdc;
        }

        .import-preview-info {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .import-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Write overlay (red accent) */
        #writeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .write-overlay-box {
            background: #2a1f1f;
            color: #e0e0e0;
            padding: 20px 28px;
            border-radius: 10px;
            border: 1px solid #c44;
            box-shadow: 0 10px 30px rgba(200, 50, 50, 0.45);
            text-align: center;
            min-width: 260px;
        }

        .write-overlay-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #ff6b6b;
        }

        .write-overlay-text {
            font-size: 14px;
            color: #ffcccc;
        }

        /* Device status display */
        #deviceStatusText {
            font-size: 14px;
            padding: 15px;
            border-radius: 5px;
            background: #252525;
            border-left: 4px solid #6ec589;
            word-break: break-word;
            white-space: pre-wrap;
        }

        #deviceStatusText.success {
            border-left-color: #6ec589;
            color: #a8e6b8;
        }

        #deviceStatusText.error {
            border-left-color: #ff6b6b;
            background: #3a2020;
            color: #ffb3b3;
        }

        #deviceStatusText.loading {
            border-left-color: #5a8fd8;
            background: #202540;
            color: #7aafff;
        }

        /* Memory map visualization */
        #memoryMapContainer {
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            display: none;
        }

        #memoryMapContainer h4 {
            margin: 0 0 10px 0;
            color: #7a8bdc;
            font-size: 14px;
        }

        #memoryMap {
            width: 100%;
            height: 40px;
            background: #1a1a1a;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            border: 1px solid #444;
        }

        .memory-segment {
            position: absolute;
            height: 100%;
            top: 0;
            transition: all 0.3s ease;
        }

        .memory-segment.unread {
            background: #3a3a3a;
        }

        .memory-segment.cached {
            background: linear-gradient(180deg, #4CAF50 0%, #2e7d32 100%);
        }

        .memory-segment.cached-ff {
            background: linear-gradient(180deg, #2e7d32 0%, #1b4620 100%);
        }

        .memory-segment.modified {
            background: linear-gradient(180deg, #f44336 0%, #b71c1c 100%);
        }

        .memory-segment.modified-ff {
            background: linear-gradient(180deg, #b23434 0%, #7a1212 100%);
        }

        #memoryMapLegend {
            display: flex;
            gap: 20px;
            margin-top: 8px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid #555;
        }

        .legend-color.unread {
            background: #3a3a3a;
        }

        .legend-color.cached {
            background: #4CAF50;
        }

        .legend-color.cached-ff {
            background: #2e7d32;
        }

        .legend-color.modified {
            background: #f44336;
        }

        .legend-color.modified-ff {
            background: #b23434;
        }

        /* Device popup */
        .device-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 31, 53, 0.95);
            border: 1px solid #4a4f70;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            padding: 12px 14px;
            border-radius: 8px;
            color: #f0f6fc;
            font-size: 14px;
            max-width: 440px;
            z-index: 1000;
            display: none;
            line-height: 1.4;
        }

        .device-popup strong {
            color: #7a8bdc;
        }

        @keyframes blink-red {

            0%,
            100% {
                box-shadow: 0 0 0 rgba(0, 0, 0, 0);
            }

            50% {
                box-shadow: 0 0 12px rgba(248, 81, 73, 0.8);
            }
        }

        .device-popup.secure-warning {
            border-color: #f85149;
            background: rgba(62, 12, 12, 0.95);
            color: #fff;
            animation: blink-red 1s linear infinite;
        }
    </style>
</head>

<body>
    <div id="fetchOverlay">
        <div class="fetch-overlay-box">
            <div class="fetch-overlay-title">Fetching firmwareâ€¦</div>
            <div class="fetch-overlay-text" id="fetchOverlayText">Please wait</div>
        </div>
    </div>
    <div id="writeOverlay">
        <div class="write-overlay-box">
            <div class="write-overlay-title">Writing to Deviceâ€¦</div>
            <div class="write-overlay-text" id="writeOverlayText">Please wait</div>
        </div>
    </div>

    <div id="importPopup">
        <div class="import-popup-box">
            <div class="import-popup-title">ðŸ“¥ Import Binary File</div>

            <div class="import-tabs">
                <button class="import-tab active" onclick="switchImportTab('file')">File</button>
                <button class="import-tab" onclick="switchImportTab('url')">URL</button>
            </div>

            <div id="importTabFile" class="import-tab-content active">
                <div class="import-drop-zone" id="importDropZone"
                    onclick="document.getElementById('importFileInput').click()">
                    <p style="font-size: 1.1em; margin-bottom: 10px;">ðŸ“‚ Drop .bin file here or click to browse</p>
                    <p style="font-size: 0.9em; color: #888;">Selected: <span id="importFileName">None</span></p>
                    <input type="file" id="importFileInput" accept=".bin,.json" style="display: none;">
                </div>
            </div>

            <div id="importTabUrl" class="import-tab-content">
                <div class="import-field" style="margin-bottom: 20px;">
                    <label for="importUrlInput">URL (.bin or .json):</label>
                    <input type="text" id="importUrlInput" placeholder="https://example.com/firmware.bin"
                        style="width: 100%;">
                    <button class="btn" onclick="loadImportUrl()" style="margin-top: 10px; width: 100%;">Load
                        URL</button>
                </div>
            </div>

            <div class="import-field">
                <label for="importAddress">Start Address (Hex):</label>
                <input type="text" id="importAddress" placeholder="0x00000000" value="0x00000000">
            </div>

            <div class="import-field" id="importEraseOption" style="display: none;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="importEraseFlash" checked style="width: auto; cursor: pointer;">
                    <span>Erase Flash (recommended)</span>
                </label>
                <p style="font-size: 0.85em; color: #888; margin-top: 5px; margin-left: 24px;">
                    Remaining data may cause misdetection of partition table
                </p>
            </div>

            <div class="import-preview">
                <div class="import-preview-label">Preview:</div>
                <div class="import-preview-info" id="importPreview">
                    Select a file/URL and enter an address to see preview
                </div>
            </div>

            <div class="import-buttons">
                <button class="btn" onclick="hideImportPopup()"
                    style="background: linear-gradient(135deg, #666 0%, #444 100%);">Cancel</button>
                <button class="btn" id="importApplyBtn" onclick="applyImport()" disabled
                    style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Import</button>
            </div>
        </div>
    </div>
    <div id="devicePopup" class="device-popup"></div>
    <div class="container">
        <div class="header">
            <h1>ESP32 Firmware Editor</h1>
            <p>Reverse engineering & firmware analysis</p>
            <div style="font-size: 0.75em; margin-top: 12px; opacity: 0.7;"><a href="https://www.g3gg0.de">g3gg0.de</a>
            </div>
        </div>

        <div class="content">
            <div class="drop-zone" id="dropZone">
                <p><strong>Drop your ESP32 firmware (.bin) file here</strong></p>
                <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
                    <button class="btn" onclick="document.getElementById('fileInput').click()">Browse Files</button>
                    <button class="btn" id="connectToggleBtn"
                        style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);"
                        onclick="toggleDeviceSession()">Connect to ESP32</button>
                </div>
                <div id="advancedBaudGroup" style="display:none; margin-top:10px; text-align:center;">
                    <label for="advancedBaudSelect" style="font-size:0.9em; color:#a0a0a0;">Baud Rate
                        (advanced):</label>
                    <div style="margin-top:6px;">
                        <select id="advancedBaudSelect"
                            style="padding:8px 10px; border-radius:6px; border:1px solid #5a6bb8; background:#252525; color:#c8c8c8;">
                            <option value="115200">115200</option>
                            <option value="921600" selected>921600</option>
                            <option value="1000000">1000000</option>
                        </select>
                    </div>
                </div>
                <input type="file" id="fileInput" class="file-input" accept=".bin">
            </div>

            <div class="file-info" id="fileInfo">
                <h3 ondblclick="toggleTargetActions()" style="cursor: pointer;"
                    title="Double-click to toggle advanced actions">ðŸŽ¯ Target Information</h3>
                <div class="info-grid" id="fileInfoGrid">
                </div>
                <div id="targetActions" style="display:none; margin-top:12px;">
                    <div id="targetActionsButtons" class="button-group" style="display:none; flex-wrap:wrap; gap:8px;">
                        <button class="btn" id="targetResetBtn" onclick="deviceHardReset()" disabled>Reset</button>
                        <button class="btn" id="targetSyncBtn" onclick="deviceSync()" disabled>Sync</button>
                        <button class="btn" id="targetStubBtn" onclick="deviceLoadStub()" disabled>Download
                            Stub</button>
                        <button class="btn" id="targetFetchBtn" onclick="deviceRefresh()" disabled>Refresh</button>
                    </div>
                </div>
                <div class="button-group" style="display: flex; flex-wrap:wrap; gap:8px;">
                    <button class="btn" id="deviceDisconnectBtn" onclick="toggleDeviceSession()"
                        style="background: linear-gradient(135deg, #b71c1c 0%, #ef5350 100%); display: none;">Disconnect</button>
                    <button class="btn" id="closeFileBtn" onclick="closeFile()"
                        style="background: linear-gradient(135deg, #b71c1c 0%, #ef5350 100%); display: none;">Close
                        File</button>
                    <button class="btn" id="importBinBtn"
                        onclick="showImportPopup(0x00000000, deviceFlashSizeBytes, true, async () => { await parseAndDisplay(true); })"
                        style="display: none; background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Import...</button>
                    <button class="btn" id="eraseFlashBtn" onclick="eraseFlash()"
                        style="display: none; background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);">Erase
                        Flash</button>
                    <button class="btn" id="writeToDeviceBtn" onclick="writeToDevice()"
                        style="display: none; background: linear-gradient(135deg, #b71c1c 0%, #ef5350 100%);">Write to
                        Device</button>
                    <button class="btn" id="saveImageBtn" onclick="saveImage()">Save Image</button>
                </div>
            </div>

            <div id="deviceStatusContainer" style="display: none; margin-bottom: 20px;">
                <div id="deviceStatusText" class="success"
                    style="padding: 15px; border-radius: 5px; background: #252525; border-left: 4px solid #6ec589;">
                </div>
            </div>

            <div id="memoryMapContainer">
                <h4>ðŸ“Š Memory Map</h4>
                <div id="memoryMap" style="cursor: pointer;"></div>
                <div id="memoryMapLegend">
                    <div class="legend-item">
                        <div class="legend-color unread"></div>
                        <span>Unread</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color cached"></div>
                        <span>Cached</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color modified"></div>
                        <span>Modified</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color cached-ff"></div>
                        <span>Cached (0xFF)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color modified-ff"></div>
                        <span>Modified (0xFF)</span>
                    </div>
                </div>
            </div>

            <div id="tabContainer" style="display: none;">
                <div style="display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 10px;">
                </div>
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('bootloader', event)">Bootloader</button>
                    <button class="tab" onclick="switchTab('partitions', event)">Partitions</button>
                    <button class="tab" onclick="switchTab('raw', event)">Hex Viewer</button>
                </div>

                <div class="tab-content active" id="bootloader-tab">
                    <h3>Bootloader</h3>
                    <div id="bootloaderContent"></div>
                </div>

                <div class="tab-content" id="partitions-tab">
                    <h3>Partition Table</h3>
                    <div id="partitionsContent"></div>
                </div>

                <div class="tab-content" id="nvs-tab">
                    <h3>Non-Volatile Storage (NVS)</h3>
                    <div id="nvsContent"></div>
                </div>

                <div class="tab-content" id="raw-tab">
                    <h3>Hex Viewer</h3>
                    <div class="hex-controls">
                        <div>
                            <label for="hexOffset">Offset (hex):</label>
                            <input type="text" id="hexOffset" value="0" placeholder="0x0" onchange="updateHexView()">
                        </div>
                        <div>
                            <label for="hexLength">Length (hex):</label>
                            <input type="text" id="hexLength" value="100" placeholder="0x100"
                                onchange="updateHexView()">
                        </div>
                        <div>
                            <label for="hexWidth">Width (bytes/line):</label>
                            <input type="number" id="hexWidth" value="32" min="4" max="64" step="4"
                                onchange="updateHexView()">
                        </div>
                        <div style="display: flex; align-items: flex-end;">
                            <button class="btn" onclick="updateHexView()">Update View</button>
                        </div>
                    </div>
                    <div id="rawContent"></div>
                </div>
            </div>

            <input type="file" id="partitionFileInput" class="file-input" style="display:none" accept=".bin">
        </div>
    </div>

    <script src="chips.js"></script>
    <script src="flasher.js"></script>
    <script src="esp32-parser.js"></script>
    <script>
        let parser = null;
        let currentFile = null;
        let replaceTargetPartition = null;

        let deviceFlasher = null;
        let deviceMode = false;
        let deviceMac = null;
        let devicePopupTimer = null;
        let devicePopupContent = '';
        let deviceFlashSizeBytes = 0x00800000; /* Default 8 MiB */
        let deviceReadProgressTotal = 0;
        let deviceReadProgressDone = 0;
        let fetchOverlayReason = '';
        let fetchOverlayActiveReads = 0;
        let intentionalDisconnect = false; /* Track intentional disconnects */
        let bootloaderInfo = null;
        let partitionTableOffset = null;
        let isDebugMode = window.location.hash.includes('debug');
        let isAdvancedMode = window.location.hash.includes('advanced');
        let selectedBaudRate = 921600;

        /* Performance tracking for read/write operations */
        let readStartTime = null;
        let readSlowWarningShown = false;
        let readWarningShownTime = null;
        let readWarningHideTimeout = null;
        let writeStartTime = null;
        let writeSlowWarningShown = false;
        let writeWarningShownTime = null;
        let writeWarningHideTimeout = null;
        const SLOW_SPEED_THRESHOLD = 50 * 1024; /* 200 KiB/s in bytes/s */
        const SPEED_CHECK_DELAY = 5000; /* 1 second before checking speed */
        const WARNING_MIN_DISPLAY_TIME = 10000; /* Keep warning visible for at least 10 seconds */

        async function openFlasherMenu() {
            await toggleDeviceSession();
        }

        async function toggleDeviceSession() {
            const btn = document.getElementById('connectToggleBtn');
            const isDisconnect = btn && btn.dataset.state === 'connected';

            if (isDisconnect) {
                await disconnectDeviceSession();
                return;
            }

            try {
                setDeviceStatus('Requesting serial port...', 'loading');
                deviceFlasher = new ESPFlasher({
                    initialBaudRate: selectedBaudRate,
                    logMessage: (msg) => console.log('[Flasher]', msg),
                    logWarning: (msg) => console.warn('[Flasher WARNING]', msg),
                    logError: (msg) => console.error('[Flasher ERROR]', msg),
                    logDebug: (msg) => { isDebugMode ?? console.log('[Flasher DEBUG]', msg); },
                    logPackets: isDebugMode,
                });

                /* Set up callback for unexpected device disconnection */
                deviceFlasher.disconnected = () => {
                    handleUnexpectedDeviceDisconnect();
                };

                deviceFlasher.deviceStateCallback = (state, data) => {
                    if (state === 'secure') {
                        showSecureModError('Secure bootloader detected. Flash access is disabled.');
                    } else if (state === 'secure_boot') {
                        showSecureModError('Secure bootloader detected. Flash access is disabled.');
                    } else if (state === 'secure_download') {
                        showSecureModError('Secure download mode detected.<br>Flash readout is disabled. Write would brick the device.');
                    } else {
                        const msg = formatDeviceStateMessage(state, data);
                        showDevicePopup(msg, state);
                    }
                };

                /* Detect Android and use WebUSB (Web Serial not available on Android) */
                const isAndroid = /Android/i.test(navigator.userAgent);
                if (isAndroid) {
                    console.log('Android device detected, using WebUSB');
                    setDeviceStatus('Android detected - using WebUSB', 'info');
                    const port = await WebUSBSerial.requestPort();
                    await deviceFlasher.openPortWithPort(port);
                } else {
                    console.log('Desktop detected, using Web Serial API');
                    await deviceFlasher.openPort(); // Use Web Serial (default)
                }
                setDeviceButtons({ connected: true });

                /* Try hard reset + sync across baud rates: default, 250000, 115200 */
                let synced = false;
                const baudCandidates = [deviceFlasher.initialBaudRate, 250000, 115200];
                for (const baud of baudCandidates) {
                    try {
                        if (baud && baud !== deviceFlasher.initialBaudRate) {
                            await deviceFlasher.reopenPort(baud);
                        }
                        setDeviceStatus('Resetting ESP32...', 'loading');
                        await deviceFlasher.hardReset(true);

                        setDeviceStatus('Syncing...', 'loading');
                        await deviceFlasher.sync();
                        synced = true;
                        break;
                    } catch (err) {
                        setDeviceStatus('Sync failed' + (baud ? ` at ${baud} baud` : '') + ': ' + err.message, 'error');
                    }
                }
                if (!synced) {
                    deviceFlasher.disconnect();
                    throw new Error('Failed to sync after trying default, 250000, 115200 baud.');
                }

                // Read MAC address after successful sync
                try {
                    deviceMac = await deviceFlasher.readMac();
                } catch (macErr) {
                    console.warn('Could not read device MAC:', macErr);
                    deviceMac = null;
                }

                const isStub = await deviceFlasher.isStubLoader();
                setDeviceButtons({ connected: true, synced: true, stub: isStub });

                if (!isStub) {
                    setDeviceStatus('Loading stub...', 'loading');
                    const stubLoaded = await deviceFlasher.downloadStub();
                    setDeviceButtons({ connected: true, synced: true, stub: stubLoaded });
                }

                setDeviceStatus('Fetching bootloader and partition table...', 'loading');
                setFetchOverlayReason('Reading flash from ESP32');
                showFetchOverlay('Reading flash from ESP32...');
                deviceMode = true;
                deviceReadProgressTotal = deviceFlashSizeBytes;
                deviceReadProgressDone = 0;
                const totalSize = deviceFlashSizeBytes;

                parser = new ESP32Parser(deviceFlasher, {
                    sizeHint: totalSize,
                    logMessage: (msg) => console.log('[Parser]', msg),
                    logWarning: (msg) => console.warn('[Parser WARNING]', msg),
                    logError: (msg) => console.error('[Parser ERROR]', msg),
                    logDebug: (msg) => { },
                    preReadCommandCbr: (addr, len) => {
                        deviceReadProgressDone = 0;
                        deviceReadProgressTotal = len;
                        fetchOverlayActiveReads++;
                        if (!isFetchOverlayVisible()) {
                            showFetchOverlay(fetchOverlayReason || 'Reading flash from ESP32...');
                        }
                    },
                    readBlockCbr: (addr, len, bytesRead, totalBytes) => {
                        deviceReadProgressDone = bytesRead;
                        const now = Date.now();
                        if (now - lastProgressUpdateTime >= UPDATE_THROTTLE_MS) {
                            lastProgressUpdateTime = now;
                            updateFetchOverlayProgress(addr + deviceReadProgressDone, deviceReadProgressDone, deviceReadProgressTotal);
                        }
                    },
                    postReadCommandCbr: (addr, len) => {
                        const now = Date.now();
                        if (now - lastProgressUpdateTime >= UPDATE_THROTTLE_MS) {
                            lastProgressUpdateTime = now;
                            updateFetchOverlayProgress(addr + len, deviceReadProgressDone, deviceReadProgressTotal);
                        }
                        if (--fetchOverlayActiveReads === 0) {
                            hideFetchOverlay();
                        }
                    },
                    preWriteCommandCbr: (addr, len) => {
                        showWriteOverlay('Writing to device...');
                    },
                    writeBlockCbr: (addr, len, bytesWritten, totalBytes, status) => {
                        updateWriteOverlayProgress(addr + bytesWritten, bytesWritten, totalBytes, status);
                    },
                    postWriteCommandCbr: (addr, len) => {
                        hideWriteOverlay();
                        updateMemoryMap();
                    }
                });
                displaySourceInfo({
                    name: 'ESP32 Device',
                    size: totalSize,
                    type: `device/${deviceFlasher.current_chip || 'esp32'}`,
                    lastModified: Date.now()
                });

                parser.logMessage = (msg) => {
                    console.log('Parser:', msg);
                };
                parser.logError = (msg) => {
                    console.error('Parser:', msg);
                };
                if (isDebugMode) {
                    parser.logDebug = (msg) => {
                        console.log('Parser:', msg);
                    };
                }

                await parseAndDisplay(true);
                setDeviceStatus('Connected to ' + deviceFlasher.current_chip + '. Firmware loaded and parsed.', 'success');
                setToggleButtonState(true);

                /* Hide file drop/browse when in device mode */
                const dropZone = document.getElementById('dropZone');
                if (dropZone) dropZone.style.display = 'none';
            } catch (e) {
                if (deviceFlasher) {
                    try {
                        deviceFlasher.disconnect();
                    } catch (disconnectError) {
                        //console.warn('Error during disconnect:', disconnectError);
                    }
                }
                setDeviceStatus('Connection failed: ' + e.message, 'error');
                setDeviceButtons({ connected: false });
                setToggleButtonState(false);
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
                /* Update memory map after all reads complete */
                updateMemoryMap();
            }
        }

        async function disconnectDeviceSession() {
            intentionalDisconnect = true;
            if (deviceFlasher) {
                try {
                    await deviceFlasher.disconnect();
                } catch (e) {
                    console.warn('Device disconnect error:', e);
                }
            }

            clearDeviceState();
        }

        function handleUnexpectedDeviceDisconnect() {
            /* Called when device is unexpectedly disconnected (pulled out, lost connection, etc) */
            if (!intentionalDisconnect) {
                setDeviceStatus('Device unexpectedly disconnected. Please reconnect.', 'error');
            }

            /* Hide any active overlays */
            hideFetchOverlay();
            hideWriteOverlay();

            clearDeviceState();
        }

        function closeFile() {
            /* Close the currently loaded file and reset UI to initial state */
            parser = null;
            currentFile = null;
            deviceMode = false;

            /* Hide file info section */
            const fileInfo = document.getElementById('fileInfo');
            if (fileInfo) {
                fileInfo.classList.remove('visible');
            }

            /* Hide tab container */
            const tabContainer = document.getElementById('tabContainer');
            if (tabContainer) {
                tabContainer.style.display = 'none';
            }

            /* Hide memory map */
            const memoryMapContainer = document.getElementById('memoryMapContainer');
            if (memoryMapContainer) {
                memoryMapContainer.style.display = 'none';
            }

            /* Clear content divs */
            const contentDivs = [
                document.getElementById('bootloaderContent'),
                document.getElementById('partitionsContent'),
                document.getElementById('rawContent')
            ];
            contentDivs.forEach(div => {
                if (div) div.innerHTML = '';
            });

            /* Hide Save Image and Close File buttons */
            const saveBtn = document.getElementById('saveImageBtn');
            if (saveBtn) saveBtn.style.display = 'none';
            const closeBtn = document.getElementById('closeFileBtn');
            if (closeBtn) closeBtn.style.display = 'none';

            /* Show file drop/browse zone */
            const dropZone = document.getElementById('dropZone');
            if (dropZone) dropZone.style.display = 'block';
        }

        function clearDeviceState() {
            /* Clear all device information and reset to disconnected state */
            deviceFlasher = null;
            deviceMode = false;
            deviceMac = null;
            parser = null;

            setDeviceButtons({ connected: false, synced: false, stub: false });
            setToggleButtonState(false);

            /* Hide file info section */
            const fileInfo = document.getElementById('fileInfo');
            if (fileInfo) {
                fileInfo.classList.remove('visible');
            }

            /* Hide tab container */
            const tabContainer = document.getElementById('tabContainer');
            if (tabContainer) {
                tabContainer.style.display = 'none';
            }

            /* Hide memory map */
            const memoryMapContainer = document.getElementById('memoryMapContainer');
            if (memoryMapContainer) {
                memoryMapContainer.style.display = 'none';
            }

            /* Clear content in all tabs */
            const contentDivs = document.querySelectorAll('[id$="Content"]');
            contentDivs.forEach(div => {
                div.innerHTML = '';
            });

            /* Keep Save Image button visible even when disconnected */
            const saveBtn = document.getElementById('saveImageBtn');
            if (saveBtn) {
                saveBtn.style.display = 'inline-block';
            }

            /* Show file drop/browse when disconnected */
            const dropZone = document.getElementById('dropZone');
            if (dropZone) dropZone.style.display = 'block';

            const popup = document.getElementById('devicePopup');
            if (popup) {
                popup.style.display = 'none';
                popup.classList.remove('secure-warning');
            }
            devicePopupContent = '';
            if (devicePopupTimer) {
                clearTimeout(devicePopupTimer);
                devicePopupTimer = null;
            }
        }

        /**
         * Update memory map visualization
         */
        async function updateMemoryMap() {
            if (!parser) return;

            const container = document.getElementById('memoryMapContainer');
            const map = document.getElementById('memoryMap');

            if (!container || !map) return;

            /* Show the map */
            container.style.display = 'block';

            /* Clear existing segments */
            map.innerHTML = '';

            let totalSize = 0;
            let readBuffer = [];
            let writeBuffer = [];

            /* Get data based on mode */
            if (parser.sparseImage) {
                /* Device mode or sparse image */
                totalSize = parser.sparseImage.size;
                readBuffer = parser.sparseImage.readBuffer || [];
                writeBuffer = parser.sparseImage.writeBuffer || [];
            } else {
                container.style.display = 'none';
                return;
            }

            /* Create a coverage map */
            const segmentSize = Math.max(1, Math.floor(totalSize / 1000)); /* 1000 segments max */
            const segments = [];

            for (let i = 0; i < totalSize; i += segmentSize) {
                const end = Math.min(i + segmentSize, totalSize);
                segments.push({ start: i, end: end, type: 'unread' });
            }

            /* Mark cached regions (readBuffer) */
            for (const read of readBuffer) {
                const readStart = read.address;
                const readEnd = read.address + read.data.length;

                for (let seg of segments) {
                    if (seg.end <= readStart || seg.start >= readEnd) continue;

                    /* Check if this segment is all 0xFF (erased) by examining 512-byte blocks */
                    const segStart = Math.max(seg.start, readStart);
                    const segEnd = Math.min(seg.end, readEnd);
                    const blockSize = 512;
                    let isAllFF = true;

                    /* Check 512-byte blocks within this segment */
                    for (let blockAddr = Math.floor(segStart / blockSize) * blockSize; blockAddr < segEnd; blockAddr += blockSize) {
                        const blockEnd = Math.min(blockAddr + blockSize, segEnd);
                        if (blockEnd <= blockAddr) continue;

                        /* Get data for this block from readBuffer */
                        const offsetInRead = Math.max(blockAddr - readStart, 0);
                        const blockDataLen = blockEnd - Math.max(blockAddr, readStart);

                        /* Check if block data is available and all 0xFF */
                        if (offsetInRead < read.data.length) {
                            const blockData = read.data.slice(offsetInRead, offsetInRead + blockDataLen);
                            let blockIsFF = blockData.length > 0 && Array.from(blockData).every(byte => byte === 0xFF);

                            if (!blockIsFF) {
                                isAllFF = false;
                                break;
                            }
                        }
                    }

                    /* Mark segment as 'cached' (normal green) or 'cached-ff' (darker green) */
                    seg.type = isAllFF ? 'cached-ff' : 'cached';
                }
            }

            /* Mark modified regions (writeBuffer) - these override cached */
            for (const write of writeBuffer) {
                const writeStart = write.address;
                const writeEnd = write.address + write.data.length;

                for (let seg of segments) {
                    if (seg.end <= writeStart || seg.start >= writeEnd) continue;

                    const overlapStart = Math.max(seg.start, writeStart);
                    const overlapEnd = Math.min(seg.end, writeEnd);
                    const off = overlapStart - writeStart;
                    const len = overlapEnd - overlapStart;

                    let isAllFF = true;
                    for (let i = 0; i < len; i++) {
                        if (write.data[off + i] !== 0xFF) {
                            isAllFF = false;
                            break;
                        }
                    }

                    seg.type = isAllFF ? 'modified-ff' : 'modified';
                }
            }

            /* Render segments - merge adjacent segments of same type to avoid gaps */
            const mergedSegments = [];
            for (let i = 0; i < segments.length; i++) {
                const seg = segments[i];
                if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === seg.type) {
                    /* Extend previous segment */
                    mergedSegments[mergedSegments.length - 1].end = seg.end;
                } else {
                    /* New segment */
                    mergedSegments.push({ start: seg.start, end: seg.end, type: seg.type });
                }
            }

            for (const seg of mergedSegments) {
                const div = document.createElement('div');
                div.className = `memory-segment ${seg.type}`;
                const leftPercent = (seg.start / totalSize) * 100;
                const widthPercent = ((seg.end - seg.start) / totalSize) * 100;
                div.style.left = leftPercent + '%';
                div.style.width = widthPercent + '%';
                div.title = `0x${seg.start.toString(16).toUpperCase()} - 0x${seg.end.toString(16).toUpperCase()} (${seg.type})`;
                map.appendChild(div);
            }

            /* Collect all labeled areas: bootloader + partitions */
            const areas = [];

            /* Add bootloader */
            if (bootloaderInfo && bootloaderInfo.bootloaderStart !== undefined && bootloaderInfo.bootloaderEnd !== undefined) {
                areas.push({
                    label: 'bootloader',
                    start: bootloaderInfo.bootloaderStart,
                    end: bootloaderInfo.bootloaderEnd,
                    color: '#8B4513'
                });
            }

            /* Add partitions */
            if (parser.partitions && parser.partitions.length > 0) {
                parser.partitions.forEach(part => {
                    areas.push({
                        label: part.label,
                        start: part.offset,
                        end: part.offset + part.length,
                        color: part.type === 0 ? '#60FFFF' : '#7F30FF'
                    });
                });
            }

            /* Sort by start offset */
            areas.sort((a, b) => a.start - b.start);

            /* Set up container for absolute positioning of popups */
            map.parentNode.style.position = 'relative';

            const MIN_WIDTH_FOR_INLINE = 100; /* pixels for inline label */

            /* Create inline labels for large partitions */
            areas.forEach(area => {
                const leftPercent = (area.start / totalSize) * 100;
                const widthPercent = ((area.end - area.start) / totalSize) * 100;
                const mapWidth = map.offsetWidth || 800; /* fallback */
                const areaPixelWidth = (widthPercent / 100) * mapWidth;
                const isInline = areaPixelWidth >= MIN_WIDTH_FOR_INLINE;

                if (isInline) {
                    /* Inline label with vertical borders - always visible */
                    const labelDiv = document.createElement('div');
                    labelDiv.style.position = 'absolute';
                    labelDiv.style.left = leftPercent + '%';
                    labelDiv.style.width = widthPercent + '%';
                    labelDiv.style.top = '0';
                    labelDiv.style.bottom = '0';
                    labelDiv.style.display = 'flex';
                    labelDiv.style.alignItems = 'center';
                    labelDiv.style.justifyContent = 'center';
                    labelDiv.style.borderLeft = `2px solid ${area.color}`;
                    labelDiv.style.borderRight = `2px solid ${area.color}`;
                    labelDiv.style.color = area.color;
                    labelDiv.style.textShadow = '0 0 9px rgba(128,128,128,0.9)';
                    labelDiv.style.fontSize = '12px';
                    labelDiv.style.fontWeight = 'bold';
                    labelDiv.style.pointerEvents = 'none';
                    labelDiv.style.zIndex = '20';
                    labelDiv.textContent = area.label;
                    map.appendChild(labelDiv);

                    /* Create highlight overlay for hover effect */
                    const highlightDiv = document.createElement('div');
                    highlightDiv.style.position = 'absolute';
                    highlightDiv.style.left = leftPercent + '%';
                    highlightDiv.style.width = widthPercent + '%';
                    highlightDiv.style.top = '0';
                    highlightDiv.style.bottom = '0';
                    highlightDiv.style.backgroundColor = area.color;
                    highlightDiv.style.opacity = '0.3';
                    highlightDiv.style.display = 'none';
                    highlightDiv.style.pointerEvents = 'none';
                    highlightDiv.style.zIndex = '15';
                    map.appendChild(highlightDiv);

                    /* Create hover area that covers full height */
                    const hoverDiv = document.createElement('div');
                    hoverDiv.style.position = 'absolute';
                    hoverDiv.style.left = leftPercent + '%';
                    hoverDiv.style.width = widthPercent + '%';
                    hoverDiv.style.top = '0';
                    hoverDiv.style.bottom = '0';
                    hoverDiv.style.cursor = 'pointer';
                    hoverDiv.style.zIndex = '21';

                    hoverDiv.addEventListener('mouseenter', () => {
                        highlightDiv.style.display = 'block';
                    });
                    hoverDiv.addEventListener('mouseleave', () => {
                        highlightDiv.style.display = 'none';
                    });

                    map.appendChild(hoverDiv);
                }
            });

            /* Create single global popup for all partitions */
            const globalPopup = document.createElement('div');
            globalPopup.style.position = 'absolute';
            globalPopup.style.display = 'none';
            globalPopup.style.background = '#303030';
            globalPopup.style.border = '1px solid #333';
            globalPopup.style.padding = '4px 8px';
            globalPopup.style.borderRadius = '3px';
            globalPopup.style.whiteSpace = 'nowrap';
            globalPopup.style.color = '#333';
            globalPopup.style.fontSize = '12px';
            globalPopup.style.fontWeight = 'bold';
            globalPopup.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
            globalPopup.style.pointerEvents = 'none';
            globalPopup.style.zIndex = '30';
            map.parentNode.appendChild(globalPopup);

            /* Create global connecting line */
            const globalLine = document.createElement('div');
            globalLine.style.position = 'absolute';
            globalLine.style.width = '1px';
            globalLine.style.height = '8px';
            globalLine.style.backgroundColor = '#333';
            globalLine.style.display = 'none';
            globalLine.style.pointerEvents = 'none';
            globalLine.style.zIndex = '25';
            map.parentNode.appendChild(globalLine);

            /* Add mousemove handler to show single popup with current address and partition */
            /* Remove old listeners first to prevent duplicates */
            map.removeEventListener('mousemove', map._memoryMapMoveListener);
            map.removeEventListener('mouseleave', map._memoryMapLeaveListener);

            /* Create new listener function and store reference to remove later */
            map._memoryMapMoveListener = function (e) {
                const mapRect = map.getBoundingClientRect();
                const containerRect = map.parentNode.getBoundingClientRect();
                const cursorX = e.clientX - mapRect.left;
                const cursorPercent = cursorX / mapRect.width;
                const addressAtCursor = Math.floor(cursorPercent * totalSize);

                /* Find which partition contains this address */
                const currentArea = areas.find(area => addressAtCursor >= area.start && addressAtCursor < area.end);

                //console.log(`Address: 0x${addressAtCursor.toString(16).toUpperCase()}, Partition: ${currentArea ? currentArea.label : 'NONE'}`);

                if (currentArea) {
                    /* Show popup for the current partition */
                    globalPopup.style.display = 'block';
                    globalLine.style.display = 'block';
                    globalPopup.textContent = `${currentArea.label} @ 0x${addressAtCursor.toString(16).toUpperCase()}`;
                    globalPopup.style.borderColor = currentArea.color;
                    globalPopup.style.color = currentArea.color;
                    globalLine.style.backgroundColor = currentArea.color;

                    /* Position popup above cursor */
                    const cursorXRelativeToContainer = e.clientX - containerRect.left;
                    globalPopup.style.left = cursorXRelativeToContainer + 'px';
                    globalPopup.style.transform = 'translateX(-50%)';
                    globalPopup.style.top = (mapRect.top - containerRect.top - 22) + 'px';

                    /* Position line above bar at cursor */
                    globalLine.style.left = cursorXRelativeToContainer + 'px';
                    globalLine.style.transform = 'translateX(-50%)';
                    globalLine.style.top = (mapRect.top - containerRect.top - 8) + 'px';
                } else {
                    /* No partition at cursor, hide popup */
                    globalPopup.style.display = 'none';
                    globalLine.style.display = 'none';
                }
            };

            map._memoryMapLeaveListener = function () {
                globalPopup.style.display = 'none';
                globalLine.style.display = 'none';
            };

            map.addEventListener('mousemove', map._memoryMapMoveListener);
            map.addEventListener('mouseleave', map._memoryMapLeaveListener);

            /* Add click handler to show segments in console */
            map.onclick = () => {
                console.log('=== Memory Map Segments ===');
                console.log(`Total Size: 0x${totalSize.toString(16).toUpperCase()} (${formatBytes(totalSize)})`);
                console.log('\nRead Buffer Segments:');
                readBuffer.forEach((seg, idx) => {
                    console.log(`  [${idx}] 0x${seg.address.toString(16).toUpperCase()} - 0x${(seg.address + seg.data.length).toString(16).toUpperCase()} (${formatBytes(seg.data.length)})`);
                });
                console.log('\nWrite Buffer Segments:');
                writeBuffer.forEach((seg, idx) => {
                    console.log(`  [${idx}] 0x${seg.address.toString(16).toUpperCase()} - 0x${(seg.address + seg.data.length).toString(16).toUpperCase()} (${formatBytes(seg.data.length)})`);
                });
                console.log('\nMerged Display Segments:');
                mergedSegments.forEach((seg, idx) => {
                    console.log(`  [${idx}] 0x${seg.start.toString(16).toUpperCase()} - 0x${seg.end.toString(16).toUpperCase()} (${seg.type})`);
                });
            };
        }

        function setToggleButtonState(connected) {
            const btn = document.getElementById('connectToggleBtn');
            if (!btn) return;
            if (connected) {
                btn.textContent = 'Disconnect';
                btn.style.background = 'linear-gradient(135deg, #b71c1c 0%, #ef5350 100%)';
                btn.dataset.state = 'connected';
            } else {
                btn.textContent = 'Connect to ESP32';
                btn.style.background = 'linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%)';
                btn.dataset.state = 'disconnected';
            }
        }

        function toggleTargetActions() {
            const targetActions = document.getElementById('targetActionsButtons');
            if (targetActions) {
                const isVisible = targetActions.style.display !== 'none';
                targetActions.style.display = isVisible ? 'none' : 'block';
            }
        }

        function setDeviceButtons({ connected = false, synced = false, stub = false }) {
            const targetActions = document.getElementById('targetActions');
            if (targetActions) {
                targetActions.style.display = connected ? 'block' : 'none';
            }

            const btnReset = document.getElementById('targetResetBtn');
            const btnSync = document.getElementById('targetSyncBtn');
            const btnStub = document.getElementById('targetStubBtn');
            const btnFetch = document.getElementById('targetFetchBtn');
            const btnDisconnect = document.getElementById('deviceDisconnectBtn');

            if (btnReset) btnReset.disabled = !connected;
            if (btnSync) btnSync.disabled = !connected;
            if (btnStub) btnStub.disabled = !synced || stub;
            if (btnFetch) btnFetch.disabled = !synced;
            if (btnDisconnect) btnDisconnect.style.display = connected ? 'block' : 'none';
        }

        function setDeviceStatus(text, cls = 'success') {
            const el = document.getElementById('deviceStatusText');
            const container = document.getElementById('deviceStatusContainer');
            if (el && container) {
                el.className = cls;
                el.textContent = text;
                container.style.display = 'block';
                container.style.opacity = '1';
                container.style.transition = 'opacity 0.5s ease-out';

                /* Fade out after 5 seconds */
                setTimeout(() => {
                    container.style.opacity = '0';
                    setTimeout(() => {
                        container.style.display = 'none';
                    }, 500);
                }, 10000);
            } else {
                console.log(`[${cls}] ${text}`);
            }
        }

        function setupAdvancedControls() {
            const group = document.getElementById('advancedBaudGroup');
            const select = document.getElementById('advancedBaudSelect');

            if (!group || !select) {
                return;
            }

            if (!isAdvancedMode) {
                group.style.display = 'none';
                return;
            }

            group.style.display = 'block';
            select.value = selectedBaudRate.toString();

            select.addEventListener('change', () => {
                const nextBaud = parseInt(select.value, 10);
                if (!Number.isFinite(nextBaud)) {
                    return;
                }
                selectedBaudRate = nextBaud;
                if (deviceFlasher) {
                    deviceFlasher.initialBaudRate = selectedBaudRate;
                }
                setDeviceStatus(`Baud set to ${selectedBaudRate} (advanced)`, 'info');
            });

            setDeviceStatus('Advanced baud selector enabled (#advanced).', 'info');
        }

        function showDevicePopup(message, state = null) {
            const popup = document.getElementById('devicePopup');
            if (!popup) {
                return;
            }

            if (popup.style.display !== 'none' && devicePopupContent) {
                devicePopupContent += '\n' + message;
            } else {
                devicePopupContent = message;
            }

            popup.innerHTML = '<strong>Device Info</strong><br>' + devicePopupContent.replace(/\n/g, '<br>');
            if (state === 'secure') {
                popup.classList.add('secure-warning');
            } else {
                popup.classList.remove('secure-warning');
            }
            popup.style.display = 'block';

            if (devicePopupTimer) {
                clearTimeout(devicePopupTimer);
            }
            devicePopupTimer = setTimeout(() => {
                popup.style.display = 'none';
                devicePopupContent = '';
            }, 5000);
        }

        function formatDeviceStateMessage(state, data) {
            if (state === 'secure') {
                return 'âš ï¸ Warning: Device is secured, this tool won\'t work with it';
            }
            if (state === 'download') {
                return 'Device waiting for download (ROM bootloader)';
            }
            if (state === 'reboot' && data) {
                const rstHex = '0x' + (data.rst ?? 0).toString(16);
                const rstName = data.rstName || 'UNKNOWN';
                const bootHex = '0x' + (data.boot ?? 0).toString(16);
                return `Reboot: ${rstName} (${rstHex}), boot=${bootHex}`;
            }
            return `Device state: ${state}`;
        }

        function showFetchOverlay(text) {
            const overlay = document.getElementById('fetchOverlay');
            const label = document.getElementById('fetchOverlayText');

            setFetchOverlayReason(text);
            if (overlay) {
                overlay.style.display = 'flex';
            }
            readStartTime = Date.now();
            readSlowWarningShown = false;
            lastProgressPercent = -1; /* Reset percentage tracker for new operation */
        }

        function setFetchOverlayReason(reason) {
            fetchOverlayReason = reason || '';
            const overlay = document.getElementById('fetchOverlay');
            const label = document.getElementById('fetchOverlayText');
            if (overlay && label && overlay.style.display === 'flex') {
                label.textContent = fetchOverlayReason || label.textContent || 'Fetching firmware...';
            }
        }

        function isFetchOverlayVisible() {
            const overlay = document.getElementById('fetchOverlay');
            return overlay && overlay.style.display === 'flex';
        }

        let lastProgressPercent = -1;
        let pendingProgressUpdate = null;
        let lastProgressUpdateTime = 0;
        let lastMemoryMapUpdateTime = 0;
        const UPDATE_THROTTLE_MS = 50;

        async function updateFetchOverlayProgress(address, bytesRead, totalBytes) {
            const pct = totalBytes > 0 ? Math.min(100, Math.round((bytesRead / totalBytes) * 100)) : 0;

            /* Skip update if percentage hasn't changed (reduces redundant DOM updates) */
            if (pct === lastProgressPercent && pct !== 0 && pct !== 100) {
                return;
            }

            /* Reset speed calculation if progress went backwards (new read started) */
            if (pct < lastProgressPercent) {
                readStartTime = Date.now();
            }
            lastProgressPercent = pct;


            /* Defer DOM update to next animation frame to avoid blocking WebUSB loop */
            if (pendingProgressUpdate) {
                cancelAnimationFrame(pendingProgressUpdate);
            }
            pendingProgressUpdate = requestAnimationFrame(() => {
                pendingProgressUpdate = null;
                const label = document.getElementById('fetchOverlayText');
                if (!label) {
                    return;
                }

                const kbRead = Math.round(bytesRead / 1024);
                const kbTotal = Math.round(totalBytes / 1024);

                let text = `Reading 0x${address.toString(16).toUpperCase()} (${pct}% â€“ ${kbRead} / ${kbTotal} KB)`;
                let addWarning = false;

                /* Calculate speed if operation has been running > 1 second */
                if (readStartTime) {
                    const elapsedMs = Date.now() - readStartTime;
                    if (elapsedMs > SPEED_CHECK_DELAY && bytesRead > 0) {
                        const speedBytesPerSec = (bytesRead / elapsedMs) * 1000;
                        const speedKiBPerSec = Math.round(speedBytesPerSec / 1024);
                        text += ` - ${speedKiBPerSec} KiB/s`;

                        /* Show warning if speed is too slow */
                        if (speedBytesPerSec < SLOW_SPEED_THRESHOLD) {
                            addWarning = true;
                            if (!readSlowWarningShown) {
                                readSlowWarningShown = true;
                                readWarningShownTime = Date.now();
                            }
                        }
                    }
                } else if (readSlowWarningShown && readWarningShownTime) {
                    /* Keep showing warning if still within minimum display time */
                    const warningElapsedMs = Date.now() - readWarningShownTime;
                    if (warningElapsedMs < WARNING_MIN_DISPLAY_TIME) {
                        addWarning = true;
                    }
                }
                if (addWarning) {
                    text += `<br><br>âš ï¸ SLOW: due to hardware/stub bug, ESP32-S3 and C3 are very slow with onchip USB-JTAG`;
                }

                label.innerHTML = text;
            });
        }

        function hideFetchOverlay() {
            const overlay = document.getElementById('fetchOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            fetchOverlayActiveReads = 0;
            readStartTime = null;
            /* Clear any existing timeout and set new one for warning minimum display time */
            if (readWarningHideTimeout) {
                clearTimeout(readWarningHideTimeout);
            }
            if (readSlowWarningShown && readWarningShownTime) {
                const timeElapsed = Date.now() - readWarningShownTime;
                const timeRemaining = Math.max(0, WARNING_MIN_DISPLAY_TIME - timeElapsed);
                readWarningHideTimeout = setTimeout(() => {
                    readSlowWarningShown = false;
                    readWarningShownTime = null;
                    readWarningHideTimeout = null;
                }, timeRemaining);
            }
        }

        function showWriteOverlay(text) {
            const overlay = document.getElementById('writeOverlay');
            const label = document.getElementById('writeOverlayText');
            if (label) {
                label.textContent = text || 'Writing to device...';
            }
            if (overlay) {
                overlay.style.display = 'flex';
            }
            writeStartTime = Date.now();
            writeSlowWarningShown = false;
            writeWarningShownTime = null;
        }

        function updateWriteOverlayProgress(address, bytesWritten, totalBytes, statusText = '') {
            const label = document.getElementById('writeOverlayText');
            if (!label) {
                return;
            }

            const kbWritten = Math.round(bytesWritten / 1024);
            const kbTotal = Math.round(totalBytes / 1024);
            const pct = totalBytes > 0 ? Math.min(100, Math.round((bytesWritten / totalBytes) * 100)) : 0;

            let text = `${statusText} 0x${address.toString(16).toUpperCase()} (${pct}% â€“ ${kbWritten} / ${kbTotal} KB)`;
            let addWarning = false;

            /* Calculate speed if operation has been running > 1 second */
            if (writeStartTime) {
                const elapsedMs = Date.now() - writeStartTime;
                if (elapsedMs > SPEED_CHECK_DELAY && bytesWritten > 0) {
                    const speedBytesPerSec = (bytesWritten / elapsedMs) * 1000;
                    const speedKiBPerSec = Math.round(speedBytesPerSec / 1024);
                    text += ` - ${speedKiBPerSec} KiB/s`;

                    /* Show warning if speed is too slow */
                    if (speedBytesPerSec < SLOW_SPEED_THRESHOLD) {
                        addWarning = true;
                        if (!writeSlowWarningShown) {
                            writeSlowWarningShown = true;
                            writeWarningShownTime = Date.now();
                        }
                    }
                }
            } else if (writeSlowWarningShown && writeWarningShownTime) {
                /* Keep showing warning if still within minimum display time */
                const warningElapsedMs = Date.now() - writeWarningShownTime;
                if (warningElapsedMs < WARNING_MIN_DISPLAY_TIME) {
                    addWarning = true;
                }
            }
            if (addWarning) {
                text += `<br><br>âš ï¸ SLOW: due to hardware/stub bug, ESP32-S3 and C3 are very slow with onchip USB-JTAG`;
            }

            label.innerHTML = text;
        }

        function hideWriteOverlay() {
            const overlay = document.getElementById('writeOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            writeStartTime = null;
            /* Clear any existing timeout and set new one for warning minimum display time */
            if (writeWarningHideTimeout) {
                clearTimeout(writeWarningHideTimeout);
            }
            if (writeSlowWarningShown && writeWarningShownTime) {
                const timeElapsed = Date.now() - writeWarningShownTime;
                const timeRemaining = Math.max(0, WARNING_MIN_DISPLAY_TIME - timeElapsed);
                writeWarningHideTimeout = setTimeout(() => {
                    writeSlowWarningShown = false;
                    writeWarningShownTime = null;
                    writeWarningHideTimeout = null;
                }, timeRemaining);
            }
        }

        function showSecureModError(msg) {
            /* If overlay exists, update its message and keep it visible */
            const existing = document.getElementById('secureModErrorOverlay');
            if (existing) {
                const msgEl = document.getElementById('secureModErrorMessage');
                if (msgEl) {
                    msgEl.innerHTML = `
                        <p>This ESP32 device has been programmed with secure fuses.</p>
                        <p><strong>${msg || 'Secure mode active'}</strong></p>
                        <p>The device's security features prevent any useful access to its firmware.</p>
                    `;
                }
                existing.style.display = 'flex';
                return;
            }

            /* Create overlay */
            const overlay = document.createElement('div');
            overlay.id = 'secureModErrorOverlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'rgba(0, 0, 0, 0.8)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '10002';

            /* Create error box */
            const errorBox = document.createElement('div');
            errorBox.style.background = '#3d1f1f';
            errorBox.style.border = '3px solid #ff4444';
            errorBox.style.borderRadius = '12px';
            errorBox.style.padding = '40px';
            errorBox.style.maxWidth = '600px';
            errorBox.style.textAlign = 'center';
            errorBox.style.boxShadow = '0 0 40px rgba(255, 68, 68, 0.6)';

            /* Error title */
            const title = document.createElement('div');
            title.style.fontSize = '32px';
            title.style.fontWeight = 'bold';
            title.style.color = '#ff6b6b';
            title.style.marginBottom = '20px';
            title.textContent = 'ðŸ”’ Device is Secured';
            errorBox.appendChild(title);

            /* Error message */
            const msgEl = document.createElement('div');
            msgEl.id = 'secureModErrorMessage';
            msgEl.style.fontSize = '16px';
            msgEl.style.color = '#ffcccc';
            msgEl.style.lineHeight = '1.6';
            msgEl.style.marginBottom = '20px';
            msgEl.innerHTML = `
                <p>This ESP32 device has been programmed with secure fuses.</p>
                <p><strong>${msg || 'Secure mode active'}</strong></p>
                <p>The device's security features prevent any useful access to its firmware.</p>
            `;
            errorBox.appendChild(msgEl);

            /* Close button */
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.style.background = '#ff4444';
            closeBtn.style.color = '#fff';
            closeBtn.style.border = 'none';
            closeBtn.style.padding = '12px 30px';
            closeBtn.style.fontSize = '16px';
            closeBtn.style.borderRadius = '6px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.marginTop = '20px';
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.body.removeChild(overlay);
            });
            errorBox.appendChild(closeBtn);

            /* Stop propagation on errorBox to prevent closing when clicking inside */
            errorBox.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            /* Close when clicking on overlay background */
            overlay.addEventListener('click', () => {
                document.body.removeChild(overlay);
            });

            overlay.appendChild(errorBox);
            document.body.appendChild(overlay);
        }

        async function deviceConnect() {
            try {
                setDeviceStatus('Requesting serial port...', 'loading');
                deviceFlasher = new ESPFlasher({
                    initialBaudRate: selectedBaudRate,
                    logMessage: (msg) => console.log('[Flasher]', msg),
                    logWarning: (msg) => console.warn('[Flasher WARNING]', msg),
                    logError: (msg) => console.error('[Flasher ERROR]', msg),
                    logDebug: (msg) => { isDebugMode ?? console.log('[Flasher DEBUG]', msg); },
                    logPackets: isDebugMode,
                });
                await deviceFlasher.openPort();
                setDeviceStatus('Connected. You may Hard Reset, then Sync.', 'success');
                setDeviceButtons({ connected: true });
            } catch (e) {
                setDeviceStatus('Connection failed: ' + e.message, 'error');
                setDeviceButtons({ connected: false });
            }
        }

        async function deviceHardReset() {
            if (!deviceFlasher) return;
            try {
                setDeviceStatus('Resetting...', 'loading');
                await deviceFlasher.hardReset(true);
                setDeviceStatus('Reset sequence sent.', 'success');
            } catch (e) {
                setDeviceStatus('Reset failed: ' + e.message, 'error');
            }
        }

        async function deviceSync() {
            if (!deviceFlasher) return;
            try {
                setDeviceStatus('Syncing...', 'loading');
                await deviceFlasher.sync();

                // Read MAC address
                try {
                    deviceMac = await deviceFlasher.readMac();
                } catch (macErr) {
                    console.warn('Could not read device MAC:', macErr);
                    deviceMac = null;
                }

                setDeviceStatus('Synced to ' + deviceFlasher.current_chip + '.', 'success');
                setDeviceButtons({ connected: true, synced: true, stub: await deviceFlasher.isStubLoader() });
            } catch (e) {
                setDeviceStatus('Sync failed: ' + e.message, 'error');
            }
        }

        async function deviceLoadStub() {
            if (!deviceFlasher) return;
            try {
                setDeviceStatus('Loading stub...', 'loading');
                const ok = await deviceFlasher.downloadStub();
                setDeviceButtons({ connected: true, synced: true, stub: ok });
                setDeviceStatus(ok ? 'Stub loaded.' : 'Stub load failed', ok ? 'success' : 'error');
            } catch (e) {
                setDeviceStatus('Stub error: ' + e.message, 'error');
            }
        }

        async function deviceRefresh() {
            if (!deviceFlasher) return;
            try {
                deviceMode = true;
                setDeviceStatus('Fetching bootloader and partition table...', 'loading');
                setFetchOverlayReason('Reading flash from ESP32');
                showFetchOverlay('Reading flash from ESP32...');
                deviceReadProgressTotal = deviceFlashSizeBytes;
                deviceReadProgressDone = 0;
                const totalSize = deviceFlashSizeBytes;

                await parser.sparseImage.clear();

                /* Fake file info for UI */
                displaySourceInfo({
                    name: 'ESP32 Device',
                    size: totalSize,
                    type: `device/${deviceFlasher.current_chip || 'esp32'}`,
                    lastModified: Date.now()
                });

                await parseAndDisplay();
                setDeviceStatus('Fetched and parsed. You can explore partitions.', 'success');
            } catch (e) {
                setDeviceStatus('Fetch failed: ' + e.message, 'error');
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
            }
        }

        // File drop handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        setupAdvancedControls();

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
                // Reset input value to allow selecting the same file again
                e.target.value = '';
            }
        });

        const partitionFileInput = document.getElementById('partitionFileInput');
        partitionFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0 && replaceTargetPartition !== null) {
                handlePartitionReplaceFile(e.target.files[0], replaceTargetPartition);
                // Reset input value to allow selecting the same file again
                e.target.value = '';
            }
        });

        async function handleFile(file) {
            currentFile = file;
            console.log('Loading file:', file.name, 'size:', file.size, 'type:', file.type);
            await disconnectDeviceSession();
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const sparse = SparseImage.fromBuffer(e.target.result);
                    parser = new ESP32Parser(sparse, {
                        sizeHint: sparse.size,
                        logMessage: (msg) => console.log('[Parser]', msg),
                        logWarning: (msg) => console.warn('[Parser WARNING]', msg),
                        logError: (msg) => console.error('[Parser ERROR]', msg),
                        logDebug: (msg) => { },
                    });
                    displaySourceInfo(file);
                    parseAndDisplay(true).then(() => {
                        updateMemoryMap();
                        // Hide drop zone and show close button when file is loaded
                        const dropZone = document.getElementById('dropZone');
                        if (dropZone) dropZone.style.display = 'none';
                        const closeBtn = document.getElementById('closeFileBtn');
                        if (closeBtn) closeBtn.style.display = 'inline-block';
                    }).catch(err => {
                        console.error('Error parsing file:', err);
                        showError('Error parsing file: ' + err.message);
                    });
                } catch (error) {
                    console.error('Error parsing file:', error);
                    showError('Error parsing file: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function displaySourceInfo(file) {
            const fileInfo = document.getElementById('fileInfo');
            const grid = document.getElementById('fileInfoGrid');

            const typeLabel = (() => {
                const t = file.type || 'application/octet-stream';
                if (t.startsWith('device/') && deviceFlasher && deviceFlasher.current_chip) {
                    return `device/${deviceFlasher.current_chip}`;
                }
                return t;
            })();

            const isDevice = deviceMode || (file.type && file.type.startsWith('device/'));
            const sizeValueBytes = isDevice ? deviceFlashSizeBytes : file.size;
            const sizeMarkup = isDevice
                ? `<select id="deviceSizeSelect" class="size-select" title="Select device flash size">
                        <option value="1">1 MiB</option>
                        <option value="2">2 MiB</option>
                        <option value="4">4 MiB</option>
                        <option value="8">8 MiB</option>
                        <option value="16">16 MiB</option>
                   </select>`
                : `<span>${formatBytes(sizeValueBytes)}</span>`;

            // Build MAC address row for device mode
            const macRow = isDevice && deviceMac
                ? `<div class="info-item">
                    <label>MAC Address</label>
                    <span class="mono">${deviceMac}</span>
                </div>`
                : '';

            grid.innerHTML = `
                <div class="info-item">
                    <label>Filename</label>
                    <span>${file.name}</span>
                </div>
                <div class="info-item">
                    <label>Size</label>
                    ${sizeMarkup}
                </div>
                <div class="info-item">
                    <label>Type</label>
                    <span>${typeLabel}</span>
                </div>
                ${macRow}
                <div class="info-item">
                    <label>Last Modified</label>
                    <span>${new Date(file.lastModified).toLocaleString()}</span>
                </div>
            `;

            if (isDevice) {
                const sel = document.getElementById('deviceSizeSelect');
                if (sel) {
                    const currentMiB = Math.round(deviceFlashSizeBytes / (1024 * 1024));
                    sel.value = String(currentMiB);
                    sel.addEventListener('change', () => {
                        const parsed = parseInt(sel.value, 10);
                        applyDeviceFlashSize(parsed * 1024 * 1024);
                    });
                }
            }

            fileInfo.classList.add('visible');

            // Show/hide buttons based on mode
            const importBtn = document.getElementById('importBinBtn');
            if (importBtn) {
                importBtn.style.display = 'inline-block';
            }
            const eraseBtn = document.getElementById('eraseFlashBtn');
            if (eraseBtn) {
                eraseBtn.style.display = 'inline-block';
            }
            const writeBtn = document.getElementById('writeToDeviceBtn');
            if (writeBtn) {
                writeBtn.style.display = isDevice ? 'inline-block' : 'none';
            }

            // Always show Save Image button for both file and device modes
            const saveBtn = document.getElementById('saveImageBtn');
            if (saveBtn) {
                saveBtn.style.display = 'inline-block';
            }
        }

        async function applyDeviceFlashSize(sizeBytes) {
            if (!deviceFlasher) {
                return;
            }

            console.log('Applying device flash size: ', sizeBytes);

            deviceMode = true;

            deviceFlashSizeBytes = sizeBytes;
            parser.sparseImage.size = sizeBytes;

            displaySourceInfo({
                name: 'ESP32 Device',
                size: deviceFlashSizeBytes,
                type: `device/${deviceFlasher.current_chip || 'esp32'}`,
                lastModified: Date.now()
            });
        }

        async function parseAndDisplay(focusBootloader = false) {
            // Parse bootloader first to detect partition table offset
            bootloaderInfo = await parseBootloader(0x1000);
            if (!bootloaderInfo || bootloaderInfo.error) {
                bootloaderInfo = await parseBootloader(0x0000);
            }
            console.log("Bootloader parsed:", bootloaderInfo);

            // Auto-detect partition table offset based on bootloader end/FF padding
            const detectedOffset = await parser.detectPartitionTableOffset(bootloaderInfo);
            console.log("Detected partition table offset: ", detectedOffset ? `0x${detectedOffset.toString(16)}` : 'not found');

            partitionTableOffset = detectedOffset;
            if (detectedOffset) {
                await parser.parsePartitions(detectedOffset);
            } else {
                // No partition table detected, clear the list
                parser.partitions = [];
            }

            // Compute SHA-1 only in file mode to avoid heavy device reads
            if (!deviceMode) {
                await Promise.all(parser.partitions.map(async (part) => {
                    part.sha1 = await parser.computePartitionSHA1(part);
                }));
            }

            await displayPartitions();
            await updateMemoryMap();

            // Show tabs
            document.getElementById('tabContainer').style.display = 'block';

            if (focusBootloader) {
                switchTab('bootloader');
            }
        }

        async function parseBootloader(offset = 0x0000) {
            const contentDiv = document.getElementById('bootloaderContent');
            const maxBootloaderLength = parser.sparseImage.length - offset;
            const partition = { offset: offset, length: maxBootloaderLength, label: 'bootloader' };

            contentDiv.innerHTML = '<div class="loading">â³ Parsing bootloader...</div>';

            try {
                const image = await parser.parseImage(partition.offset, partition.length);

                const fmtHex = (val, width = 0) => Number.isFinite(val) ? '0x' + val.toString(16).toUpperCase().padStart(width, '0') : 'n/a';
                const fmtText = (val, fallback = 'n/a') => (val !== undefined && val !== null && val !== '') ? val : fallback;

                const magicValid = image && !image.error && image.magic === 0xE9;
                if (!magicValid) {
                    const msg = fmtText(image.error, `Invalid magic or non-bootloader image: ${image.error}`);
                    const minimalHtml = `<div class="error" style="margin-bottom: 15px;"><strong>âš ï¸ Not a bootloader at ${fmtHex(offset, 4)}</strong><br>${msg}</div>`;
                    contentDiv.innerHTML = minimalHtml;

                    /* Provide reasonable start/end markers so callers can continue */
                    image.bootloaderStart = partition.offset;
                    image.bootloaderEnd = Number.isFinite(image.endOffset)
                        ? image.endOffset
                        : partition.offset + (image.length || 0);
                    return image;
                }

                // Validate SHA256 (appended) and compute region/full hashes
                let sha256Validation = null;
                let sha256RegionCalc = null;

                if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined && image.sha256DataEnd > image.sha256DataStart) {
                    console.log(`Bootloader SHA256 region: start=0x${image.sha256DataStart.toString(16)}, end=0x${image.sha256DataEnd.toString(16)}, length=${image.sha256DataEnd - image.sha256DataStart}`);
                    const regionData = await parser.sparseImage.slice_async(image.sha256DataStart, image.sha256DataEnd);
                    const regionHash = await ESP32Parser.calculateSHA256(regionData);
                    sha256RegionCalc = ESP32Parser.bytesToHex(regionHash);
                }

                if (image.sha256) {
                    sha256Validation = await parser.validateImageSHA256(image);
                    if (sha256Validation && !sha256Validation.calculated && sha256RegionCalc) {
                        sha256Validation.calculated = sha256RegionCalc;
                    }
                }

                let html = '';

                if (image.error) {
                    html += `<div class="error" style="margin-bottom: 15px;"><strong>âš ï¸ Parsing Error:</strong> ${image.error}</div>`;
                }

                //html += '<div class="success">Bootloader parsed successfully</div>';

                html += '<h4 style="margin-top: 15px;">Basic Information</h4>';
                html += '<div class="info-grid">';
                html += `<div class="info-item"><label>Flash Offset:</label><span class="mono">${fmtHex(offset, 4)}</span></div>`;
                html += `<div class="info-item"><label>Magic:</label><span class="mono">${fmtHex(image.magic, 2)}</span></div>`;
                html += `<div class="info-item"><label>Segment Count:</label><span>${fmtText(image.segmentCount)}</span></div>`;
                html += `<div class="info-item"><label>Entry Address:</label><span class="mono">${fmtHex(image.entryAddr, 8)}</span></div>`;
                html += `<div class="info-item"><label>Chip:</label><span>${fmtText(image.chipName, 'Unknown')} (${fmtHex(image.chipId, 4)})</span></div>`;
                html += '</div>';

                html += '<h4 style="margin-top: 15px;">Flash Configuration</h4>';
                html += '<div class="info-grid">';
                html += `<div class="info-item"><label>SPI Mode:</label><span>${fmtText(image.spiModeName, 'Unknown')} (${fmtText(image.spiMode, 'n/a')})</span></div>`;
                html += `<div class="info-item"><label>SPI Speed:</label><span>${fmtText(image.spiSpeedName, 'Unknown')}</span></div>`;
                html += `<div class="info-item"><label>Flash Size:</label><span>${fmtText(image.spiSizeName, 'Unknown')}</span></div>`;
                html += `<div class="info-item"><label>WP Pin:</label><span>${image.wpPinDisabled ? 'Disabled (0xEE)' : fmtHex(image.wpPin, 2)}</span></div>`;
                html += '</div>';

                // App Description (if found)
                if (image.appDesc && image.appDesc.found) {
                    html += '<h4 style="margin-top: 15px;">Application Description</h4>';
                    html += '<div class="info-grid">';
                    if (image.appDesc.projectName) {
                        html += `<div class="info-item"><label>Project Name:</label><span>${image.appDesc.projectName}</span></div>`;
                    }
                    if (image.appDesc.version) {
                        html += `<div class="info-item"><label>Version:</label><span>${image.appDesc.version}</span></div>`;
                    }
                    if (image.appDesc.idfVer) {
                        html += `<div class="info-item"><label>ESP-IDF Version:</label><span>${image.appDesc.idfVer}</span></div>`;
                    }
                    html += `<div class="info-item"><label>Secure Version:</label><span>${image.appDesc.secureVersion}</span></div>`;
                    if (image.appDesc.date && image.appDesc.time) {
                        html += `<div class="info-item"><label>Build Date/Time:</label><span>${image.appDesc.date} ${image.appDesc.time}</span></div>`;
                    }
                    if (image.appDesc.appElfSha256) {
                        html += `<div class="info-item" style="grid-column: 1 / -1;"><label>App ELF SHA256:</label><span class="mono" title="Reference only - ELF file not available for validation">${image.appDesc.appElfSha256} <span style="color: #9a9a9a;">â„¹ï¸</span></span></div>`;
                    }
                    html += '</div>';
                }

                /* Calculate expected checksum */
                let calculatedChecksum = null;
                let checksumMismatch = false;
                try {
                    const checksumInfo = await parser.calculateImageChecksum(image.offset);
                    calculatedChecksum = checksumInfo.checksum;
                    checksumMismatch = (checksumInfo.checksum !== image.checksum);
                } catch (e) {
                    console.warn('Could not calculate checksum:', e.message);
                }

                html += '<h4 style="margin-top: 15px;">Validation</h4>';
                html += '<div class="info-grid">';

                /* Checksum display */
                const checksumColor = checksumMismatch ? '#e88888' : '#6ec589';
                const checksumIcon = checksumMismatch ? 'âœ—' : 'âœ“';
                html += `<div class="info-item"><label>Checksum:</label><span class="mono" style="color: ${checksumColor};">0x${(image.checksum || 0).toString(16).toUpperCase().padStart(2, '0')} ${checksumIcon}</span></div>`;
                if (checksumMismatch && calculatedChecksum !== null) {
                    html += `<div class="info-item"><label>Checksum (calculated):</label><span class="mono">0x${calculatedChecksum.toString(16).toUpperCase().padStart(2, '0')}</span></div>`;
                }
                html += `<div class="info-item"><label>Hash Appended:</label><span>${image.hasHash ? 'Yes' : 'No'}</span></div>`;

                /* SHA256 display */
                const sha256Match = image.sha256 && sha256RegionCalc && image.sha256.toLowerCase() === sha256RegionCalc.toLowerCase();
                const sha256Valid = sha256Validation && sha256Validation.valid === true;
                const sha256Invalid = sha256Validation && sha256Validation.valid === false;
                const sha256Color = sha256Valid ? '#6ec589' : sha256Invalid ? '#e88888' : '#9a9a9a';
                const sha256Icon = sha256Valid ? 'âœ“' : sha256Invalid ? 'âœ—' : 'â³';

                if (image.sha256) {
                    html += `<div class="info-item" style="grid-column: 1 / -1;"><label>SHA256:</label><span class="mono" style="color: ${sha256Color};">${image.sha256} ${sha256Icon}</span></div>`;
                    if (sha256Invalid && sha256RegionCalc) {
                        html += `<div class="info-item" style="grid-column: 1 / -1;"><label>SHA256 (calculated):</label><span class="mono">${sha256RegionCalc}</span></div>`;
                    }
                }
                if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined) {
                    const regionLen = image.sha256DataEnd - image.sha256DataStart;
                    html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Hash region:</label><span class="mono">0x${image.sha256DataStart.toString(16).toUpperCase()} - 0x${image.sha256DataEnd.toString(16).toUpperCase()} (${regionLen} bytes)</span></div>`;
                }

                html += '</div>';
                html += '<h4 style="margin-top: 15px;">Segments</h4>';
                html += '<table><thead><tr><th>#</th><th>Load Address</th><th>Length</th><th>Offset</th></tr></thead><tbody>';
                const segments = Array.isArray(image.segmentList) ? image.segmentList : [];
                segments.forEach((seg, sidx) => {
                    html += '<tr>';
                    html += `<td>${sidx}</td>`;
                    html += `<td class="mono">${fmtHex(seg.loadAddress, 8)}</td>`;
                    html += `<td>${formatBytes(seg.length || 0)}</td>`;
                    html += `<td class="mono">${fmtHex(seg.offset)}</td>`;
                    html += '</tr>';
                });
                html += '</tbody></table>';

                html += '<h4 style="margin-top: 15px;">Actions</h4>';
                html += '<div style="display: flex; gap: 10px; flex-wrap: wrap;">';
                html += '<button class="hex-btn" onclick="viewPartitionHex(-1)">Hex View</button>';
                html += '<button class="download-btn" onclick="downloadPartition(-1)">Download</button>';
                html += '<button class="replace-btn" onclick="replaceBootloader()">Replace</button>';
                html += '<button class="replace-btn" onclick="clearBootloader()">Clear</button>';
                if (checksumMismatch) {
                    html += '<button class="btn" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);" onclick="fixChecksums(\'bootloader\')">Fix Checksums</button>';
                }
                html += '</div>';

                contentDiv.innerHTML = html;

                // Find bootloader end (where 0xFF padding starts)
                let bootloaderEnd = Number.isFinite(image.endOffset) ? image.endOffset : 0;
                // Scan forward from endOffset to find where 0xFF padding begins
                // Limit scan to actual file size
                const actualSize = parser.sparseImage.size;
                const scanLimit = Math.min(maxBootloaderLength, actualSize);
                const scanSize = 256; // Check in 256-byte blocks
                for (let pos = bootloaderEnd; pos < scanLimit; pos += scanSize) {
                    let allFF = true;
                    const checkLen = Math.min(scanSize, scanLimit - pos);
                    for (let i = 0; i < checkLen; i++) {
                        if ((await parser.view.getUint8(pos + i)) !== 0xFF) {
                            allFF = false;
                            bootloaderEnd = pos + i + 1;
                            break;
                        }
                    }
                    if (allFF) {
                        // Found start of 0xFF region, bootloader ends here
                        break;
                    }
                }

                image.bootloaderStart = partition.offset;
                image.bootloaderEnd = bootloaderEnd;

                /* Auto-apply detected flash size in device mode */
                if (deviceMode && image.spiSizeName) {
                    /* Extract flash size from spiSizeName (e.g., "2 MiB", "4 MiB") */
                    const flashSizeMatch = image.spiSizeName.match(/(\d+)\s*([KMG]i?B)/i);
                    if (flashSizeMatch) {
                        let sizeBytes = parseInt(flashSizeMatch[1], 10);
                        const unit = flashSizeMatch[2].toUpperCase();

                        if (unit === 'KIB' || unit === 'KB') sizeBytes *= 1024;
                        else if (unit === 'MIB' || unit === 'MB') sizeBytes *= 1024 * 1024;
                        else if (unit === 'GIB' || unit === 'GB') sizeBytes *= 1024 * 1024 * 1024;

                        if (sizeBytes > 0 && sizeBytes !== deviceFlashSizeBytes) {
                            console.log(`Detected flash size from bootloader: ${image.spiSizeName} (${sizeBytes} bytes)`);
                            await applyDeviceFlashSize(sizeBytes);
                        }
                    }
                }

                return image;
            } catch (error) {
                console.error('Bootloader parsing error:', error);
                contentDiv.innerHTML = `<div class="error">Error parsing bootloader: ${error.message}</div>`;
                return null;
            }
        }

        async function displayPartitions() {
            const content = document.getElementById('partitionsContent');
            const partitions = parser.partitions;

            if (partitions.length === 0) {
                content.innerHTML = '<div class="error">No partitions found in this firmware image.</div>';
                return;
            }

            // Parse OTA data to determine boot partition
            let bootPartitionSubType = null;
            const otaDataPartition = partitions.find(p => p.type === 1 && p.subType === 0x00);
            if (otaDataPartition) {
                try {
                    const otaResult = (await parser.parseOTAData(otaDataPartition)).otaInfo;
                    if (otaResult.activeEntry !== null) {
                        const active = otaResult.entries[otaResult.activeEntry];
                        // Count OTA partitions
                        const otaPartitions = partitions.filter(p => p.type === 0 && p.subType >= 0x10 && p.subType <= 0x1F);
                        const otaCount = otaPartitions.length;
                        if (otaCount > 0) {
                            // Calculate boot slot: (ota_seq - 1) % ota_app_count
                            const bootSlot = (active.sequence - 1) % otaCount;
                            // OTA partition subType = 0x10 + slot number
                            bootPartitionSubType = 0x10 + bootSlot;
                        }
                    }
                } catch (error) {
                    console.error('Error parsing OTA data for boot partition:', error);
                }
            }

            let html = '';
            if (partitionTableOffset !== null) {
                html += '<div class="info-grid" style="margin-bottom: 20px;">';
                html += `<div class="info-item"><label>Flash Offset:</label><span class="mono">0x${partitionTableOffset.toString(16).toUpperCase().padStart(4, '0')}</span></div>`;
                html += '</div>';
            }
            html += '<table><thead><tr>';
            html += '<th>#</th><th>Label</th><th>Type</th><th>Offset</th><th>End Offset</th><th>Size</th><th>Actions</th>';
            html += '</tr></thead><tbody>';

            for (let idx = 0; idx < partitions.length; idx++) {
                const part = partitions[idx];
                const badgeClass = part.type === 0 ? 'app' : 'data';

                // Check if APP partition has valid magic and boot status
                let magicIndicator = '';
                if (part.type === 0) { // APP partition
                    const hasValidMagic = await parser.hasValidImageMagic(part);
                    if (hasValidMagic) {
                        magicIndicator = '<span style="color: #6ec589; font-size: 1.1em; margin-left: 5px;" title="Valid ESP32 image magic (0xE9)">âœ“</span>';
                    } else {
                        magicIndicator = '<span style="color: #e88888; font-size: 1.1em; margin-left: 5px;" title="Invalid or missing ESP32 image magic">âœ—</span>';
                    }

                    // Mark boot partition
                    if (bootPartitionSubType !== null && part.subType === bootPartitionSubType) {
                        magicIndicator += '<span style="color: #ffd700; font-weight: bold; margin-left: 5px; background: #3d3d1f; padding: 2px 6px; border-radius: 3px;" title="This partition will boot according to OTA data">[BOOT]</span>';
                    } else if (part.subType === 0x00 && bootPartitionSubType === null) {
                        // Factory partition with no OTA data
                        magicIndicator += '<span style="color: #ffd700; font-weight: bold; margin-left: 5px; background: #3d3d1f; padding: 2px 6px; border-radius: 3px;" title="Factory partition (default boot)">[BOOT]</span>';
                    }
                }

                html += `<tr class="expandable" onclick="togglePartitionDetails(${idx})">`;
                html += `<td>${part.num}</td>`;
                html += `<td><strong>${part.label}${magicIndicator}</strong></td>`;
                html += `<td><span class="badge ${badgeClass}">${part.typeName}</span></td>`;
                html += `<td class="mono">0x${part.offset.toString(16).toUpperCase().padStart(6, '0')}</td>`;
                html += `<td class="mono">0x${(part.offset + part.length).toString(16).toUpperCase().padStart(6, '0')}</td>`;
                html += `<td>${formatBytes(part.length)}</td>`;
                html += `<td>
                    <button class="hex-btn" onclick="event.stopPropagation(); viewPartitionHex(${idx})">Hex View</button>
                    <button class="download-btn" onclick="event.stopPropagation(); downloadPartition(${idx})">Download</button>
                    <button class="replace-btn" onclick="event.stopPropagation(); replacePartition(${idx})">Replace</button>
                    <button class="replace-btn" onclick="event.stopPropagation(); clearPartition(${idx})">Clear</button>
                </td>`;
                html += '</tr>';

                // Details row
                html += `<tr class="details-row" id="details-${idx}">`;
                html += `<td colspan="7"><div class="details-content">`;
                html += `<div class="details-grid">`;
                html += `<div class="detail-item"><strong>Type Code:</strong> 0x${part.type.toString(16).toUpperCase()}</div>`;
                html += `<div class="detail-item"><strong>SubType Code:</strong> 0x${part.subType.toString(16).toUpperCase()}</div>`;
                html += `<div class="detail-item"><strong>Offset (decimal):</strong> ${part.offset}</div>`;
                html += `<div class="detail-item"><strong>Size (decimal):</strong> ${part.length} bytes</div>`;
                html += `<div class="detail-item"><strong>End Offset:</strong> 0x${(part.offset + part.length).toString(16).toUpperCase()}</div>`;

                // Add parse buttons for specific partition types
                if (part.subType === 0x02) { // NVS
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseNVSPartition(${idx})">Parse NVS</button></div>`;
                } else if (part.subType === 0x00 && part.type === 1) { // OTA data
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseOTADataPartition(${idx})">Parse OTA Data</button></div>`;
                } else if (part.type === 0) { // APP
                    html += `<div class="detail-item">
                        <button class="btn" onclick="event.stopPropagation(); parseImagePartitionInline(${idx})">Parse Image</button>
                        <button class="btn" id="save_ota_${idx}" onclick="event.stopPropagation(); downloadOTAImage(${idx})">Save OTA Image</button>
                        <button class="btn" id="fix_check_${idx}" style="display: none; background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); cursor: pointer;" onclick="event.stopPropagation(); (async () => { await fixChecksums('ota', ${part.offset}, ${part.length}); parseImagePartitionInline(${idx}); })();">Fix Checksums</button>
                        </div>`;
                } else if (part.subType === 0x81) { // FAT
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseFATPartition(${idx})">Parse FAT</button></div>`;
                } else if (part.subType === 0x82) { // SPIFFS
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseSPIFFSPartition(${idx})">Parse SPIFFS</button></div>`;
                }
                //html += `<div class="detail-item" style="grid-column: 1 / -1;"><strong>SHA-1:</strong> <span class="mono">${part.sha1 || 'n/a'}</span></div>`;

                html += `</div>`;

                // Add content area for inline parsed data
                html += `<div id="parsed-content-${idx}" style="margin-top: 15px;"></div>`;

                html += `</div></td></tr>`;
            }

            html += '</tbody></table>';
            content.innerHTML = html;
        }

        function replacePartition(idx) {
            if (!parser || !parser.partitions || !parser.partitions[idx]) {
                alert('Partition not found.');
                return;
            }
            const part = parser.partitions[idx];
            const start = part.offset;
            const length = part.length;

            showImportPopup(start, length, false, async () => {
                try {
                    console.log(`Replaced partition ${idx}, refreshing view...`);
                    if (!deviceMode) {
                        part.sha1 = await parser.computePartitionSHA1(part);
                    }
                    await displayPartitions();
                    const parsedContent = document.getElementById('parsed-content-' + idx);
                    if (parsedContent) {
                        parsedContent.innerHTML = '';
                    }
                    const rawTab = document.querySelector('.tab.active');
                    if (rawTab && rawTab.textContent.toLowerCase().includes('raw')) {
                        await updateHexView();
                    }
                    await updateMemoryMap();
                } catch (err) {
                    console.error('Post-import refresh error:', err);
                }
            });
        }

        function replaceBootloader() {
            if (!parser || !bootloaderInfo || bootloaderInfo.bootloaderStart === undefined || bootloaderInfo.bootloaderEnd === undefined) {
                alert('Bootloader not parsed correctly. Cannot replace bootloader.');
                return;
            }

            const start = bootloaderInfo.bootloaderStart;
            const length = bootloaderInfo.bootloaderEnd - bootloaderInfo.bootloaderStart;

            showImportPopup(start, length, false, async () => {
                try {
                    await parseBootloader();
                    updateMemoryMap();
                } catch (err) {
                    console.error('Post-import bootloader refresh error:', err);
                }
            });
        }

        async function clearBootloader() {
            if (!parser) {
                alert('No firmware file loaded.');
                return;
            }

            try {
                const start = 0;
                // Use same size calculation as download
                let length;
                if (bootloaderInfo && bootloaderInfo.bootloaderEnd) {
                    length = bootloaderInfo.bootloaderEnd;
                } else {
                    length = partitionTableOffset || 0x8000;
                }
                const end = start + length;

                if (end > parser.sparseImage.size) {
                    alert('Bootloader region exceeds firmware image size.');
                    return;
                }

                /* Fill bootloader with 0xFF */
                parser.sparseImage.fill(0xFF, start, end);

                if (!deviceMode) {
                    /* Recompute bootloader in file mode */
                    await parseBootloader();
                }

                updateMemoryMap();
            } catch (err) {
                console.error('Error clearing bootloader:', err);
                alert('Error clearing bootloader: ' + err.message);
            }
        }

        async function fixChecksums(imageType = null, otaOffset = null, otaLength = null) {
            if (!parser) {
                setDeviceStatus('No firmware file loaded', 'error');
                return;
            }

            try {
                setDeviceStatus('Fixing checksums...', 'info');
                const result = await parser.fixAllChecksums(imageType, otaOffset, otaLength);

                let statusParts = [];

                if (result.bootloader) {
                    if (result.bootloader.fixed) {
                        const fixes = [];
                        if (result.bootloader.checksumFixed) {
                            fixes.push(`checksum fixed`);
                        }
                        if (result.bootloader.sha256Fixed) {
                            fixes.push(`SHA256 fixed`);
                        }
                        statusParts.push(`Bootloader: ${fixes.join(', ')}`);
                    }
                }
                if (result.otaApp) {
                    if (result.otaApp.fixed) {
                        const fixes = [];
                        if (result.otaApp.checksumFixed) {
                            fixes.push(`checksum fixed`);
                        }
                        if (result.otaApp.sha256Fixed) {
                            fixes.push(`SHA256 fixed`);
                        }
                        statusParts.push(`OTA app: ${fixes.join(', ')}`);
                    }
                }

                updateMemoryMap();
                await parseBootloader();

                if (statusParts.length > 0) {
                    setDeviceStatus(statusParts.join(' | '), 'success');
                } else {
                    setDeviceStatus('Already valid, no fixes needed', 'success');
                }
            } catch (err) {
                console.error('Error fixing checksums:', err);
                setDeviceStatus('Error fixing checksums: ' + err.message, 'error');
                setDeviceStatus('Failed to fix checksums', 'error');
            }
        }

        async function clearPartition(idx) {
            if (!parser) {
                alert('No firmware file loaded.');
                return;
            }

            const part = parser.partitions[idx];
            if (!part) {
                alert('Partition not found.');
                return;
            }

            try {
                const start = part.offset;
                const end = start + part.length;

                const totalSize = parser.sparseImage.size;
                if (end > totalSize) {
                    alert('Partition range exceeds firmware image size.');
                    return;
                }

                // Fill partition with 0xFF
                parser.sparseImage.fill(0xFF, start, end);

                if (!deviceMode) {
                    part.sha1 = await parser.computePartitionSHA1(part);
                }

                await displayPartitions();

                const parsedContent = document.getElementById('parsed-content-' + idx);
                if (parsedContent) {
                    parsedContent.innerHTML = '';
                }

                const rawTab = document.querySelector('.tab.active');
                if (rawTab && rawTab.textContent.toLowerCase().includes('raw')) {
                    updateHexView();
                }

                updateMemoryMap();
            } catch (err) {
                console.error('Error clearing partition:', err);
                alert('Error clearing partition: ' + err.message);
            }
        }

        function handlePartitionReplaceFile(file, idx) {
            if (!parser) {
                alert('No firmware file loaded.');
                return;
            }

            /* Handle bootloader (-1) and regular partitions */
            let part;
            if (idx === -1) {
                // Only allow if bootloader was successfully parsed
                if (!bootloaderInfo || bootloaderInfo.bootloaderStart === undefined || bootloaderInfo.bootloaderEnd === undefined) {
                    alert('Bootloader not parsed correctly. Cannot replace bootloader.');
                    return;
                }
                const bootloaderStart = bootloaderInfo.bootloaderStart;
                const bootloaderLength = bootloaderInfo.bootloaderEnd - bootloaderInfo.bootloaderStart;
                part = { label: 'bootloader', offset: bootloaderStart, length: bootloaderLength };
            } else {
                part = parser.partitions[idx];
                if (!part) {
                    alert('Partition not found.');
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = async function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    if (data.length > part.length) {
                        alert('Selected file is larger than the partition size.');
                        return;
                    }

                    const start = part.offset;
                    const end = start + part.length;

                    const totalSize = parser.sparseImage.size;
                    if (end > totalSize) {
                        alert('Partition range exceeds firmware image size.');
                        return;
                    }

                    parser.sparseImage.fill(0xFF, start, end);
                    parser.sparseImage.write(start, data);

                    if (!deviceMode && idx !== -1) {
                        part.sha1 = await parser.computePartitionSHA1(part);
                    }

                    /* Refresh bootloader or partitions */
                    if (idx === -1) {
                        await parseBootloader();
                    } else {
                        await displayPartitions();
                    }

                    const parsedContent = document.getElementById('parsed-content-' + idx);
                    if (parsedContent) {
                        parsedContent.innerHTML = '';
                    }

                    const rawTab = document.querySelector('.tab.active');
                    if (rawTab && rawTab.textContent.toLowerCase().includes('raw')) {
                        updateHexView();
                    }

                    updateMemoryMap();
                } catch (err) {
                    console.error('Error replacing partition:', err);
                    alert('Error replacing partition: ' + err.message);
                } finally {
                    replaceTargetPartition = null;
                    const inputEl = document.getElementById('partitionFileInput');
                    if (inputEl) {
                        inputEl.value = '';
                    }
                }
            };
            reader.onerror = function () {
                alert('Failed to read the selected file.');
            };
            reader.readAsArrayBuffer(file);
        }

        async function saveImage() {
            if (!parser || !parser.sparseImage) {
                alert('No firmware image loaded.');
                return;
            }

            showFetchOverlay('Preparing image download...');
            try {
                const data = await parser.sparseImage.slice_async(0, parser.sparseImage.size);
                const blob = new Blob([data], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // Generate meaningful filename
                let filename;
                if (deviceMode && deviceFlasher) {
                    // Device mode: use chip type and MAC
                    const chipName = deviceFlasher.current_chip || 'esp32';
                    const macPart = deviceMac ? '_' + deviceMac.replace(/:/g, '') : '';
                    filename = `${chipName}${macPart}_dump.bin`;
                } else if (currentFile && currentFile.name) {
                    // File mode: use original filename as base
                    const baseName = currentFile.name.replace(/\.bin$/i, '');
                    filename = `${baseName}_modified.bin`;
                } else {
                    // Fallback
                    filename = 'firmware_modified.bin';
                }
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                alert('Error preparing image: ' + error.message);
            } finally {
                hideFetchOverlay();
            }
        }

        async function eraseFlash() {
            if (!parser || !parser.sparseImage) {
                alert('No device connected or firmware loaded.');
                return;
            }

            try {
                setDeviceStatus('Erasing flash...', 'loading');
                const deviceSize = parser.sparseImage.size;
                // Clear existing write buffers first, then fill with 0xFF
                parser.sparseImage.writeBuffer = [];
                parser.sparseImage.fill(0xFF, 0, deviceSize);
                await parseAndDisplay(true);
                setDeviceStatus('Flash erased (ready to write)', 'success');
            } catch (error) {
                console.error('Erase error:', error);
                setDeviceStatus('Erase failed: ' + error.message, 'error');
                alert('Error erasing flash: ' + error.message);
            }
        }

        async function writeToDevice() {
            if (!deviceFlasher || !deviceMode) {
                alert('No device connected.');
                return;
            }

            if (!parser || !parser.sparseImage) {
                alert('No firmware image loaded.');
                return;
            }

            // Check if there are any pending writes
            if (!parser.sparseImage.writeBuffer || parser.sparseImage.writeBuffer.length === 0) {
                alert('No changes to write. Please modify partitions first.');
                return;
            }

            const writeCount = parser.sparseImage.writeBuffer.length;
            const totalBytes = parser.sparseImage.writeBuffer.reduce((sum, seg) => sum + seg.data.length, 0);

            showWriteOverlay('Writing modified segments...');

            try {
                setDeviceStatus('Writing modified segments to device...', 'loading');
                updateWriteOverlayProgress(0, 0, totalBytes);
                await parser.sparseImage.flush();
            } catch (error) {
                console.error('Write error:', error);
                setDeviceStatus('Write failed: ' + error.message, 'error');
                alert('Error writing to device: ' + error.message);
            } finally {
                hideWriteOverlay();
            }

            await updateMemoryMap();
        }

        /* Import binary file functions */
        let importFile = null;
        let importIsJson = false;
        let importJsonData = null;
        let importBaseUrl = null; // For resolving relative paths in JSON manifests
        let importRangeStart = 0;
        let importRangeLength = 0;
        let importAddressEditable = true;
        let importCallback = null;

        function switchImportTab(tab) {
            const tabs = document.querySelectorAll('.import-tab');
            const contents = document.querySelectorAll('.import-tab-content');

            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));

            if (tab === 'file') {
                tabs[0].classList.add('active');
                document.getElementById('importTabFile').classList.add('active');
            } else {
                tabs[1].classList.add('active');
                document.getElementById('importTabUrl').classList.add('active');
            }
        }

        async function loadImportUrl() {
            const urlInput = document.getElementById('importUrlInput');
            const url = urlInput.value.trim();

            if (!url) {
                alert('Please enter a URL');
                return;
            }

            try {
                setDeviceStatus('Downloading from URL...', 'loading');
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const blob = await response.blob();
                const filename = url.split('/').pop() || 'download.bin';
                importFile = new File([blob], filename, { type: blob.type });

                const fileNameSpan = document.getElementById('importFileName');
                if (fileNameSpan) fileNameSpan.textContent = importFile.name + ' (from URL)';

                // Check if JSON
                if (filename.toLowerCase().endsWith('.json') || blob.type.includes('json')) {
                    // Store base URL for resolving relative paths
                    const urlParts = url.split('/');
                    urlParts.pop(); // Remove filename
                    importBaseUrl = urlParts.join('/');
                    await handleJsonManifest(importFile);
                } else {
                    importBaseUrl = null;
                    updateImportPreview();
                }

                setDeviceStatus('URL loaded successfully', 'success');
            } catch (error) {
                console.error('URL load error:', error);

                // Check if it's a CORS error
                if (error.message.includes('CORS') || error.message.includes('cross-origin') ||
                    error.name === 'TypeError' && !error.message.includes('HTTP')) {
                    const corsMsg = 'CORS Error: The server does not allow cross-origin requests.\n\n' +
                        'The server at this URL has not enabled CORS (Cross-Origin Resource Sharing).\n' +
                        'To fix this, either:\n' +
                        '  â€¢ Download the files manually and use the File tab\n' +
                        '  â€¢ Ask the server administrator to enable CORS\n' +
                        '  â€¢ Use a CORS proxy service\n' +
                        '  â€¢ Run Edge with security disabled:\n' +
                        '    msedge.exe --user-data-dir=C:\\temp\\msedge-dev-data\\ --disable-web-security';
                    setDeviceStatus('CORS blocked: Server does not allow cross-origin requests', 'error');
                    alert(corsMsg);
                } else {
                    setDeviceStatus('Failed to load URL: ' + error.message, 'error');
                    alert('Error loading URL: ' + error.message);
                }
            }
        }

        async function handleJsonManifest(file) {
            try {
                const text = await file.text();
                const manifest = JSON.parse(text);

                // Detect manifest format and normalize to common structure
                let flashEntries = [];
                let manifestType = '';
                let availableBuilds = [];

                if (manifest.flash && Array.isArray(manifest.flash)) {
                    // Format 1: { flash: [ { url, address } ] }
                    manifestType = 'esptool';
                    flashEntries = manifest.flash.map(entry => ({
                        url: entry.url,
                        address: entry.address ? parseInt(entry.address, 16) : 0,
                        path: entry.url,
                        isApp: entry.app || false
                    }));
                } else if (manifest.builds && Array.isArray(manifest.builds) && manifest.builds.length > 0) {
                    // Format 2: { builds: [ { chipFamily, parts: [], ota: {} } ] }
                    manifestType = 'esp-web-tools';

                    // Collect available builds
                    availableBuilds = manifest.builds.map((build, idx) => ({
                        chipFamily: build.chipFamily || `Build ${idx + 1}`,
                        index: idx
                    }));

                    // Try to auto-select build based on connected device chip
                    let selectedBuildIdx = 0;
                    if (deviceFlasher && deviceFlasher.current_chip) {
                        const deviceChip = deviceFlasher.current_chip.toUpperCase();
                        const matchIdx = manifest.builds.findIndex(build => {
                            const chipFam = (build.chipFamily || '').toUpperCase();
                            return chipFam.includes(deviceChip) || deviceChip.includes(chipFam);
                        });
                        if (matchIdx >= 0) selectedBuildIdx = matchIdx;
                    }

                    const build = manifest.builds[selectedBuildIdx];

                    // Collect parts
                    if (build.parts && Array.isArray(build.parts)) {
                        flashEntries = build.parts.map(part => ({
                            path: part.path,
                            url: part.path,
                            address: part.offset || 0,
                            isApp: false
                        }));
                    }

                    // Add OTA file if present (usually for OTA updates, not initial flash)
                    // But we'll include it at offset 0 if no parts exist
                    if (build.ota && build.ota.path) {
                        if (flashEntries.length === 0) {
                            // No parts, use OTA file at offset 0
                            flashEntries.push({
                                path: build.ota.path,
                                url: build.ota.path,
                                address: 0,
                                isApp: true
                            });
                        }
                    }
                } else {
                    throw new Error('Invalid manifest: missing "flash" or "builds" array');
                }

                if (flashEntries.length === 0) {
                    throw new Error('No flash entries found in manifest');
                }

                importIsJson = true;
                importJsonData = { ...manifest, flashEntries, manifestType, availableBuilds };

                // Update preview to show JSON manifest details
                const previewDiv = document.getElementById('importPreview');
                const applyBtn = document.getElementById('importApplyBtn');
                const addressInput = document.getElementById('importAddress');

                // Hide address input for JSON manifests
                if (addressInput && addressInput.parentElement) {
                    addressInput.parentElement.style.display = 'none';
                }

                // Show erase flash option for JSON manifests
                const eraseOption = document.getElementById('importEraseOption');
                if (eraseOption) {
                    eraseOption.style.display = 'block';
                }

                let html = `<div style="line-height: 1.8;">`;
                html += `<strong style="color: #7a8bdc;">JSON Manifest Detected</strong><br>`;
                if (manifest.name) html += `Name: <strong>${manifest.name}</strong><br>`;
                if (manifest.version) html += `Version: <strong>${manifest.version}</strong><br>`;
                if (manifest.chip) html += `Chip: <strong>${manifest.chip}</strong><br>`;

                // Show selected build info
                if (availableBuilds.length > 0) {
                    const selectedBuild = manifest.builds[0]; // We used index 0 above after auto-selection
                    html += `Build: <strong>${selectedBuild.chipFamily || 'Unknown'}</strong>`;
                    if (availableBuilds.length > 1) {
                        html += ` <span style="color: #888; font-size: 0.9em;">(${availableBuilds.length} builds available)</span>`;
                    }
                    html += `<br>`;
                }

                html += `<br><strong>Flash Entries (${flashEntries.length}):</strong><br>`;

                for (let i = 0; i < flashEntries.length; i++) {
                    const entry = flashEntries[i];
                    const addr = `0x${entry.address.toString(16).toUpperCase()}`;
                    const filename = entry.path.split('/').pop();
                    html += `${i + 1}. ${addr}: ${filename}`;
                    if (entry.isApp) html += ` <span style="color: #ffa726;">(app)</span>`;
                    html += `<br>`;
                }

                html += `</div>`;
                previewDiv.innerHTML = html;

                if (applyBtn) applyBtn.disabled = false;

            } catch (error) {
                console.error('JSON parse error:', error);
                alert('Error parsing JSON manifest: ' + error.message);
                importIsJson = false;
                importJsonData = null;
            }
        }

        function showImportPopup(startAddr = 0, length = deviceFlashSizeBytes, addressEditable = true, onImported = null) {
            importRangeStart = startAddr;
            importRangeLength = length;
            importAddressEditable = !!addressEditable;
            importCallback = onImported;

            console.log(`Showing import popup: start=0x${startAddr.toString(16)}, length=${length}, editable=${importAddressEditable}, callback=${importCallback ? 'yes' : 'no'}`);

            const popup = document.getElementById('importPopup');
            const addressInput = document.getElementById('importAddress');
            if (addressInput) {
                addressInput.value = '0x' + importRangeStart.toString(16).toUpperCase();
                addressInput.parentElement.style.display = importAddressEditable ? 'block' : 'none';
            }
            if (popup) {
                popup.style.display = 'flex';
                updateImportPreview();
            }
        }

        function hideImportPopup() {
            const popup = document.getElementById('importPopup');
            if (popup) {
                popup.style.display = 'none';
            }
            importFile = null;
            importIsJson = false;
            importJsonData = null;
            importBaseUrl = null;
            importRangeStart = 0;
            importRangeLength = 0;
            importAddressEditable = true;
            importCallback = null;
            const fileNameSpan = document.getElementById('importFileName');
            if (fileNameSpan) fileNameSpan.textContent = 'None';
            const applyBtn = document.getElementById('importApplyBtn');
            if (applyBtn) applyBtn.disabled = true;
            const addressInput = document.getElementById('importAddress');
            if (addressInput && addressInput.parentElement) {
                addressInput.parentElement.style.display = 'block';
            }
            const eraseOption = document.getElementById('importEraseOption');
            if (eraseOption) {
                eraseOption.style.display = 'none';
            }
            /* Reset file inputs to allow re-selecting the same file */
            const importFileInput = document.getElementById('importFileInput');
            if (importFileInput) {
                importFileInput.value = '';
            }
            const importUrlInput = document.getElementById('importUrlInput');
            if (importUrlInput) {
                importUrlInput.value = '';
            }
        }

        function updateImportPreview() {
            const previewDiv = document.getElementById('importPreview');
            const applyBtn = document.getElementById('importApplyBtn');
            const addressInput = document.getElementById('importAddress');

            if (!importFile || !addressInput || !previewDiv) {
                if (previewDiv) previewDiv.innerHTML = 'Select a file and enter an address to see preview';
                if (applyBtn) applyBtn.disabled = true;
                return;
            }

            const allowedStart = importRangeStart;
            const allowedEnd = importRangeStart + importRangeLength;

            let addressStr = addressInput.value.trim();
            if (!importAddressEditable) {
                addressStr = '0x' + allowedStart.toString(16).toUpperCase();
                addressInput.value = addressStr;
            }

            let address;
            try {
                address = parseInt(addressStr, 16);
                if (isNaN(address) || address < 0) {
                    throw new Error('Invalid address');
                }
            } catch (e) {
                previewDiv.innerHTML = '<span style="color: #ff6b6b;">Invalid address format. Use hex format like 0x10000</span>';
                if (applyBtn) applyBtn.disabled = true;
                return;
            }

            const fileSize = importFile.size;
            const endAddress = address + fileSize;
            const deviceSize = parser.sparseImage ? parser.sparseImage.size : deviceFlashSizeBytes;

            let html = `<div style="line-height: 1.8;">`;
            html += `File: <strong>${importFile.name}</strong><br>`;
            html += `Size: <strong>${formatBytes(fileSize)}</strong> (${fileSize} bytes)<br>`;
            html += `Start: <strong>0x${address.toString(16).toUpperCase()}</strong><br>`;
            html += `End: <strong>0x${endAddress.toString(16).toUpperCase()}</strong><br>`;
            html += `Allowed: <strong>0x${allowedStart.toString(16).toUpperCase()} - 0x${allowedEnd.toString(16).toUpperCase()}</strong><br>`;

            // Check if it fits in device flash
            if (endAddress > deviceSize) {
                html += `<br><span style="color: #ff6b6b;">âš ï¸ Warning: File extends beyond device flash size (0x${deviceSize.toString(16).toUpperCase()})</span>`;
                if (applyBtn) applyBtn.disabled = true;
            } else if (address < allowedStart || endAddress > allowedEnd) {
                html += `<br><span style="color: #ff6b6b;">âš ï¸ Warning: File exceeds allowed range</span>`;
                if (applyBtn) applyBtn.disabled = true;
            } else {
                // Check which partitions will be affected
                const affectedPartitions = [];
                if (parser.partitions) {
                    for (const part of parser.partitions) {
                        const partStart = part.offset;
                        const partEnd = part.offset + part.length;
                        // Check if ranges overlap
                        if (address < partEnd && endAddress > partStart) {
                            affectedPartitions.push(part.label);
                        }
                    }
                }

                if (affectedPartitions.length > 0) {
                    html += `<br>Affected partitions: <strong style="color: #ffa726;">${affectedPartitions.join(', ')}</strong>`;
                } else {
                    html += `<br><span style="color: #7a8bdc;">Will write to unpartitioned area</span>`;
                }

                if (applyBtn) applyBtn.disabled = false;
            }
            html += `</div>`;
            previewDiv.innerHTML = html;
        }

        async function applyImport() {
            if (!parser) {
                return;
            }

            // Handle JSON manifest
            if (importIsJson && importJsonData) {
                try {
                    // Check if erase flash is requested
                    const eraseFlashCheckbox = document.getElementById('importEraseFlash');
                    const shouldEraseFlash = eraseFlashCheckbox && eraseFlashCheckbox.checked;

                    if (shouldEraseFlash) {
                        setDeviceStatus('Erasing flash...', 'loading');
                        const deviceSize = parser.sparseImage ? parser.sparseImage.size : deviceFlashSizeBytes;
                        // Clear existing write buffers first, then fill with 0xFF
                        parser.sparseImage.writeBuffer = [];
                        parser.sparseImage.fill(0xFF, 0, deviceSize);
                        console.log(`Erased flash: 0x0 - 0x${deviceSize.toString(16).toUpperCase()}`);
                    }

                    setDeviceStatus('Downloading and importing manifest files...', 'loading');

                    let importCount = 0;
                    const rangeStart = importRangeStart;
                    const rangeEnd = importRangeStart + importRangeLength;
                    const deviceSize = parser.sparseImage ? parser.sparseImage.size : deviceFlashSizeBytes;
                    for (const entry of importJsonData.flashEntries) {
                        let url = entry.url || entry.path;

                        // Resolve relative URLs
                        if (importBaseUrl && !url.startsWith('http://') && !url.startsWith('https://')) {
                            url = importBaseUrl + '/' + url;
                        }

                        if (!url) {
                            console.warn('Skipping entry without URL:', entry);
                            continue;
                        }

                        console.log(`Downloading ${url} for address 0x${entry.address.toString(16).toUpperCase()}`);

                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`Failed to download ${url}: HTTP ${response.status}`);
                        }

                        const arrayBuffer = await response.arrayBuffer();
                        const data = new Uint8Array(arrayBuffer);

                        const entryStart = entry.address >>> 0;
                        const entryEnd = entryStart + data.length;
                        if (entryEnd > deviceSize) {
                            throw new Error(`Entry at 0x${entryStart.toString(16).toUpperCase()} exceeds device size 0x${deviceSize.toString(16).toUpperCase()}`);
                        }
                        if (entryStart < rangeStart || entryEnd > rangeEnd) {
                            throw new Error(`Entry at 0x${entryStart.toString(16).toUpperCase()} exceeds allowed range 0x${rangeStart.toString(16).toUpperCase()} - 0x${rangeEnd.toString(16).toUpperCase()}`);
                        }

                        // Write data to sparse image
                        await parser.sparseImage.write(entry.address, data);

                        console.log(`Imported ${formatBytes(data.length)} at 0x${entry.address.toString(16).toUpperCase()}`);
                        importCount++;
                    }

                    const didErase = shouldEraseFlash;
                    const eraseMsg = didErase ? ' (flash erased and rebuilt)' : '';
                    setDeviceStatus(`Imported ${importCount} files from manifest${eraseMsg}.`, 'success');

                    if (importCallback) {
                        await importCallback();
                    }

                    hideImportPopup();
                } catch (error) {
                    console.error('Manifest import error:', error);

                    // Check if it's a CORS error
                    if (error.message.includes('CORS') || error.message.includes('cross-origin') ||
                        error.name === 'TypeError' && !error.message.includes('HTTP')) {
                        const corsMsg = 'CORS Error: The server does not allow cross-origin requests.\n\n' +
                            'The server hosting these files has not enabled CORS.\n' +
                            'To fix this, either:\n' +
                            '  â€¢ Download the files manually and import them individually\n' +
                            '  â€¢ Ask the server administrator to enable CORS\n' +
                            '  â€¢ Use a CORS proxy service\n' +
                            '  â€¢ Run Edge with security disabled:\n' +
                            '    msedge.exe --user-data-dir=C:\\temp\\msedge-dev-data\\ --disable-web-security';
                        setDeviceStatus('CORS blocked: Server does not allow cross-origin requests', 'error');
                        alert(corsMsg);
                    } else {
                        setDeviceStatus('Manifest import failed: ' + error.message, 'error');
                        alert('Error importing manifest: ' + error.message);
                    }
                }
                return;
            }

            // Handle single binary file
            if (!importFile) {
                console.error('No import file selected');
                return;
            }

            console.log(`Importing file ${importFile.name}`);

            const addressInput = document.getElementById('importAddress');
            const addressStr = addressInput.value.trim();
            let address;
            try {
                address = parseInt(addressStr, 16);
                if (isNaN(address) || address < 0) {
                    throw new Error('Invalid address');
                }
            } catch (e) {
                alert('Invalid address format. Use hex format like 0x10000');
                return;
            }

            const fileSize = importFile.size;
            const endAddress = address + fileSize;
            const deviceSize = parser.sparseImage ? parser.sparseImage.size : deviceFlashSizeBytes;
            const rangeStart = importRangeStart;
            const rangeEnd = importRangeStart + importRangeLength;

            if (endAddress > deviceSize) {
                alert(`File extends beyond device flash size (0x${deviceSize.toString(16).toUpperCase()})`);
                return;
            }

            if (address < rangeStart || endAddress > rangeEnd) {
                alert(`File exceeds allowed range 0x${rangeStart.toString(16).toUpperCase()} - 0x${rangeEnd.toString(16).toUpperCase()}`);
                return;
            }

            try {
                const arrayBuffer = await importFile.arrayBuffer();
                const data = new Uint8Array(arrayBuffer);

                // Write data to sparse image
                await parser.sparseImage.write(address, data);

                setDeviceStatus(`Imported ${formatBytes(fileSize)} at 0x${address.toString(16).toUpperCase()}. Use "Write to Device" to flash.`, 'success');
                if (importCallback) {
                    await importCallback();
                }
                hideImportPopup();
            } catch (error) {
                console.error('Import error:', error);
                alert('Error importing file: ' + error.message);
            }
        }

        // Setup import popup event handlers
        document.addEventListener('DOMContentLoaded', () => {
            const importDropZone = document.getElementById('importDropZone');
            const importFileInput = document.getElementById('importFileInput');
            const importAddress = document.getElementById('importAddress');

            if (importFileInput) {
                importFileInput.addEventListener('change', async (e) => {
                    if (e.target.files.length > 0) {
                        importFile = e.target.files[0];
                        const fileNameSpan = document.getElementById('importFileName');
                        if (fileNameSpan) fileNameSpan.textContent = importFile.name;

                        // Check if JSON
                        if (importFile.name.toLowerCase().endsWith('.json')) {
                            importBaseUrl = null; // No base URL for local files
                            await handleJsonManifest(importFile);
                        } else {
                            importIsJson = false;
                            importJsonData = null;
                            importBaseUrl = null;
                            updateImportPreview();
                        }
                    }
                });
            }

            if (importAddress) {
                importAddress.addEventListener('input', () => {
                    updateImportPreview();
                });
            }

            if (importDropZone) {
                importDropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    importDropZone.classList.add('drag-over');
                });

                importDropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    importDropZone.classList.remove('drag-over');
                });

                importDropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    importDropZone.classList.remove('drag-over');

                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        importFile = files[0];
                        const fileNameSpan = document.getElementById('importFileName');
                        if (fileNameSpan) fileNameSpan.textContent = importFile.name;

                        // Check if JSON
                        if (importFile.name.toLowerCase().endsWith('.json')) {
                            importBaseUrl = null; // No base URL for local files
                            await handleJsonManifest(importFile);
                        } else {
                            importIsJson = false;
                            importJsonData = null;
                            importBaseUrl = null;
                            updateImportPreview();
                        }
                    }
                });
            }

            // Close popup when clicking outside
            const importPopup = document.getElementById('importPopup');
            if (importPopup) {
                importPopup.addEventListener('click', (e) => {
                    if (e.target === importPopup) {
                        hideImportPopup();
                    }
                });
            }
        });

        function togglePartitionDetails(idx) {
            const row = document.getElementById(`details-${idx}`);
            row.classList.toggle('visible');
        }

        async function parseOTADataPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            if (!contentDiv) {
                console.error(`Content div parsed-content-${idx} not found`);
                return;
            }

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing OTA data...</div>';

            try {
                const result = (await parser.parseOTAData(partition)).otaInfo;
                console.log('OTA data result:', result);
                const { entries, activeEntry } = result;

                // Count OTA partitions
                const otaPartitions = parser.partitions.filter(p =>
                    p.type === 0 && p.subType >= 0x10 && p.subType <= 0x1F
                );
                const otaCount = otaPartitions.length;

                // Build HTML display
                let html = '<div style="margin-top: 15px;">';

                html += `<div class="info-section" style="margin-bottom: 20px;">`;
                html += `<h4 style="margin: 0 0 10px 0; color: #7a8bdc;">OTA Boot Selection</h4>`;
                html += `<div style="font-size: 0.9em; color: #aaa; margin-bottom: 15px;">`;
                html += `Two redundant entries (sectors) store which OTA partition should boot. The valid entry with the highest sequence number is used.`;
                html += `</div>`;

                if (activeEntry !== null) {
                    const active = entries[activeEntry];
                    // Calculate which OTA partition will boot: (ota_seq - 1) % ota_app_count
                    const bootSlot = otaCount > 0 ? ((active.sequence - 1) % otaCount) : 0;
                    const bootPartition = otaPartitions[bootSlot];

                    html += `<div class="success" style="margin-bottom: 15px; padding: 15px;">`;
                    html += `<strong style="font-size: 1.1em;">Boot Partition:</strong> <span style="color: #88d899; font-size: 1.1em;">${bootPartition ? bootPartition.label : 'ota_' + bootSlot}</span><br>`;
                    html += `<div style="margin-top: 8px; font-size: 0.95em;">`;
                    html += `<strong>Active Entry:</strong> otadata[${activeEntry}]<br>`;
                    html += `<strong>Sequence:</strong> ${active.sequence}<br>`;
                    html += `<strong>OTA State:</strong> ${active.otaStateName}<br>`;
                    html += `<strong>OTA Slot:</strong> ${bootSlot} (calculated as (seq-1) % ${otaCount})`;
                    html += `</div>`;
                    html += `</div>`;
                } else {
                    html += '<div class="error" style="margin-bottom: 15px;">No valid OTA data entries - will boot factory partition or first OTA partition</div>';
                }

                html += `</div>`;

                // Show both entries with detailed status
                html += `<h4 style="margin: 20px 0 10px 0; color: #7a8bdc;">OTA Data Entries (Sectors)</h4>`;
                entries.forEach(entry => {
                    const isActive = entry.index === activeEntry;
                    const bgColor = isActive ? '#1f3d24' : '#2a2a2a';
                    const borderColor = isActive ? '#50a05e' : '#404040';

                    html += `<div style="background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 5px; padding: 15px; margin-bottom: 10px;">`;
                    html += `<strong style="color: ${isActive ? '#88d899' : '#aaa'};">otadata[${entry.index}]${isActive ? ' âœ“ ACTIVE' : ''}</strong>`;

                    if (entry.isEmpty) {
                        html += '<div style="margin-top: 8px; color: #888;">Empty (uninitialized - all 0xFF)</div>';
                    } else {
                        html += `<div style="margin-top: 8px; font-size: 0.9em;">`;
                        html += `<strong>Sequence:</strong> ${entry.sequence}<br>`;
                        html += `<strong>OTA State:</strong> ${entry.otaStateName} (0x${entry.otaState.toString(16).toUpperCase()})<br>`;
                        html += `<strong>CRC32:</strong> <span class="mono">0x${entry.crc.toString(16).toUpperCase().padStart(8, '0')}</span><br>`;
                        html += `<strong>Calculated:</strong> <span class="mono">0x${entry.calculatedCRC.toString(16).toUpperCase().padStart(8, '0')}</span><br>`;

                        const statusColor = entry.isValid ? '#81c784' : '#e57373';
                        const statusIcon = entry.isValid ? 'âœ“' : 'âœ—';
                        let statusText = entry.isValid ? 'Valid' : 'Invalid';
                        if (!entry.crcValid) {
                            statusText = 'CRC Mismatch';
                        } else if (!entry.isValid) {
                            statusText = 'Invalid State';
                        }
                        html += `<strong>Status:</strong> <span style="color: ${statusColor};">${statusIcon} ${statusText}</span>`;
                        html += `</div>`;
                    }

                    html += '</div>';
                });

                html += '</div>';
                contentDiv.innerHTML = html;

            } catch (error) {
                contentDiv.innerHTML = `<div class="error">Error parsing OTA data: ${error.message}</div>`;
                console.error('OTA data parse error:', error);
            }
        }

        function parseNVSPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            if (!contentDiv) {
                console.error(`Content div parsed-content-${idx} not found`);
                return;
            }

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing NVS data...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const nvsParser = await parser.parseNVS(partition);
                    currentNVSParser = nvsParser;
                    currentNVSPartition = partition;
                    const pages = nvsParser.pages;

                    console.log('NVS pages:', pages);

                    let html = '<div class="success" style="margin-bottom: 10px;">Found ' + pages.length + ' NVS pages <button class="nvs-add-btn" onclick="event.stopPropagation(); showNVSAddNamespaceDialog(' + idx + ')">âž• Add Namespace</button></div>';

                    const allNamespaces = {};
                    let totalItems = 0;

                    pages.forEach(page => {
                        page.items.forEach(item => {
                            if (item.nsIndex === 0) {
                                /* Collect namespace definitions */
                                if (item.namespace) {
                                    item.variables = [];
                                    allNamespaces[item.value] = item;
                                    totalItems++;
                                }
                            }
                        });
                    });
                    console.log('allNamespaces:', allNamespaces);

                    pages.forEach(page => {
                        page.items.forEach(item => {
                            if (item.nsIndex != 0) {
                                console.log('item:', item);
                                if (!allNamespaces[item.nsIndex]) {
                                    console.warn(`Namespace ${item.nsIndex} not found for item ${item.key}`);
                                    return;
                                }
                                allNamespaces[item.nsIndex].variables.push(item);
                            }
                            totalItems++;
                        });
                    });

                    if (allNamespaces.size === 0) {
                        html += '<div class="error">No namespaces found in this partition.</div>';
                    } else {
                        Object.keys(allNamespaces).forEach(nsKey => {
                            const nsObj = allNamespaces[nsKey];
                            const nsName = nsObj.namespace || nsKey;
                            console.log('Namespace:', nsName);
                            html += `<div class="nvs-namespace">Namespace: [${nsObj.value}] ${nsName} (${nsObj.variables.length} items)<button class="nvs-add-btn" onclick="event.stopPropagation(); showNVSAddDialog(${idx}, '${nsName}')">âž• Add Item</button></div>`;
                            nsObj.variables.forEach(item => {
                                const tooltip = `Offset: 0x${item.offset.toString(16).toUpperCase()} (${item.offset}), Size: ${item.entrySize} bytes`;
                                const crcBad = (item.headerCrcValid === false) || (item.dataCrcValid === false);
                                html += `<div class="nvs-item ${crcBad ? 'crc-bad' : ''}" title="${tooltip}" style="padding-right: 80px;">`;
                                html += `<button class="nvs-edit-btn" onclick="event.stopPropagation(); showNVSEditDialog(${idx}, '${nsName}', '${item.key}', '${item.typeName}', ${JSON.stringify(item.value).replace(/\"/g, '&quot;')})">âœï¸</button>`;
                                html += `<button class="nvs-delete-btn" onclick="event.stopPropagation(); deleteNVSItem(${idx}, '${nsName}', '${item.key}')">âŒ</button>`;
                                html += `<strong>${item.key}</strong> <span class="badge">${item.typeName}</span><br>`;
                                html += `Value: <span class="mono">${formatNVSValue(item)}</span>`;

                                if (item.headerCrcCalc !== undefined || item.dataCrcCalc !== undefined) {
                                    const headerValid = item.headerCrcCalc === undefined || item.headerCrcValid;
                                    const dataValid = item.dataCrcCalc === undefined || item.dataCrcValid;
                                    const allValid = headerValid && dataValid;

                                    if (allValid) {
                                        /* Both CRCs OK - show compact version with hover info */
                                        let hoverText = '';
                                        if (item.headerCrcCalc !== undefined) {
                                            const storedHex = (item.crc32 >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.headerCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            hoverText += `Header CRC: stored 0x${storedHex}, calc 0x${calcHex}`;
                                        }
                                        if (item.dataCrcCalc !== undefined) {
                                            const storedHex = (item.dataCrcStored >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.dataCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            if (hoverText) hoverText += '\\n';
                                            hoverText += `Data CRC: stored 0x${storedHex}, calc 0x${calcHex}`;
                                        }
                                        html += `<div class="crc-info" title="${hoverText}">CRCs: <span class="ok">OK</span> <span style="color: #9a9a9a;">â„¹ï¸</span></div>`;
                                    } else {
                                        /* At least one CRC failed - show full details */
                                        if (item.headerCrcCalc !== undefined) {
                                            const headerStatus = item.headerCrcValid ? '<span class="ok">OK</span>' : '<span class="bad">BAD</span>';
                                            const storedHex = (item.crc32 >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.headerCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            html += `<div class="crc-info">Header CRC: ${headerStatus} (stored 0x${storedHex}, calc 0x${calcHex})</div>`;
                                        }
                                        if (item.dataCrcCalc !== undefined) {
                                            const dataStatus = item.dataCrcValid ? '<span class="ok">OK</span>' : '<span class="bad">BAD</span>';
                                            const storedHex = (item.dataCrcStored >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.dataCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            html += `<div class="crc-info">Data CRC: ${dataStatus} (stored 0x${storedHex}, calc 0x${calcHex})</div>`;
                                        }
                                    }
                                }
                                html += `</div>`;
                            });
                        });
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('NVS parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing NVS: ${error.message}</div>`;
                }
            }, 100);
        }

        function formatNVSValue(item) {
            if (item.value === null) return 'null';
            if (typeof item.value === 'object') return JSON.stringify(item.value);
            if (item.typeName === 'String') return `"${item.value}"`;

            // For Blob chunks, show chunk info and data
            if (item.typeName === 'Blob' && item.chunkIndex !== undefined && item.chunkIndex !== 0xFF) {
                const chunkInfo = `<span style="color: #888;">[Chunk ${item.chunkIndex}]</span> `;

                if (item.rawValue) {
                    let hexLines = [];
                    let asciiLines = [];
                    const width = 32;

                    for (let i = 0; i < item.rawValue.length; i += width) {
                        const chunk = item.rawValue.slice(i, i + width);
                        const hexLine = Array.from(chunk)
                            .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                            .join(' ');
                        hexLines.push(hexLine);

                        let asciiLine = '';
                        for (let j = 0; j < chunk.length; j++) {
                            const byte = chunk[j];
                            asciiLine += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                        }
                        asciiLines.push(asciiLine);
                    }

                    return chunkInfo + `Hex:<br>${hexLines.join('<br>')}<br><span style="color: #d4a574;">ASCII:<br>${asciiLines.join('<br>')}</span>`;
                }
                return chunkInfo + item.value;
            }

            // For regular Blobs with raw data
            if (item.typeName === 'Blob' && item.rawValue) {
                let hexLines = [];
                let asciiLines = [];

                for (let i = 0; i < item.rawValue.length; i += 16) {
                    const chunk = item.rawValue.slice(i, i + 16);
                    const hexLine = Array.from(chunk)
                        .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                        .join(' ');
                    hexLines.push(hexLine);

                    let asciiLine = '';
                    for (let j = 0; j < chunk.length; j++) {
                        const byte = chunk[j];
                        asciiLine += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                    }
                    asciiLines.push(asciiLine);
                }

                return `Hex:<br>${hexLines.join('<br>')}<br><span style="color: #d4a574;">ASCII:<br>${asciiLines.join('<br>')}</span>`;
            }

            return item.value;
        }

        let currentFATParser = null;
        let currentFATPartition = null;
        let currentNVSParser = null;
        let currentNVSPartition = null;
        let currentSPIFFSParser = null;
        let currentSPIFFSPartition = null;

        function parseSPIFFSPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing SPIFFS filesystem...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const spiffsParser = await parser.parseSPIFFS(partition);
                    currentSPIFFSParser = spiffsParser;
                    currentSPIFFSPartition = partition;
                    const spiffsInfo = spiffsParser.spiffsInfo;

                    console.log('SPIFFS info:', spiffsInfo);

                    let html = '';

                    if (!spiffsInfo.valid) {
                        html += '<div class="error" style="margin-bottom: 10px;">âš ï¸ SPIFFS header not found. The partition may be empty, corrupted, or using a different filesystem.</div>';
                    } else {
                        html += '<div class="success" style="margin-bottom: 10px;">SPIFFS filesystem detected</div>';
                    }

                    // Filesystem info
                    html += '<h4 style="margin-top: 15px;">SPIFFS Information</h4>';
                    html += '<div class="info-grid">';
                    html += `<div class="info-item"><label>Valid Header:</label><span>${spiffsInfo.valid ? 'Yes' : 'No (estimated)'}</span></div>`;
                    if (spiffsInfo.magic) {
                        html += `<div class="info-item"><label>Magic:</label><span class="mono">0x${spiffsInfo.magic.toString(16).toUpperCase()}</span></div>`;
                    }
                    html += `<div class="info-item"><label>Block Size:</label><span>${spiffsInfo.blockSize} bytes (0x${spiffsInfo.blockSize.toString(16).toUpperCase()})</span></div>`;
                    html += `<div class="info-item"><label>Page Size:</label><span>${spiffsInfo.pageSize} bytes</span></div>`;
                    html += `<div class="info-item"><label>Total Size:</label><span>${formatBytes(spiffsInfo.totalSize)}</span></div>`;
                    html += `<div class="info-item"><label>Files Found:</label><span>${spiffsInfo.filesCount}</span></div>`;
                    html += '</div>';

                    // Files list with grouping: active vs deleted/old versions
                    if (spiffsInfo.files.length > 0) {
                        const activeFiles = spiffsInfo.files.filter(f => !f.deleted);
                        const deletedFiles = spiffsInfo.files.filter(f => f.deleted);

                        // Active files
                        html += `<h4 style="margin-top: 15px;">Files (${activeFiles.length} active${deletedFiles.length ? `, ${deletedFiles.length} deleted` : ''})</h4>`;
                        if (activeFiles.length > 0) {
                            html += '<table style="margin-top: 10px;"><thead><tr>';
                            html += '<th>Name</th><th>Object ID</th><th>Size</th><th>Block</th>';
                            html += '</tr></thead><tbody>';

                            activeFiles.forEach((file, fileIdx) => {
                                const fileId = `spiffsFile_${idx}_act_${fileIdx}`;
                                window[fileId] = file;
                                const clickable = file.size > 0;
                                const cursorStyle = clickable ? 'cursor: pointer;' : '';
                                const hoverClass = clickable ? 'class="fat-file-row"' : '';

                                html += `<tr ${hoverClass} style="${cursorStyle}" ${clickable ? `onclick="downloadSPIFFSFile('${fileId}')"` : ''}>`;
                                html += `<td><strong>${escapeHtml(file.name)}</strong></td>`;
                                html += `<td class="mono">0x${file.objId.toString(16).toUpperCase().padStart(4, '0')}</td>`;
                                html += `<td>${file.size > 0 ? formatBytes(file.size) : 'Unknown'}</td>`;
                                html += `<td>${file.blockIdx}</td>`;
                                html += '</tr>';
                            });

                            html += '</tbody></table>';
                        } else {
                            html += '<div style="margin-top: 10px; color: #888;">No active files found</div>';
                        }

                        // Deleted / old versions (collapsed group)
                        html += `<div style="margin-top: 18px;">
                                    <div class="expandable" style="padding:10px; border:1px solid #444; border-radius:6px; background:#2a2a2a;" onclick="(function(){
                                        const el=document.getElementById('spiffsDeletedGroup-${idx}');
                                        const ic=document.getElementById('spiffsDeletedToggle-${idx}');
                                        if(!el||!ic) return; 
                                        const vis=el.style.display!=='none';
                                        el.style.display= vis ? 'none' : 'block';
                                        ic.textContent = vis ? 'â–¶' : 'â–¼';
                                    })()">
                                        <span id="spiffsDeletedToggle-${idx}">â–¶</span>
                                        <strong style="margin-left:6px;">Deleted / old versions</strong>
                                        <span style="color:#aaa; margin-left:8px;">(${deletedFiles.length})</span>
                                    </div>
                                    <div id="spiffsDeletedGroup-${idx}" style="display:none; margin-top:8px;">
                                `;
                        if (deletedFiles.length > 0) {
                            html += '<table style="margin-top: 6px;"><thead><tr>';
                            html += '<th>Name</th><th>Object ID</th><th>Size</th><th>Block</th>';
                            html += '</tr></thead><tbody>';

                            deletedFiles.forEach((file, fileIdx) => {
                                const fileId = `spiffsFile_${idx}_del_${fileIdx}`;
                                window[fileId] = file;
                                const clickable = file.size > 0;
                                const cursorStyle = clickable ? 'cursor: pointer;' : '';
                                const hoverClass = clickable ? 'class="fat-file-row"' : '';

                                html += `<tr ${hoverClass} style="${cursorStyle}" ${clickable ? `onclick="downloadSPIFFSFile('${fileId}')"` : ''}>`;
                                html += `<td><strong>${escapeHtml(file.name)}</strong></td>`;
                                html += `<td class="mono">0x${file.objId.toString(16).toUpperCase().padStart(4, '0')}</td>`;
                                html += `<td>${file.size > 0 ? formatBytes(file.size) : (file.size === 0 ? '0' : 'Unknown')}</td>`;
                                html += `<td>${file.blockIdx}</td>`;
                                html += '</tr>';
                            });

                            html += '</tbody></table>';
                        } else {
                            html += '<div style="margin-top: 8px; color: #888;">No deleted entries</div>';
                        }
                        html += '</div></div>';
                    } else {
                        html += '<div style="margin-top: 15px; color: #888;">No files found. The filesystem may be empty or the partition is not SPIFFS.</div>';
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('SPIFFS parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing SPIFFS: ${error.message}</div>`;
                }
            }, 100);
        }

        async function downloadSPIFFSFile(fileId) {
            const file = window[fileId];
            if (!file || !currentSPIFFSParser) {
                alert('File data not available');
                return;
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'spiffs-loading-indicator';
            loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
            loadingDiv.textContent = `Loading ${file.name}...`;
            document.body.appendChild(loadingDiv);

            try {
                const fileData = await currentSPIFFSParser.readFile(file);
                const blob = new Blob([fileData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file: ' + error.message);
            } finally {
                // Remove loading indicator
                const indicator = document.getElementById('spiffs-loading-indicator');
                if (indicator) {
                    document.body.removeChild(indicator);
                }
            }
        }

        function parseFATPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing FAT filesystem...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const fatParser = await parser.parseFATFilesystem(partition);

                    if (fatParser.fatInfo.error) {
                        contentDiv.innerHTML = `<div class="error">${fatParser.fatInfo.error}</div>`;
                        return;
                    }

                    // Store parser instance for file downloads
                    currentFATParser = fatParser;
                    currentFATPartition = partition;

                    let html = '<div class="success" style="margin-bottom: 10px;">FAT filesystem parsed successfully</div>';

                    // Filesystem info
                    html += '<h4 style="margin-top: 15px;">Filesystem Information</h4>';
                    html += '<div class="info-grid">';
                    html += `<div class="info-item"><label>Type:</label><span>${fatParser.fatInfo.fatType}</span></div>`;
                    html += `<div class="info-item"><label>Volume Label:</label><span>${fatParser.fatInfo.volumeLabel}</span></div>`;
                    html += `<div class="info-item"><label>Bytes/Sector:</label><span>${fatParser.fatInfo.bytesPerSector}</span></div>`;
                    html += `<div class="info-item"><label>Sectors/Cluster:</label><span>${fatParser.fatInfo.sectorsPerCluster}</span></div>`;
                    html += `<div class="info-item"><label>Total Sectors:</label><span>${fatParser.fatInfo.totalSectors}</span></div>`;
                    html += `<div class="info-item"><label>Total Clusters:</label><span>${fatParser.fatInfo.totalClusters}</span></div>`;
                    html += '</div>';

                    // Wear leveling info
                    if (fatParser.fatInfo.wearLeveling && fatParser.fatInfo.wearLeveling.wlState) {
                        const wl = fatParser.fatInfo.wearLeveling.wlState;
                        html += '<h4 style="margin-top: 15px;">Wear Leveling</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Move Count:</label><span>${wl.moveCount}</span></div>`;
                        html += `<div class="info-item"><label>Access Count:</label><span>${wl.accessCount}</span></div>`;
                        html += `<div class="info-item"><label>Max Count:</label><span>${wl.maxCount}</span></div>`;
                        html += `<div class="info-item"><label>Block Size:</label><span>0x${wl.blockSize.toString(16).toUpperCase()}</span></div>`;
                        html += `<div class="info-item"><label>Version:</label><span>${wl.version}</span></div>`;
                        html += `<div class="info-item"><label>Device ID:</label><span>0x${wl.deviceId.toString(16).toUpperCase()}</span></div>`;
                        html += '</div>';
                    }

                    // Files list
                    html += '<h4 style="margin-top: 15px;">Files (' + countTotalFiles(fatParser.fatInfo.files) + ' total entries) <button class="add-btn" onclick="addFATFile(\'/\')" title="Add file to root directory">+</button></h4>';
                    if (fatParser.fatInfo.files.length > 0) {
                        html += '<table style="margin-top: 10px;"><thead><tr>';
                        html += '<th>Path</th><th>Size</th><th>Attributes</th><th>Date</th><th>Time</th><th>Cluster</th><th>Actions</th>';
                        html += '</tr></thead><tbody>';

                        renderFATFiles(fatParser.fatInfo.files, 0).forEach(row => {
                            html += row;
                        });

                        html += '</tbody></table>';
                    } else {
                        html += '<div style="margin-top: 10px; color: #888;">No files found</div>';
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('FAT parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing FAT: ${error.message}</div>`;
                }
            }, 100);
        }

        async function downloadFATFile(fileId) {
            const file = window[fileId];
            if (!file || !currentFATParser) {
                alert('File data not available');
                return;
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'fat-loading-indicator';
            loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
            loadingDiv.textContent = `Loading ${file.name}...`;
            document.body.appendChild(loadingDiv);

            try {
                const blob = await currentFATParser.extractFile(file);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file: ' + error.message);
            } finally {
                // Remove loading indicator
                const indicator = document.getElementById('fat-loading-indicator');
                if (indicator) {
                    document.body.removeChild(indicator);
                }
            }
        }

        async function deleteFATFile(fileId) {
            const file = window[fileId];
            if (!file || !currentFATParser || !currentFATPartition) {
                alert('File data not available');
                return;
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'fat-delete-indicator';
            loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
            loadingDiv.textContent = `Deleting ${file.name}...`;
            document.body.appendChild(loadingDiv);

            try {
                const result = await currentFATParser.deleteFile(file);

                if (result.success) {
                    console.log(`File "${file.name}" deleted successfully!\n${result.clustersCleared} clusters cleared.`);

                    // Re-parse the partition to refresh the file list
                    const partitionIdx = parser.partitions.indexOf(currentFATPartition);
                    if (partitionIdx !== -1) {
                        parseFATPartition(partitionIdx);
                    }
                } else {
                    alert('Error deleting file: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Delete error:', error);
                alert('Error deleting file: ' + error.message);
            } finally {
                // Remove loading indicator
                const indicator = document.getElementById('fat-delete-indicator');
                if (indicator) {
                    document.body.removeChild(indicator);
                }
            }
        }

        async function addFATFile(dirPath) {
            if (!currentFATParser || !currentFATPartition) {
                alert('FAT parser not available');
                return;
            }

            // Create modal dialog for file input
            const modal = document.createElement('div');
            modal.id = 'add-file-modal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center;';

            const dialog = document.createElement('div');
            dialog.style.cssText = 'background: #2a2b35; padding: 30px; border-radius: 8px; max-width: 500px; width: 90%;';

            const dirDisplayPath = dirPath || '(root)';
            dialog.innerHTML = `
                <h3 style="margin-top: 0;">Add File to ${dirDisplayPath}</h3>
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 5px;">Filename (8.3 format):</label>
                    <input type="text" id="add-file-name" placeholder="e.g., config.txt" style="width: 100%; padding: 8px; background: #1e1f29; border: 1px solid #444; color: #e0e0e0; border-radius: 4px;" />
                    <div style="font-size: 12px; color: #888; margin-top: 5px;">Max 8 characters for name, 3 for extension</div>
                </div>
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 5px;">File:</label>
                    <input type="file" id="add-file-input" style="width: 100%; padding: 8px; background: #1e1f29; border: 1px solid #444; color: #e0e0e0; border-radius: 4px;" />
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="add-file-cancel" style="padding: 10px 20px; background: #555; border: none; color: white; border-radius: 4px; cursor: pointer;">Cancel</button>
                    <button id="add-file-submit" style="padding: 10px 20px; background: #44cc44; border: none; color: white; border-radius: 4px; cursor: pointer;">Add File</button>
                </div>
            `;

            modal.appendChild(dialog);
            document.body.appendChild(modal);

            // Handle cancel
            document.getElementById('add-file-cancel').onclick = () => {
                document.body.removeChild(modal);
            };

            // Handle submit
            document.getElementById('add-file-submit').onclick = async () => {
                const filenameInput = document.getElementById('add-file-name');
                const fileInput = document.getElementById('add-file-input');

                let filename = filenameInput.value.trim();
                const file = fileInput.files[0];

                if (!file) {
                    alert('Please select a file');
                    return;
                }

                // Use uploaded filename if no custom name provided
                if (!filename) {
                    filename = file.name;
                }

                // Construct full path
                const fullPath = dirPath ? `${dirPath}/${filename}` : filename;

                // Close modal
                document.body.removeChild(modal);

                // Show loading indicator
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'fat-add-indicator';
                loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
                loadingDiv.textContent = `Adding ${filename}...`;
                document.body.appendChild(loadingDiv);

                try {
                    // Read file data
                    const arrayBuffer = await file.arrayBuffer();
                    const data = new Uint8Array(arrayBuffer);

                    // Add file to FAT
                    const result = await currentFATParser.addFile(fullPath, data);

                    if (result.success) {
                        alert(`File "${result.filename}" added successfully!\nSize: ${result.size} bytes\nClusters: ${result.clusters}\nStart cluster: 0x${result.startCluster.toString(16).toUpperCase()}`);

                        // Re-parse the partition to refresh the file list
                        const partitionIdx = parser.partitions.indexOf(currentFATPartition);
                        if (partitionIdx !== -1) {
                            parseFATPartition(partitionIdx);
                        }
                    } else {
                        alert('Error adding file: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Add file error:', error);
                    alert('Error adding file: ' + error.message);
                } finally {
                    // Remove loading indicator
                    const indicator = document.getElementById('fat-add-indicator');
                    if (indicator) {
                        document.body.removeChild(indicator);
                    }
                }
            };

            // Handle ESC key to close modal
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('add-file-modal');
                    if (modal) {
                        document.body.removeChild(modal);
                    }
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }

        function countTotalFiles(files) {
            let count = files.length;
            files.forEach(file => {
                if (file.children && file.children.length > 0) {
                    count += countTotalFiles(file.children);
                }
            });
            return count;
        }

        function renderFATFiles(files, depth) {
            const rows = [];
            const indent = '&nbsp;&nbsp;&nbsp;&nbsp;'.repeat(depth);

            files.forEach((file, fileIdx) => {
                const fileId = `fat-file-${depth}-${fileIdx}-${file.cluster}`;
                const clickable = !file.isDirectory && file.size > 0;
                const cursorStyle = clickable ? 'cursor: pointer;' : '';
                const hoverClass = clickable ? 'class="fat-file-row"' : '';

                let row = `<tr ${hoverClass} style="${cursorStyle}" ${clickable ? `onclick="downloadFATFile('${fileId}')"` : ''}>`;

                // Path column with indentation
                const icon = file.isDirectory ? 'ðŸ“' : 'ðŸ“„';
                row += `<td>${indent}${icon} <strong>${file.path || file.name}</strong></td>`;

                // Size (show - for directories)
                row += `<td>${file.isDirectory ? '-' : formatBytes(file.size)}</td>`;

                // Attributes
                row += `<td>${file.attributes.join(', ') || 'None'}</td>`;

                // Date & Time
                row += `<td class="mono">${file.date}</td>`;
                row += `<td class="mono">${file.time}</td>`;

                // Store file data for download
                if (clickable) {
                    window[fileId] = file;
                }

                // Cluster
                row += `<td class="mono">0x${file.cluster.toString(16).toUpperCase()}</td>`;

                // Actions (delete/add button)
                if (!file.isDirectory) {
                    row += `<td><button class="delete-btn" onclick="event.stopPropagation(); deleteFATFile('${fileId}')" title="Delete file">âœ•</button></td>`;
                } else {
                    // Store directory info for adding files
                    window[fileId] = file;
                    row += `<td><button class="add-btn" onclick="event.stopPropagation(); addFATFile('${file.path}')" title="Add file to this directory">+</button></td>`;
                }

                row += '</tr>';

                rows.push(row);

                // Add children if directory
                if (file.children && file.children.length > 0) {
                    rows.push(...renderFATFiles(file.children, depth + 1));
                }
            });

            return rows;
        }

        function parseImagePartitionInline(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            // Show loading
            contentDiv.innerHTML = '<div class="loading">â³ Parsing firmware image...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const image = await parser.parseImage(partition.offset, partition.length);

                    // Validate SHA256 (appended) and compute region hash
                    let sha256Validation = null;
                    let sha256RegionCalc = null;

                    if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined && image.sha256DataEnd > image.sha256DataStart) {
                        console.log(`Image SHA256 region: start=0x${image.sha256DataStart.toString(16)}, end=0x${image.sha256DataEnd.toString(16)}, length=${image.sha256DataEnd - image.sha256DataStart}`);

                        // Process in chunks to avoid allocation failures on large images
                        const MAX_CHUNK = 1024 * 1024; // 1 MB
                        const regionLength = image.sha256DataEnd - image.sha256DataStart;

                        if (regionLength <= MAX_CHUNK) {
                            // Small enough to process at once
                            const regionData = await parser.sparseImage.slice_async(image.sha256DataStart, image.sha256DataEnd);
                            const regionHash = await ESP32Parser.calculateSHA256(regionData);
                            sha256RegionCalc = ESP32Parser.bytesToHex(regionHash);
                        } else {
                            // Process in chunks using streaming hash
                            const hashBuffer = new Uint8Array(regionLength);
                            let offset = 0;
                            let remaining = regionLength;

                            while (remaining > 0) {
                                const chunkSize = Math.min(remaining, MAX_CHUNK);
                                const chunk = await parser.sparseImage.slice_async(
                                    image.sha256DataStart + offset,
                                    image.sha256DataStart + offset + chunkSize
                                );
                                hashBuffer.set(chunk, offset);
                                offset += chunkSize;
                                remaining -= chunkSize;
                            }

                            const regionHash = await ESP32Parser.calculateSHA256(hashBuffer);
                            sha256RegionCalc = ESP32Parser.bytesToHex(regionHash);
                        }
                    }

                    if (image.sha256) {
                        sha256Validation = await parser.validateImageSHA256(image);
                        // If validation didn't compute, reuse region calc
                        if (sha256Validation && !sha256Validation.calculated && sha256RegionCalc) {
                            sha256Validation.calculated = sha256RegionCalc;
                        }
                    }

                    let html = '';

                    if (image.error) {
                        html += `<div class="error" style="margin-bottom: 15px;"><strong>âš ï¸ Parsing Error:</strong> ${image.error}</div>`;
                    } else {

                        /* Check if OTA app checksum needs fixing */
                        let otaCheckNeedsFix = false;
                        try {
                            const checksumInfo = await parser.calculateImageChecksum(partition.offset, partition.length);
                            if (checksumInfo.checksum !== image.checksum) {
                                otaCheckNeedsFix = true;

                                const button = document.getElementById(`fix_check_${idx}`);
                                button.style.display = 'inline-block';
                            }
                        } catch (e) {
                            console.warn('Could not check OTA checksum:', e.message);
                        }

                        html += '<h4 style="margin-top: 15px;">Basic Information</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Magic:</label><span class="mono">0x${image.magic.toString(16).toUpperCase()}</span></div>`;
                        html += `<div class="info-item"><label>Segment Count:</label><span>${image.segmentCount}</span></div>`;
                        html += `<div class="info-item"><label>Entry Address:</label><span class="mono">0x${image.entryAddr.toString(16).toUpperCase().padStart(8, '0')}</span></div>`;
                        html += `<div class="info-item"><label>Chip:</label><span>${image.chipName} (0x${image.chipId.toString(16).toUpperCase().padStart(4, '0')})</span></div>`;
                        html += '</div>';

                        html += '<h4 style="margin-top: 15px;">Flash Configuration</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>SPI Mode:</label><span>${image.spiModeName} (${image.spiMode})</span></div>`;
                        html += `<div class="info-item"><label>SPI Speed:</label><span>${image.spiSpeedName}</span></div>`;
                        html += `<div class="info-item"><label>Flash Size:</label><span>${image.spiSizeName}</span></div>`;
                        html += `<div class="info-item"><label>WP Pin:</label><span>${image.wpPinDisabled ? 'Disabled (0xEE)' : '0x' + image.wpPin.toString(16).toUpperCase()}</span></div>`;
                        html += '</div>';

                        html += '<h4 style="margin-top: 15px;">Chip Revision</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Min Chip Rev:</label><span>v${image.minChipRevMajor}.${image.minChipRevMinor} (${image.minChipRevFull})</span></div>`;
                        html += `<div class="info-item"><label>Max Chip Rev:</label><span>v${image.maxChipRevMajor}.${image.maxChipRevMinor} (${image.maxChipRevFull})</span></div>`;
                        html += `<div class="info-item"><label>Legacy Min Rev:</label><span>${image.minChipRev}</span></div>`;
                        html += '</div>';

                        // App Description (if found)
                        if (image.appDesc && image.appDesc.found) {
                            html += '<h4 style="margin-top: 15px;">Application Description</h4>';
                            html += '<div class="info-grid">';
                            if (image.appDesc.projectName) {
                                html += `<div class="info-item"><label>Project Name:</label><span>${image.appDesc.projectName}</span></div>`;
                            }
                            if (image.appDesc.version) {
                                html += `<div class="info-item"><label>Version:</label><span>${image.appDesc.version}</span></div>`;
                            }
                            if (image.appDesc.idfVer) {
                                html += `<div class="info-item"><label>ESP-IDF Version:</label><span>${image.appDesc.idfVer}</span></div>`;
                            }
                            html += `<div class="info-item"><label>Secure Version:</label><span>${image.appDesc.secureVersion}</span></div>`;
                            if (image.appDesc.date && image.appDesc.time) {
                                html += `<div class="info-item"><label>Build Date/Time:</label><span>${image.appDesc.date} ${image.appDesc.time}</span></div>`;
                            }
                            if (image.appDesc.appElfSha256) {
                                html += `<div class="info-item" style="grid-column: 1 / -1;"><label>App ELF SHA256:</label><span class="mono" title="Reference only - ELF file not available for validation">${image.appDesc.appElfSha256} <span style="color: #9a9a9a;">â„¹ï¸</span></span></div>`;
                            }
                            html += '</div>';
                        }

                        html += '<h4 style="margin-top: 15px;">Validation</h4>';
                        html += '<div class="info-grid">';

                        /* Calculate expected checksum for OTA app */
                        let otaChecksumMismatch = false;
                        let otaCalculatedChecksum = null;
                        try {
                            const checksumInfo = await parser.calculateImageChecksum(partition.offset, partition.length);
                            otaCalculatedChecksum = checksumInfo.checksum;
                            otaChecksumMismatch = (checksumInfo.checksum !== image.checksum);
                        } catch (e) {
                            console.warn('Could not calculate OTA checksum:', e.message);
                        }

                        /* Checksum display */
                        const otaChecksumColor = otaChecksumMismatch ? '#e88888' : '#6ec589';
                        const otaChecksumIcon = otaChecksumMismatch ? 'âœ—' : 'âœ“';
                        html += `<div class="info-item"><label>Checksum:</label><span class="mono" style="color: ${otaChecksumColor};">0x${(image.checksum || 0).toString(16).toUpperCase().padStart(2, '0')} ${otaChecksumIcon}</span></div>`;
                        if (otaChecksumMismatch && otaCalculatedChecksum !== null) {
                            html += `<div class="info-item"><label>Checksum (calculated):</label><span class="mono">0x${otaCalculatedChecksum.toString(16).toUpperCase().padStart(2, '0')}</span></div>`;
                        }
                        html += `<div class="info-item"><label>Hash Appended:</label><span>${image.hasHash ? 'Yes' : 'No'}</span></div>`;

                        /* SHA256 display */
                        const otaSha256Match = image.sha256 && sha256RegionCalc && image.sha256.toLowerCase() === sha256RegionCalc.toLowerCase();
                        const otaSha256Valid = sha256Validation && sha256Validation.valid === true;
                        const otaSha256Invalid = sha256Validation && sha256Validation.valid === false;
                        const otaSha256Color = otaSha256Valid ? '#6ec589' : otaSha256Invalid ? '#e88888' : '#9a9a9a';
                        const otaSha256Icon = otaSha256Valid ? 'âœ“' : otaSha256Invalid ? 'âœ—' : 'â³';

                        if (image.sha256) {
                            html += `<div class="info-item" style="grid-column: 1 / -1;"><label>SHA256:</label><span class="mono" style="color: ${otaSha256Color};">${image.sha256} ${otaSha256Icon}</span></div>`;
                            if (otaSha256Invalid && sha256RegionCalc) {
                                html += `<div class="info-item" style="grid-column: 1 / -1;"><label>SHA256 (calculated):</label><span class="mono">${sha256RegionCalc}</span></div>`;
                            }
                        }
                        if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined) {
                            const regionLen = image.sha256DataEnd - image.sha256DataStart;
                            html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Hash region:</label><span class="mono">0x${image.sha256DataStart.toString(16).toUpperCase()} - 0x${image.sha256DataEnd.toString(16).toUpperCase()} (${regionLen} bytes)</span></div>`;
                        }
                        html += '</div>';

                        html += '<h4 style="margin-top: 15px;">Segments</h4>';
                        html += '<table><thead><tr><th>#</th><th>Load Address</th><th>Length</th><th>Offset</th></tr></thead><tbody>';
                        image.segmentList.forEach((seg, sidx) => {
                            html += '<tr>';
                            html += `<td>${sidx}</td>`;
                            html += `<td class="mono">0x${seg.loadAddress.toString(16).toUpperCase().padStart(8, '0')}</td>`;
                            html += `<td>${formatBytes(seg.length)}</td>`;
                            html += `<td class="mono">0x${seg.offset.toString(16).toUpperCase()}</td>`;
                            html += '</tr>';
                        });
                        html += '</tbody></table>';
                    }

                    contentDiv.innerHTML = html;

                    // Update the Save OTA Image button to show actual size
                    if (image.sha256DataEnd !== undefined) {
                        const imageSize = image.sha256DataEnd - partition.offset;
                        const saveButton = document.getElementById(`save_ota_${idx}`);
                        if (saveButton) {
                            saveButton.textContent = `Save OTA Image (${formatBytes(imageSize)})`;
                        }
                    }
                } catch (error) {
                    console.error('Image parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing image: ${error.message}</div>`;
                }
            }, 100);
        }

        async function downloadPartition(idx) {
            /* Handle bootloader (-1) and regular partitions */
            let partition;
            if (idx === -1) {
                // Use parsed bootloader bounds if available, otherwise fall back to partition table offset
                if (bootloaderInfo && bootloaderInfo.bootloaderEnd) {
                    partition = { label: 'bootloader', offset: 0x0000, length: bootloaderInfo.bootloaderEnd };
                } else {
                    const bootloaderEnd = partitionTableOffset || 0x8000;
                    partition = { label: 'bootloader', offset: 0x0000, length: bootloaderEnd };
                }
            } else {
                partition = parser.partitions[idx];
            }

            setFetchOverlayReason(`Download ${partition.label}`);
            showFetchOverlay(`Downloading ${partition.label}...`);
            try {
                const blob = await parser.exportPartitionData(partition);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${partition.label}_0x${partition.offset.toString(16)}.bin`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Partition download error:', error);
                alert('Error downloading partition: ' + error.message);
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
            }
        }

        async function downloadOTAImage(idx) {
            const partition = parser.partitions[idx];
            if (!partition) {
                alert('Partition not found.');
                return;
            }

            setFetchOverlayReason(`Save OTA image (${partition.label})`);
            showFetchOverlay(`Preparing OTA image from header...`);
            try {
                // Re-parse to get precise header-defined bounds
                const image = await parser.parseImage(partition.offset, partition.length);

                if (image && image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined) {
                    const start = partition.offset;
                    // If appended SHA256 present, include it (32 bytes)
                    const hasAppendedHash = !!image.sha256;
                    const end = image.sha256DataEnd + (hasAppendedHash ? 32 : 0);

                    const bytes = await parser.sparseImage.slice_async(start, end);

                    const blob = new Blob([bytes], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${partition.label}_ota_0x${start.toString(16)}-0x${end.toString(16)}.bin`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else {
                    alert('Unable to determine OTA image bounds from header.');
                }
            } catch (error) {
                console.error('OTA image download error:', error);
                alert('Error saving OTA image: ' + error.message);
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
            }
        }

        async function viewPartitionHex(idx) {
            /* Handle bootloader (-1) and regular partitions */
            let partition;
            if (idx === -1) {
                partition = { label: 'bootloader', offset: 0, length: 0x10000 };
            } else {
                partition = parser.partitions[idx];
            }
            document.getElementById('hexOffset').value = '0x' + partition.offset.toString(16).toUpperCase();
            document.getElementById('hexLength').value = '0x' + Math.min(partition.length, 0x1000).toString(16).toUpperCase();
            switchTab('raw');
            updateHexView();
        }

        async function updateHexView() {
            const offsetStr = document.getElementById('hexOffset').value.trim();
            const lengthStr = document.getElementById('hexLength').value.trim();
            const rawContent = document.getElementById('rawContent');

            if (!parser) {
                rawContent.innerHTML = '<div class="error">No firmware loaded</div>';
                return;
            }

            // Show loading indicator
            rawContent.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading hex view...</div>';

            try {
                const offset = parseInt(offsetStr, 16);
                const length = parseInt(lengthStr, 16);

                if (isNaN(offset) || isNaN(length)) {
                    rawContent.innerHTML = '<div class="error">Invalid offset or length. Use hex format (e.g., 0x1000)</div>';
                    return;
                }

                const totalLen = parser.sparseImage.size;

                if (offset < 0 || offset >= totalLen) {
                    rawContent.innerHTML = '<div class="error">Offset out of range</div>';
                    return;
                }

                const actualLength = Math.min(length, totalLen - offset);
                if (actualLength > 0x100000) {
                    rawContent.innerHTML = '<div class="error">Length too large. Maximum is 0x100000 (1MB)</div>';
                    return;
                }

                const hexView = await generateHexView(offset, actualLength);
                rawContent.innerHTML = hexView;
            } catch (error) {
                rawContent.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }

        async function generateHexView(offset, length) {
            const bytes = await parser.sparseImage.subarray_async(offset, offset + length);
            const widthInput = document.getElementById('hexWidth');
            const bytesPerLine = widthInput ? parseInt(widthInput.value) || 16 : 16;

            let html = '<div class="hex-viewer">';

            for (let i = 0; i < bytes.length; i += bytesPerLine) {
                const lineOffset = offset + i;
                const lineBytes = bytes.slice(i, Math.min(i + bytesPerLine, bytes.length));

                html += '<div>';

                // Offset (colored)
                html += `<span class="hex-offset">${lineOffset.toString(16).toUpperCase().padStart(8, '0')}</span>  `;

                // Hex bytes (colored)
                let hexPart = '';
                for (let j = 0; j < bytesPerLine; j++) {
                    if (j < lineBytes.length) {
                        const byte = lineBytes[j];
                        hexPart += byte.toString(16).toUpperCase().padStart(2, '0') + ' ';
                    } else {
                        hexPart += '   ';
                    }

                    if (j === Math.floor(bytesPerLine / 2) - 1) {
                        hexPart += ' ';
                    }
                }
                html += `<span class="hex-bytes">${hexPart}</span>`;

                // Add spacing before ASCII
                html += '   ';

                // ASCII representation (colored)
                let asciiPart = '';
                for (let j = 0; j < lineBytes.length; j++) {
                    const byte = lineBytes[j];
                    asciiPart += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                }
                html += `<span class="hex-ascii">${asciiPart}</span>`;

                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        function switchTab(tabName, event) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            if (event?.target) {
                event.target.classList.add('active');
            } else {
                // Find and activate by tab name if no event
                document.querySelectorAll('.tab').forEach(tab => {
                    if (tab.textContent.toLowerCase().includes(tabName)) {
                        tab.classList.add('active');
                    }
                });
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }

        function showError(message) {
            console.error('showError:', message);
            const content = document.getElementById('partitionsContent');
            if (content) {
                content.innerHTML = `<div class="error">${message}</div>`;
            }
        }

        async function deleteNVSItem(partitionIdx, namespace, key) {
            if (!currentNVSParser) {
                alert('No NVS partition loaded.');
                return;
            }

            try {
                await currentNVSParser.deleteItem(namespace, key);

                // Refresh the NVS display
                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Deleted NVS item: ${namespace}.${key}`, 'success');
            } catch (error) {
                alert('Error deleting NVS item: ' + error.message);
            }
        }

        let currentNVSAddPartition = null;
        let currentNVSAddNamespace = null;

        function showNVSAddDialog(partitionIdx, namespace) {
            currentNVSAddPartition = partitionIdx;
            currentNVSAddNamespace = namespace;

            const overlay = document.createElement('div');
            overlay.className = 'nvs-popup-overlay';
            overlay.onclick = closeNVSAddDialog;

            const popup = document.createElement('div');
            popup.className = 'nvs-popup';
            popup.onclick = (e) => e.stopPropagation();

            popup.innerHTML = `
                <h3>Add NVS Item to ${namespace}</h3>
                <label for="nvs-add-key">Key:</label>
                <input type="text" id="nvs-add-key" maxlength="15" placeholder="Key name (max 15 chars)">
                
                <label for="nvs-add-type">Type:</label>
                <select id="nvs-add-type" onchange="updateNVSAddValueInput()">
                    <option value="U8">U8 (Unsigned 8-bit)</option>
                    <option value="U16">U16 (Unsigned 16-bit)</option>
                    <option value="U32">U32 (Unsigned 32-bit)</option>
                    <option value="U64">U64 (Unsigned 64-bit)</option>
                    <option value="I8">I8 (Signed 8-bit)</option>
                    <option value="I16">I16 (Signed 16-bit)</option>
                    <option value="I32">I32 (Signed 32-bit)</option>
                    <option value="I64">I64 (Signed 64-bit)</option>
                    <option value="String">String</option>
                    <option value="BlobSmall">Blob Small (Hex, â‰¤32 bytes)</option>
                    <option value="BlobSmallString">Blob Small (String, â‰¤32 bytes)</option>
                    <option value="Blob">Blob (Hex)</option>
                    <option value="BlobString">Blob (String)</option>
                </select>
                
                <label for="nvs-add-value">Value:</label>
                <input type="text" id="nvs-add-value" placeholder="Enter value">
                <div id="nvs-add-value-hint" style="font-size: 0.85em; color: #888; margin-top: 5px;">Enter a number (0-255)</div>
                
                <div class="nvs-popup-buttons">
                    <button class="btn" onclick="closeNVSAddDialog()">Cancel</button>
                    <button class="btn" onclick="submitNVSAddDialog()" style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Add</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Initialize value input hint
            setTimeout(() => {
                updateNVSAddValueInput();
                document.getElementById('nvs-add-key').focus();
            }, 100);
        }

        function showNVSAddNamespaceDialog(partitionIdx) {
            currentNVSAddPartition = partitionIdx;

            const overlay = document.createElement('div');
            overlay.className = 'nvs-popup-overlay';
            overlay.onclick = closeNVSAddDialog;

            const popup = document.createElement('div');
            popup.className = 'nvs-popup';
            popup.onclick = (e) => e.stopPropagation();

            popup.innerHTML = `
                <h3>Add New Namespace</h3>
                <label for="nvs-namespace-name">Namespace Name:</label>
                <input type="text" id="nvs-namespace-name" maxlength="15" placeholder="Namespace name (max 15 chars)">
                <div style="font-size: 0.85em; color: #888; margin-top: 5px;">Enter a unique namespace name</div>
                
                <div class="nvs-popup-buttons">
                    <button class="btn" onclick="closeNVSAddDialog()">Cancel</button>
                    <button class="btn" onclick="submitNVSAddNamespaceDialog()" style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Create</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            setTimeout(() => {
                document.getElementById('nvs-namespace-name').focus();
            }, 100);
        }

        function showNVSEditDialog(partitionIdx, namespace, key, type, value) {
            currentNVSAddPartition = partitionIdx;
            currentNVSAddNamespace = namespace;
            window.currentNVSEditKey = key;

            const overlay = document.createElement('div');
            overlay.className = 'nvs-popup-overlay';
            overlay.onclick = closeNVSAddDialog;

            const popup = document.createElement('div');
            popup.className = 'nvs-popup';
            popup.onclick = (e) => e.stopPropagation();

            // Format value for display in input
            let displayValue = value;
            if (type === 'String') {
                displayValue = value.replace(/^"|"$/g, '');
            } else if (type === 'Blob') {
                // Extract hex from formatted blob value
                if (typeof value === 'string') {
                    const hexMatch = value.match(/Hex: ([0-9A-F ]+)/i);
                    if (hexMatch) {
                        displayValue = hexMatch[1];
                    }
                }
            }

            popup.innerHTML = `
                <h3>Edit NVS Item: ${key}</h3>
                <label>Key: <strong>${key}</strong> (read-only)</label>
                
                <label for="nvs-add-type">Type:</label>
                <select id="nvs-add-type" onchange="updateNVSAddValueInput()">
                    <option value="U8" ${type === 'U8' ? 'selected' : ''}>U8 (Unsigned 8-bit)</option>
                    <option value="U16" ${type === 'U16' ? 'selected' : ''}>U16 (Unsigned 16-bit)</option>
                    <option value="U32" ${type === 'U32' ? 'selected' : ''}>U32 (Unsigned 32-bit)</option>
                    <option value="U64" ${type === 'U64' ? 'selected' : ''}>U64 (Unsigned 64-bit)</option>
                    <option value="I8" ${type === 'I8' ? 'selected' : ''}>I8 (Signed 8-bit)</option>
                    <option value="I16" ${type === 'I16' ? 'selected' : ''}>I16 (Signed 16-bit)</option>
                    <option value="I32" ${type === 'I32' ? 'selected' : ''}>I32 (Signed 32-bit)</option>
                    <option value="I64" ${type === 'I64' ? 'selected' : ''}>I64 (Signed 64-bit)</option>
                    <option value="String" ${type === 'String' ? 'selected' : ''}>String</option>
                    <option value="BlobSmall" ${type === 'BlobSmall' ? 'selected' : ''}>Blob Small (Hex, â‰¤32 bytes)</option>
                    <option value="BlobSmallString" ${type === 'BlobSmallString' ? 'selected' : ''}>Blob Small (String, â‰¤32 bytes)</option>
                    <option value="Blob" ${type === 'Blob' ? 'selected' : ''}>Blob (Hex)</option>
                    <option value="BlobString" ${type === 'BlobString' ? 'selected' : ''}>Blob (String)</option>
                </select>
                
                <label for="nvs-add-value">Value:</label>
                <input type="text" id="nvs-add-value" placeholder="Enter value" value="${displayValue}">
                <div id="nvs-add-value-hint" style="font-size: 0.85em; color: #888; margin-top: 5px;">Enter a number (0-255)</div>
                
                <div class="nvs-popup-buttons">
                    <button class="btn" onclick="closeNVSAddDialog()">Cancel</button>
                    <button class="btn" onclick="submitNVSEditDialog()" style="background: linear-gradient(135deg, #d49f37 0%, #b58f30 100%);">Save</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Initialize value input hint
            setTimeout(() => {
                updateNVSAddValueInput();
                document.getElementById('nvs-add-value').focus();
                document.getElementById('nvs-add-value').select();
            }, 100);
        }

        function updateNVSAddValueInput() {
            const typeSelect = document.getElementById('nvs-add-type');
            const valueInput = document.getElementById('nvs-add-value');
            const hint = document.getElementById('nvs-add-value-hint');

            if (!typeSelect || !valueInput || !hint) return;

            const type = typeSelect.value;

            switch (type) {
                case 'U8':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (0-255)';
                    hint.textContent = 'Range: 0 to 255';
                    break;
                case 'U16':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (0-65535)';
                    hint.textContent = 'Range: 0 to 65535';
                    break;
                case 'U32':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (0-4294967295)';
                    hint.textContent = 'Range: 0 to 4294967295';
                    break;
                case 'U64':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter number (0-18446744073709551615)';
                    hint.textContent = 'Range: 0 to 18446744073709551615';
                    break;
                case 'I8':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (-128 to 127)';
                    hint.textContent = 'Range: -128 to 127';
                    break;
                case 'I16':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (-32768 to 32767)';
                    hint.textContent = 'Range: -32768 to 32767';
                    break;
                case 'I32':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (-2147483648 to 2147483647)';
                    hint.textContent = 'Range: -2147483648 to 2147483647';
                    break;
                case 'I64':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter number (-9223372036854775808 to 9223372036854775807)';
                    hint.textContent = 'Range: -9223372036854775808 to 9223372036854775807';
                    break;
                case 'String':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter string value';
                    hint.textContent = 'Enter any text (max 1984 bytes)';
                    break;
                case 'BlobSmall':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter hex bytes (e.g., 01 02 03 FF)';
                    hint.textContent = 'Enter hex bytes separated by spaces (max 32 bytes)';
                    break;
                case 'BlobSmallString':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter string value';
                    hint.textContent = 'Enter string to be stored as small blob (max 32 bytes)';
                    break;
                case 'Blob':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter hex bytes (e.g., 01 02 03 FF)';
                    hint.textContent = 'Enter hex bytes separated by spaces (max 1984 bytes)';
                    break;
                case 'BlobString':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter string value';
                    hint.textContent = 'Enter string to be stored as blob (max 1984 bytes)';
                    break;
            }
        }

        function closeNVSAddDialog() {
            const overlay = document.querySelector('.nvs-popup-overlay');
            if (overlay) {
                document.body.removeChild(overlay);
            }
            currentNVSAddPartition = null;
            currentNVSAddNamespace = null;
        }

        async function submitNVSAddDialog() {
            const key = document.getElementById('nvs-add-key').value.trim();
            let type = document.getElementById('nvs-add-type').value;
            let value = document.getElementById('nvs-add-value').value.trim();

            if (!key) {
                alert('Please enter a key name.');
                return;
            }

            if (key.length > 15) {
                alert('Key name must be 15 characters or less.');
                return;
            }

            if (!value) {
                alert('Please enter a value.');
                return;
            }

            // Convert BlobString to Blob with hex bytes
            if (type === 'BlobString') {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(value);
                value = Array.from(bytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                type = 'Blob';
            }

            // Convert BlobSmallString to BlobSmall with hex bytes
            if (type === 'BlobSmallString') {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(value);
                value = Array.from(bytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                type = 'BlobSmall';
            }

            // Save partition index and namespace before closing dialog
            const partitionIdx = currentNVSAddPartition;
            const namespace = currentNVSAddNamespace;

            try {
                if (!currentNVSParser) {
                    alert('No NVS partition loaded.');
                    return;
                }

                await currentNVSParser.addItem(namespace, key, type, value);

                closeNVSAddDialog();

                // Ensure the details row is visible before parsing
                const detailsRow = document.getElementById(`details-${partitionIdx}`);
                if (detailsRow && !detailsRow.classList.contains('visible')) {
                    detailsRow.classList.add('visible');
                }

                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Added NVS item: ${namespace}.${key}`, 'success');
            } catch (error) {
                alert('Error adding NVS item: ' + error.message);
            }
        }

        async function submitNVSEditDialog() {
            const oldKey = window.currentNVSEditKey;
            let type = document.getElementById('nvs-add-type').value;
            let value = document.getElementById('nvs-add-value').value.trim();

            if (!value) {
                alert('Please enter a value.');
                return;
            }

            // Convert BlobString to Blob with hex bytes
            if (type === 'BlobString') {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(value);
                value = Array.from(bytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                type = 'Blob';
            }

            // Convert BlobSmallString to BlobSmall with hex bytes
            if (type === 'BlobSmallString') {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(value);
                value = Array.from(bytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                type = 'BlobSmall';
            }

            // Save partition index and namespace before closing dialog
            const partitionIdx = currentNVSAddPartition;
            const namespace = currentNVSAddNamespace;

            try {
                if (!currentNVSParser) {
                    alert('No NVS partition loaded.');
                    return;
                }

                // Update using the updateItem method (delete + add)
                await currentNVSParser.updateItem(namespace, oldKey, type, value);
                console.log(`Updated NVS item: ${namespace}/${oldKey} = ${value} (${type})`);

                closeNVSAddDialog();

                // Ensure the details row is visible before parsing
                const detailsRow = document.getElementById(`details-${partitionIdx}`);
                if (detailsRow && !detailsRow.classList.contains('visible')) {
                    detailsRow.classList.add('visible');
                }

                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Updated NVS item: ${namespace}.${oldKey}`, 'success');
            } catch (error) {
                alert('Error updating NVS item: ' + error.message);
            }
        }

        async function submitNVSAddNamespaceDialog() {
            const namespaceName = document.getElementById('nvs-namespace-name').value.trim();

            if (!namespaceName) {
                alert('Please enter a namespace name.');
                return;
            }

            if (namespaceName.length > 15) {
                alert('Namespace name must be 15 characters or less.');
                return;
            }

            // Save partition index before closing dialog
            const partitionIdx = currentNVSAddPartition;

            try {
                if (!currentNVSParser) {
                    alert('No NVS partition loaded.');
                    return;
                }

                await currentNVSParser.addNamespace(namespaceName);
                console.log(`Added namespace: ${namespaceName}`);

                closeNVSAddDialog();

                // Ensure the details row is visible before parsing
                const detailsRow = document.getElementById(`details-${partitionIdx}`);
                if (detailsRow && !detailsRow.classList.contains('visible')) {
                    detailsRow.classList.add('visible');
                }

                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Created namespace: ${namespaceName}`, 'success');
            } catch (error) {
                alert('Error creating namespace: ' + error.message);
            }
        }
    </script>
</body>

</html>
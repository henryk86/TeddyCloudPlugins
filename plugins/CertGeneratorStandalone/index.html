<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CA Certificate Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/node-forge@1.0.0/dist/forge.min.js"></script>
    <script>
/* Inlined from chips.js */

class ChipDescriptions {
    constructor() {
        this.chip_descriptions = {
            /*
                These are the flash stub loaders from esptool: 
                https://github.com/espressif/esptool/tree/master/esptool/targets/stub_flasher/1
                
                The binaries in JSON format distributed in this directory are released as Free Software under GNU General Public License Version 2 or later. 
            */
            "esp32": {
                "magic_value": 0x00F01D83,
                "mac_efuse_reg": 0x3FF5A004,
                "stub":
                {
                    "entry": 1074521712,
                    "text": "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",
                    "text_start": 1074520064,
                    "data": "DMD8P3HoC0AH6QtAke0LQKfpC0Aq6QtAp+kLQADqC0AH6wtAfesLQCLrC0Ad6AtAs+oLQPzqC0Ae6gtAnusLQEjqC0Ce6wtA/ugLQGDpC0Cn6QtAAOoLQBDpC0Bs7AtAVu0LQIjtC0By7QtAiO0LQIjtC0CI7QtAiO0LQIjtC0CI7QtAiO0LQIjtC0D/6wtAiO0LQIfsC0BW7QtA",
                    "data_start": 1073605548,
                    "bss_start": 1073528832
                }
            },
            "esp32s2": {
                "mac_efuse_reg": 0x3F41A044,
                "magic_value": 0x000007C6,
                "stub":
                {
                    "entry": 1073907892,
                    "text": "CAAAYBwAAGBIAP0/EAAAYDZBAIH7/1H7/8AgAGgIwCAAeAVwcJSc5ww0MEQBgfb/wCAAqASICHLH/6CgdOAIAFaX/sb1/wAAgfH/wCAAaQgd8AAA8Cv+P2ir/T+o6/0/9Cv+P+gr/j/sK/4/NkEAsfn/IKB0EBEgpQsBltoEkfr/gfj/wCAAuAjAIACCGQCAgPQbyMAgAMJZAIqLwCAAokgAwCAAghkAkqBAgID0ktlAl5hHkez/gej/wCAAyAmh6P+x5v+HnBgGAgAAfOiHGuLGCQDAIACJCsAgALkJRgIAwCAAuQrAIACJCZKhhJLZf5qIkqAAwCAAklgAHfAAAFQgQD9UMEA/NkEAkf3/wCAAiAmAgCRWSP+R+v/AIACICYCAJFZI/x3wAAAALCBAPwAgQD82QQAQESDl/P+B+/8MCcAgAJkIDBqR+f9QqgHAIACpCcAgAKgJVnr/wCAAKAh8+IAiMCAgBB3wADZBABARICX8/xZq/4Hu/wwZIJkBwCAAmQjAIACYCFZ5/x3wAFiA/T8EIEA/NkEAYf3/WEYWhQYQESDl+P8W+gUM+HKgAFeoC3ImAnBwNHD3QHB1QRARIKX6/xARIOXz/5gmDBpAiRGAqgGMNwwakKoBse3/gIgRgIhBwCAAiQuB0f/AIACiaADAIACoCFZ6/wwYHApwipOAVcCKmVlGmSYd8AAA+Pz/P0QA/T9MAP0/ADIBQOwxAUAwMwFANmEAfMitAoeTLTH3/8YFAACoAwwcvQGB9//gCACBcP+iAQCICOAIAKgDgfP/4AgA5hrdRgoAAABmAyQMCIkBzQEMK4Hu/+AIAJgBgej/zMmoCGYaCLHm/8AgAKJLAJkIHfAAAHDi+j8IIEA/hGIBQKRiAUA2YQAQESBl5v+h+f+9AYH6/+AIAC0KDBf8SoIhAJKiAJCIEIJhABARIGXq/5Hy/wwawCAAiAmgqgGgiCDAIACJCbIhAKHr/4Ht/+AIAKBygy0HHfA2QQCBp/8MGZJIADCcQZkofPmQlLUpODkYmiIwMLQqMwwJmVgwPEEMGTlIQJSDgtgrkkgMEBEgZff/LQqCoMWgKJMd8Hh2AUDgdwFAlHYBQDZBAIH8/+AIAG0CIZH/iDKAM2MWkwR4EnpzcHxBRgEAEBEgZeP/iEKmGAWCIgKHp+4QESDl2/8Wav+oEs0DvQaB7v/gCACMOoKgxIlSiBI6iIkSiDIwiMCJMoHo/+AIAB3wAADMcQFANkEAbQIheP+9A4LSK4IIDBbIAGCmIBARIOX3/0YUAACIMoAzYxaDBHgSenNwfEHGAQAAABARIKXb/4hCphgEiCKHp+8QESBl1P8Wav+oEs0DvQaB6v/gCACgoHSMSoKgxIJiBYgSOoiJEogyMIjAiTId8ABAAP0/AAD9P4wxAUA2QQCB/P+x/P/CKACBd/+iKACB+v/gCACR9/8MCIkJHfAAAABgLwFANkEAgf7/4AgAIgoYIsL+IPJAICVBHfAA/Cv+P/gr/j8YAEw/jABMPzZBABARICX9/xZaBLH5/4gLvNiB+P+YCLxpoff/fMzAIACICpCQFMCIEJCIIMAgAIkKofL/iAvAIACYCnz7gIoUstv0YIgRsJkQkIggwCAAiQod8CgrAUA2QQAQESCl9/+8CpHQ/4gJG6ipCZHP/4qZIkkAkq9AmiKg8kCgpUGMkoLIwZKgAYCak4z5EBEgJfL/xgEArQKB7//gCAAd8AA2QQCioMAQESDl+v8d8AAANkEAgqDArQKHkhGioNsQESBl+f+ioNxGBAAAAACCoNuHkggQESAl+P+ioN0QESCl9/8d8DZBADoyxgIAAKICABsiEBEgpfv/N5LxHfAAAABsUgBAjHIBQIxSAEAMUwBANiEhotEQDBaB+v/gCABAZhGGCQAAYHNjzQe9Aa0CgfX/4AgAoKB0/FrNB70BotEQgfL/4AgAeiJwM8BWY/1cgzLTEDoxstEQrQOB7P/gCAAcC60DEBEg5ff/DALGAAAAIqBjHfAAAABAKwFANkEAEBEgZeX/jLqBh/+ICIxIEBEg5eH/DAqB+P/gCAAd8AAAhDIBQLTxAECQMgFAwPEAQDZBABARICXi/6zanBKB9v6oCIH3/+AIAKKiAMYHAAAAoqIAgfT/4AgAge/+qAiB8v/gCACGBQAAAAAsCoyCge//4AgAhgEAAIHr/+AIAB3wWBAAAHwQAAB4EAAAdBAAAHAQAADwKwFANkEhgf3/DAoaiEkIgfr/GohZCAwIUtEQgmUaEBEgpff/kfX/DBgamZgJQIgRl7gChkoAUKUggaz/4AgAke3/gqBsgtgQioEamYkJgef/kef/ioEamQwGiQkGMACB5/9gQ8AaiIgIvQGARGPNBK0CgZ//4AgAoKB0nIoQESBl7v9CoGgMCELUEIJlFgwHSkFGDwAAABARICXf/70ErQEQESCl4v8QESAl3v/NBBCxIFClIIGP/+AIAEoiSmY3trqRzf9whsAamZgJlziPhur/AAwIgkVsgcb/EIiAoigAgcf/4AgAVtr+gcH/ogVsGoiyKAAQESDlmgD36hkMOHCIYguIgIBggIB0jJh6hKJIABt3xu7/AHzoh5q1ZkcTciUaN7cNcIZiC4iAgGCAgHRWqPhxrf+9BXpxrQeBbv/gCAAQESBl1P+tBxwLEBEg5df/EBEgZdP/DBoQESDl4/8d8AAA/T9PSEFJACz+P2yAAkBIPAFAKIICQAgACGAQgAJADAAAYDhAQD8AEAAAAAABABAnAAAogUA/BCz+PxQs/j8AQAAAfJBAP4CQQD+EkEA/eJBAP1AA/T9UAP0/YCz+PxQAAGDw//8AACz+P1gA/T9wgP0/XPIAQIjYAEDQ8QBApPEAQNQyAUBYMgFAoOQAQARwAUAAdQFAgEkBQOg1AUDsOwFAgAABQJggAUDscAFAbHEBQAxxAUCEKQFAADAAQGgAAUA2wQCBz/8MCoJhCoHp/+AIABARIGW4/xYaBXHo/mHm/sAgAIgHkeb+iQbAIACICaHh/okKfPqi2vSgiBCipACgiCDAIACJCaKgZIHa/+AIAJgGfMiQiBAMKZCIIMAgAIkHxgEAqQhLiAYCAACBtP+Rtf8MCpc47BARIKW+/wxLosEoEBEgJcL/EBEgpb3/EBEg5cr/gcf9McP9kav/wCAAOQiBrP2ZCBARICWv/xY6BnEr/sEr/qgHDCuBLf7gCAAMnDwLDAqBvP/gCACxoP8MDAyagbr/4AgAoqIAgSX/4AgAsZv/qAeBtv/gCACoB4Ed/+AIAKgHgbP/4AgAkZX/DBrAIACICaCIIMAgAIkJRgoAAACxkf8MDAxagaj/4AgAkY7/oqEBwCAAiAmgiCDAIACJCSwKgQ7/4AgAgaP/4AgAgYf/wCAAiAjMuhzJkIgQgsj4DBmAqYMMC4Gc/+AIANGA/8GB/3z/DBvw8PXioQCAuwEMCoGW/+AIAIKhjEHX/YLYf4ozItQrBhUAwCAAggoAgIB0FrgEwCAAkkoAoqIAgfH+4AgAoXH/gYL/4AgAgYj/4AgAkW7/fOrAIACICaCIEHz6wCAAiQkQqgGBgv/gCACBgv/gCAAMCoGB/+AIAKHg/cAgAJgDFvn5DAnAIABoAwwYwCAAmQOCQRyCBgEMKpmBgkEdolEPHDmXGCMcSZcYJGaYJoIGA5IGAoCIEZCIIGZIF4gmwCAAiAiJgcYCAAAcKIYAAAAMyIJRDxARICWi/wyLosEcEBEgpaX/ggYDkgYCgIgRkIggHAmS2UCHuRqioMAQESCloP+ioO4QESAloP8QESClnv+GewGSBgEcSpc6NfYpGQb2AJLJL5CQdLZJAoYkAKE2/6CZoJgJoAkAksn+kJB0HCqXugLG7AChMf+gmaCYCaAJAKLJMKCgdLZaxgbnACxJDAVyoMCXGAJG5wBZgQx3DAoQESBlmf8MChARIOWY/xARIGWX/xARICWX/wyLosEccsf/EBEgZZr/Vif9xswA/DjCwRAMCwwKgTT/4AgAjBqGCAAMy6LBEBARICWY/wauAAwXVvgyicGBLf/gCACIwUYsACaIBAwXhsYAWCZ4NnCFIICAtFbY/hARICVp/3pVnAoG+P+grEGBIv/gCABWigRy1/CMd3ClwKCA9FZY/oH7/sYEAHClwKCg9YEa/+AIAOyqgfb+gHfAdzjohgQAAABwpcCgrEGBEv/gCADcSnLX8Fa3/gwIBgMAPFjGAQA8aIYAAAA8eAwXgHiDhqUAZogCRpsAxnwAZrgCBpkAhnoADBcmuAIGnwC4NqgmEBEgpY7/DAigeIOGmgB8uZCYEAwFcqDAJrkCRpsAod3+mEZyoMKXugLGlwAcSagmuFYMDJeYAchmEBEgZWH/fQoGjQB8uZCYEAwFcqDAJrkCxo0AmEahz/5yoMKXugJGigC4NqgmsFmCHEm4VgwMl5gByGYQESDlXf+BHv0MCZlogtgrfQpZKEZ7AJEa/QwFogkAcqDGFiofqCaCyPByoMCHmgF4WQwJoqDvRgIAmrayCxgbmbCqMIcp8oIGBZIGBICIEZCIIJIGBgwFAJkRgJkgggYHgIgBkIgghxoCxmkAxmkAgQT9DAWSCAByoMYWmRmYOHKgyFYZGXhYkkgARmIAHIkMBQwXlxgCRl8A+HboZthWyEa4NqgmgbP+4AgADAhdCqB4g0ZYAAwXJkgChlEAwZn+fPvAIACIDJGQ/rLbkLCIEJCIIKgmwCAAiQzBk/7AIACIDLCIEJCIIMAgAIkMwY/+wCAAiAywiBCQiCDAIACJDMGL/sAgAIgMsIgQkIggwCAAiQwMC4GW/uAIAEYaAICQNAwFcqDAVtkOgIRBi3bGCwCoN4nBgYj+4AgAmCeoF7gHiMGgqRAmCQ3AIADIC8CZEMCZMJCqIMAgAKkLG1VyxxCHNcxGHgAmSHYMBXKgwAYpAAwXJrgCRiIAgW7+qFaYJqkIgW3+mQgMB4YdANFp/uLI8MgNzKwMBXKgxpy+Rh0AAACRZf5SoACSKQByoMnnOWSAgBRyoMBWuAWBX/4MCpgIDAvGAgC6pvhquqz5Cku7DBrnO/CMerCZwJkIuoyJDQwFDAeGCwAMF2aIFqFS/pKgyIgKgImTDAmZCqFN/oB5g5kKDAVGAwAMBXKg/0YBAAAAAHKgwXCgdBARIKVf/1CgdBARICVf/xARIKVd/1bnHYIGARwphzkg9jgCBnQAgsj9gIB0DPmHuQKGcACRO/6QiKCICKAIAAAAkqDSlxhTkqDUlxhfhmkAeDZoJhARIOVM/1aaGaEm/oE3/uAIAIEv/pEw/sAgAIIoAKKgAIC0NcCIEZCIEIC7IHC7gmC7woE9/uAIAKKj6IEr/uAIAEZXAAAA2FbIRrg2qCYQESDla/+GUgAAsgYDggYCgLsRgLsgssvwosYYEBEgJTX/hksAALIGA4IGAoC7EYC7ILLL8KLGGBARIOU5/4ZEAAByBgOCBgKAdxGAdyCINHLH8Mw4DEh3OAtRDP5ixhgMGIYhAACCoMnGJADoBYFV/Kgi4IjAiUF5kYKgA6c3AQwYidHpwRARICUU/4jR6MHR//2h//29BokBwsEk8sEQgQ/+4AgAuCKNCqiRkfj9oLvAuSKgd8C4BapmqEHA+ECqu7kFwMVBkLvAjJjS24AMGtCskxZKAaHt/YJhDBARIKUv/4Hq/YJlAIIhDIynuDQMCoxLh6oCRtz/1ngAgqDHiVSGEwBWuASINBZoBIKgyAb7/wCIJvyoEBEgpVD/oc39gd794AgAEBEg5Tf/ge394AgARgcAAAB4NpxnEBEgZU7/oqPogdX94AgAEBEgpTX/4AcAEBEg5Uz/hlr+EBEgpTT/HfAANkEAoqDAmAONAqeSDgwYrBkMCIkDfOLGDgAAACYZCSYpFnzyhgsAAACSoNuAIiOXmCMMKIkDBvr/kqDcl5IJDBiJAyKgwAYDAJKg3ZeS0gwYiQMioNsd8A==",
                    "text_start": 1073905664,
                    "data": "WAD9P/KLAkCHjAJAK5ECQCeNAkCqjAJAJ40CQICNAkCDjgJA+Y4CQJ6OAkB9iwJAL44CQHiOAkCejQJAGo8CQMaNAkAajwJAfowCQOCMAkAnjQJAgI0CQJCMAkC+iwJA9I8CQOKQAkAikQJABpECQCKRAkAikQJAIpECQCKRAkAikQJAIpECQCKRAkAikQJAe48CQCKRAkAQkAJA4pACQA==",
                    "data_start": 1073622016,
                    "bss_start": 1073545216
                }
            },
            "esp32s3": {
                "mac_efuse_reg": 0x60007044,
                "magic_value": 0x00000009,
                "stub":
                {
                    "entry": 1077382292,
                    "text": "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",
                    "text_start": 1077379072,
                    "data": "WADKP2qQN0A/kTdA1ZU3QN+RN0BikTdA35E3QDiSN0A/kzdAtZM3QFqTN0D1jzdA55I3QDSTN0BWkjdA1pM3QH6SN0DWkzdANpE3QJiRN0DfkTdAOJI3QEiRN0A2kDdArJQ3QJqVN0DMlTdAtpU3QMyVN0DMlTdAzJU3QMyVN0DMlTdAzJU3QMyVN0DMlTdAM5Q3QMyVN0DIlDdAmpU3QAQInwAAAAAAAAAYAQQIBQAAAAAAAAAIAQQIBgAAAAAAAAAAAQQIIQAAAAAAIAAAEQQI3AAAAAAAIAAAEQQIDAAAAAAAIAAAAQQIEgAAAAAAIAAAESAoDAAQAQAA",
                    "data_start": 1070279676,
                    "bss_start": 1070202880
                }
            },
            "esp32c2": {
                "mac_efuse_reg": 0x60008840,
                "stub":
                {
                    "entry": 1077413350,
                    "text": "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",
                    "text_start": 1077411840,
                    "data": "DEDKP+IIOEBICThA3Ak4QLAKOEAYCzhAxgo4QNAHOEBsCjhArAo4QPgJOECABzhAIAo4QIAHOEDACDhACAk4QEgJOEDcCThA0gg4QP4HOEAyCDhAzgg4QAoNOEBICThA1As4QM4MOEBcBzhA8Aw4QFwHOEBcBzhAXAc4QFwHOEBcBzhAXAc4QFwHOEBcBzhAegs4QFwHOEDsCzhAzgw4QA==",
                    "data_start": 1070295980,
                    "bss_start": 1070219264
                }
            },
            "esp32c3": {
                "mac_efuse_reg": 0x60008844,
                "magic_value": [0x6921506F, 0x1B31506F, 0x4881606F, 0x4361606F],
                "stub":
                {
                    "entry": 1077413582,
                    "text": "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",
                    "text_start": 1077411840,
                    "data": "FEDIP5IKOED8CjhAjgs4QGIMOEDKDDhAeAw4QGwJOEAeDDhAXgw4QKoLOEAcCThA0gs4QBwJOEBwCjhAugo4QPwKOECOCzhAggo4QJQJOEDgCThAfgo4QMQOOED8CjhAhg04QIAOOEDaCDhApg44QNoIOEDaCDhA2gg4QNoIOEDaCDhA2gg4QNoIOEDaCDhALA04QNoIOECeDThAgA44QA==",
                    "data_start": 1070164916,
                    "bss_start": 1070088192
                }
            },
            "esp32c5": {
                "mac_efuse_reg": 0x600B4844,
                "stub":
                {
                    "entry": 1082133122,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "FACEQOYOgEBQD4BA5A+AQLgQgEAgEYBAzhCAQEANgEB0EIBAtBCAQAAQgEDwDIBAKBCAQPAMgEDCDoBADg+AQFAPgEDkD4BA1A6AQGgNgECWDYBA0A6AQBoTgEBQD4BA3BGAQNYSgECqDIBA/BKAQKoMgECqDIBAqgyAQKoMgECqDIBAqgyAQKoMgECqDIBAghGAQKoMgED0EYBA1hKAQA==",
                    "data_start": 1082469300,
                    "bss_start": 1082392576
                }
            },
            "esp32c6": {
                "mac_efuse_reg": 0x600B0844,
                "magic_value": 0x2CE0806F,
                "stub":
                {
                    "entry": 1082132158,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "EACEQD4KgECoCoBANguAQAoMgEByDIBAIAyAQDAJgEDGC4BABgyAQFILgEDgCIBAeguAQOAIgEAcCoBAZgqAQKgKgEA2C4BALgqAQFgJgECMCYBAKgqAQGwOgECoCoBALg2AQCgOgECeCIBATg6AQJ4IgECeCIBAngiAQJ4IgECeCIBAngiAQJ4IgECeCIBA1AyAQJ4IgEBGDYBAKA6AQA==",
                    "data_start": 1082469296,
                    "bss_start": 1082392576
                }
            },
            "esp32c61": {
                "mac_efuse_reg": 0x600B4844,
                "stub":
                {
                    "entry": 1082132158,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "EECAQEIKgECsCoBAOguAQA4MgEB2DIBAJAyAQDQJgEDKC4BACgyAQFYLgEDkCIBAfguAQOQIgEAgCoBAagqAQKwKgEA6C4BAMgqAQFwJgECQCYBALgqAQHAOgECsCoBAMg2AQCwOgECiCIBAUg6AQKIIgECiCIBAogiAQKIIgECiCIBAogiAQKIIgECiCIBA2AyAQKIIgEBKDYBALA6AQA==",
                    "data_start": 1082223536,
                    "bss_start": 1082146816
                }
            },
            "esp32h2": {
                "stub":
                {
                    "entry": 1082132158,
                    "text": "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",
                    "text_start": 1082130432,
                    "data": "EACDQD4KgECoCoBANguAQAoMgEByDIBAIAyAQDAJgEDGC4BABgyAQFILgEDgCIBAeguAQOAIgEAcCoBAZgqAQKgKgEA2C4BALgqAQFgJgECMCYBAKgqAQGwOgECoCoBALg2AQCgOgECeCIBATg6AQJ4IgECeCIBAngiAQJ4IgECeCIBAngiAQJ4IgECeCIBA1AyAQJ4IgEBGDYBAKA6AQA==",
                    "data_start": 1082403760,
                    "bss_start": 1082327040
                }
            },
            "esp32p4": {
                "mac_efuse_reg": 0x5012D044,
                "stub":
                {
                    "entry": 1341459336,
                    "text": "QRG3Jw1QIsQmwkrAEUcGxrcE9k/Yyz6JM4TnAJOEBAAcQJGLmeeyQCJEkkQCSUEBgoADJQkAnEATdfUPgpfNtwERt6cMUE7Gg6mHAErINwn2TybKUsQGziLMk4THAT6KEwkJAIBAE3T0PxnIAyUKAIMnCQB9FBN19Q+Cl2X43bfyQGJEt6cMUCOoNwHSREJJskkiSgVhgoCTBwAMkEEqh2MY9QCFRwXGI6AFAHlVgoCFRmMH1gAJRWMNpgB9VYKAQgWTB7ANQYVjE/cCiUecwfW3EwbADWMVxwCUwT6FgoCTB9AN4xz3/JTBEwWwDYKAtzX3T0ERk4VFvwbGcT9jTQUEtzf3T5OHx7YDpwcIg9ZHCBOGFgAjkscINpcjAKcAA9dHCJFnk4cHBGMa9wI3t/ZPEwfHtqFnupcDpgcIt/b2T5OGxrpjH+YAI6bHCCOg1wgjkgcIIaD5V+MK9fyyQEEBgoAjptcII6DnCN23N9cIUBMHRwUcQ52L9f83xwhQEwdHBRxDnYv1/4KAQREGxvk/N9cIULcGAAgjJgcCkwfHAhTDFEP9/ohDskATRfX/BYlBAYKAQREGxsk/fd231whQNwcAQJjDmEN9/7JAQQGCgDlxItwm2krYUtRW0gbeTtaqhC6JMoRBSpcAy//ngODyhUpjS4AA8lBiVNJUQlmyWSJaklohYYKAooljU4oAwUmTlzkAIUg+xErCJocCyFbGAsCBSJMHAALChjFGkUUFRZcAzP/ngCB7MwQ0QU6ZzpRNvzlxItwm2krYUtRW0gbeTtaqhC6JMoSTCgAClwDL/+eAoOsFSmNLgADyUGJU0lRCWbJZIlqSWiFhgoAlP6KJY9SKAJMJAAKTlzkAyogmhz7AAUiTBwACoUZJRpFFBUVSyFLGAsQCwpcAzP/ngKBzlwDL/+eAYOZOmc6UMwQ0QV23eXEi1DeE9k8TBMQFStADKQQBBtYm0mMCCQp9NVnNvUeBRGPWJwEERP2Mk7QUANE1rT23B/ZPg8dHAMHPlwDL/+eAgOF9NRhEBUUqyCrGAsQCwgLAMge3BwABgUgBSIXIY1H3AuFHoUYTBoANlUWXAMz/54Aga5cAy//ngODdQUc9oJMHAAKhRhMGwA3Ft2Nc9wLhR6FGEwYAApVFlwDM/+eAQGiXAMv/54AA2wVHHEiZjxzIHES6lxzEslAiVJJUAllFYYKAkwcAAqFGEwYQAum3HEQ3BwABuoayB5nAtwaAAH0X+Y831whQXMMUwxxD/f/N3Gm3AREGziLMJsrxV2OS9QQ3BPZPtwT8TxMEBAADpUT9lwDL/+eAwE9jR6AA8kBiRNJEBWGCgAOlRP0FRmwAlwDL/+eAIE4cQANFwQCCl/m3/VfjnfX8cACJRQLGlwDL/+eAQE8yR7cH9k+ThwcAGeeURwVGY5TGACOG1wCYx323AREGzg07NwX0T2wAMRWXAMv/54Bg1KqHBUWd57JHk/cHID7GqTu31whQmEe3BkAANwX0T1WPmMeyRTEVlwDL/+eAwNEzNaAA8kAFYYKAQRG3h/ZPBsaTh8cFBUcjgOcAE9fFAJjHBWd9F8zDyMf5jTqVqpWxgQ1njMsjqgcAMzbAALqXI4bHsKU/GcETBVAMskBBAYKAWXGi1DeE9k+m0s7OLtaG1srQ0szWytrI3sbixObC6sBu3qqJEwTEBZcAy//ngODCslVERGPzlQCuhGOCBBwDKUQAJpkTWckAHEhjVfAAHERjX/kGrTF93bcH9k+Dx0cAAylEAGOFBxiz5yQBvYvF65cAy//ngGC+t8cIUCOiBzSXAMv/54DgwCaKUeU3ywhQt8sIUDfMCFC3zAhQkw3wAxMLCzSTiwswEwyMNJOMzDSFShN1+QMR7RMNAARj700B/Uczs0cBEx1DAEENOaAlM6W/k3f5AUFN5deTV11AIyD7AGqGzoVelZcAy//ngGDLIyAsASOgXAHFPrfGCFBhZ4FHk4aGNQlGEwcHaoxCY47FAGOa5wCXAMv/54BAtJMHQAxcyGmohQfVt+OG5/4+1pcAy//ngKCxN8cIULJXIyhXNZMGhzVhZw1GEwcHaoxCY4bFAOOB5/yFB9W/443n+pcAy//ngKCuIeWTFz0A/Rc+wEqHkwcAAlbIVsYCxALCgUgBSKFGSUaRRQVFlwDM/+eAoDi3xwhQI6pXNTMKqkHqmWqZ4xcK8JcAy//ngCCqKtaXAMv/54CAqjJVLfFcQLZQBlmml1zAXET2SWZKhY9cxCZUllTWSkZLtksmTJZMBk3yXWVhFwPL/2cAQ6cmhs6FSoWXAMv/54CgpcG3tlAmVJZUBln2SWZK1kpGS7ZLJkyWTAZN8l1lYYKAAREizDeE9k8TBMQFjWeil4PHx7AGzibKSshOxlLEVsJawJnLYkTyQNJEQkmySSJKkkoCSwVhfbNERGPzlQCuhKXAAylEACqKJpkTWckAHEhjVfAAHERjX/kEoTR93bcH9k+Dx0cAgypEANnDk/n6DxMJABAzCTlBlwDL/+eAYJtj/CQDJobShVaFwTyXAMv/54AgmlxAppdcwFxEhY9cxPJAYkTSREJJskkiSpJKAksFYYKAHTZhv5OJCfBKhtKFVoWmmVk8k9mJAAFLMwVZAbMFKgFjZTsBM4YkQX23EwYAEAULnTwTCQkQE3v7D/m/JobShVaFlwDL/+eAQJcTdfUPSdmTB0AMXMhpt0ERBsaXAMv/54CgiwNFhQGyQGkVEzUVAEEBgoBBEQbGlwDL/+eA4IkDRYUBskBtFRM1FQBBAYKAQREixDcE9k8TBAQAtwf8TxBIA6VH/ZMFRAEGxpcAy//ngGAIskAjKAQAIkRBAYKAQREixAbGKoR1NxXFtwf2T5OHBwCYS5MGFwCUy7qXI4qHABMEBPQBxBMHF/wF4yJEskBBAXG/jTcRzTcnDVARBxxDiYv137cnDVCAw7JAIkRBAYKAIoUiRLJAQQEX88r/ZwDjeUERBsYTBwAMYxrlABMFsA1xNxMFwA2yQEEBSbcTB7AN4xvl/qU/EwXQDfW3QREixCbCBsYqhLMEtQBjF5QAskAiRJJEQQGCgANFBAAFBE0/7bd1cSLFJsPO3tLc1toGx0rBEwEBgBMBAYCqhDcK9k8oCC6EhWqXAMv/54CAyhMKCgCTCQEHFeQoACwIlwDL/+eAoMkoAMFFUT8BRYViFpG6QCpEmkQKSfZZZlrWWklhgoAiiWPzigAFaYNHSgBKhs6FJoWRz+/wv4RKhs6FKAiXAMv/54AgxcqUMwQkQWW3l/DK/+eAYHsTdfUPed0TBTAGbbcTBQAMVbVBEQbGiT0BybcH9k+ThwcAnEuRw7k9FTUBybJAtycNUAVH2MNBAYKAskBBARfzyv9nAMNoNXEizU7HUsVaweLcBs8my0rJVsPe3hMBAYATAQGAgBiqiS6KMos2jCMqBPjdOznBNwUCAJcAy//ngAC7twf8TwOlR/2XAMv/54AA7IVnY+9nESgItwr2T5cAy//ngIC5AUmTigoAgytE+WNmeQ1j6ksF0aBJO5MHAAIZwbcHAgA+hZcAy//ngCC2ybezBCpBY3ObANqEg8dKACaGooVOhYXL7/AP9AU3poUihYk9IT8mhqKFKAiXAMv/54Dgs6aZJpljfkkBswd5QePhh/0BqJfwyv/ngIBpE3X1D2nV/TWBRCMsBPj5W6MJBPgTBTEAl/DK/+eAAFh1+QNFNPksAO/wj9qTFwUBY8IHApO3RACRz4Vnk4cHB6aXipeThweAk4cHgCOKp/iFBH2/4x51+5FH44r08igALAiXAMv/54Dgq1E1wUUoAF07tT3ZOQ3Ntwf8TwOlR/2XAMv/54CA2jcFAgCXAMv/54BAqIViFpH6QGpE2kRKSbpJKkqaSgpL9ltmXA1hgoC9OZMHAAIZwbcHAgA+hfm3t1dBSTVxk4f3hAFFBs8izSbLSslOx1LFVsNawd7e4tzm2urY7tY+3pfwyv/ngEBRPTkFxTdH2FC3ZxFQEwcXqpjPI6AHACOsBwCY09RPNwYEANGO1M8joAcCtwf2Tzc390+ThwcAEwfHvyGgI6AHAJEH4+3n/mU7kUVoGO0xRTtVO7e39k+Th8e2oWq+miOg+gi3CfZPtwf1T5OJCQCThwcPI6D5ANU2YwMFGjcE/E8DJUT9E4aJAIlFlwDL/+eAYMy3Vw5Qk4fHFZhDtwYgAIVFVY+Yw7dnDVATBxACI6rnFkVFlwDL/+eAAJS3FcBPAUaThUWXRUWXAMv/54AAlTcFAgCXAMv/54DAlAMlRP23BfVPk4WlO5cAy//ngADGAyVE/ZcAy//ngEDEAyVE/ZcAy//ngMDCtwcAUJhHE2cXAJjHtwcOUIhfgUU3ivZPcYlhFRM1FQCX8Mr/54CAUOFHBUU+xPwAKsY+woFIAUiBRwFHoUYTBvAJkUUCyALAlwDM/+eAwM2DR+EEQWaFZhOHd/6Tt5cDEzd3AZO3FwDZjyOC+QATBwAQkwf2/7cFAAQBRTcMEVATCsoFDWuX8Mr/54AgQiEMUpuDp8oIY4UHDoOkygiFRyOmCggjAvEEg8cUAAlHIxPhBKMC8QSCxE1HY4/nEFFHY43nEClHY57nAIPHNAADxyQAogfZjxFHY5XnAJxEnEO+xBE5oUXIAJk2g8Y0AIPHJACiBt2OkWfBB2Pz1w4TBbANcTwTBcANWTwTBeAOQTzdNu02vb8FNCnBt2cNUBMHEAK4z4VFRUWX8Mr/54BAfLcF9U8BRpOFBQBFRZfwyv/ngEB9tycNUBFHmMs3BQIAl/DK/+eAgHxVvbcF9U8BRpOFBQQVRZfwyv/ngKB6t6cMUNhHEwUAAhNnFxDYx8m/g8fJAOOHB/A3BQIAI4YJAJfwyv/ngEB4CWUTBQVxl/DK/+eA4B2XAMv/54BgtoMnDAA3BQCA7ZsjIPwAlwDL/+eAgKqXAMv/54DArgFFl/DK/+eAoCB1vclHIxPxBBG3g8cUAFFHY2f3AgVHY2b3AAFJEwTwD9mk+ReT9/cPSUfjaPf+Nzf3T4oHEwcHwLqXnEOChxOHBwMTd/cPEUbjaeb8k4f3ApP39w8NR2Ng9wY3N/dPigcTB8fEupecQ4KHkwdAAmOT9hqCxB1EAUXv8B+VAUV9MkU0eTyhRcgAfRT5Mm30AUkBRJGsierwAIFFAUWX8Mr/54CgGAHFBUQBSTWs0UXoAGUyAUTVvwVE5fqX8Mr/54DAHTM0oADNt6FH4572/AOphADARLNniQDSB/H37/BvzHnxIpmFTBnEMweJQJMXBwHBg6nvQW2FTMF9Y2eNCoVMTcCDx0kAMweJQGOKBw461u/wD6GX8Mr/54DgFjJXZshmxgLEAsICwIFIAUiTBwACoUYTBhAClUUFRZcAzP/ngEChEwQEgBMEBIBdv4PHSQChwzrW7/DPnJfwyv/ngKASMldmyGbGAsQCwgLAgUgBSJMHAAKhRhMGEAKVRQVFlwDM/+eAAJ0TBASAEwQEgKG/E1XHAJfwyv/ngCASbdUTBFADMzSAAAm3g8dJADMHiUCNzzrW7/DPlpfwyv/ngKAMMldmyGbGAsQCwgLAgUgBSJMHAAKhRhMGwA2VRQVFlwDM/+eAAJdulAm/E1UHAZfwyv/ngMAMZdkTBGADXbcTVccAl/DK/+eAQAsF3Um/oUfjj/bmAUkTBAAM8aDBR82/wUcFROOS9ujMRIhE7/A/hUm9k/e2/0FH457n/JhIkWdj7Ock0UeIRMxIAUZjk/YAkEzv8O+5KoSBvZP3tv9BR+Oa5/qcSBFnY2j3IthEiETMSDOJ5wLRRwFGY5P2AJBM7/APt7eH9k+Th8cFDWcjrAcAupcqhCOkJ7E5tbeH9k+Th8cFA8cHAGMHBxiYRMEWEwQADGMT1wDAS4FHEwbwDmPF1waDx1QAA8dEAAFJogfZjwPHZABCB12Pg8d0AOIH2Y9jH/YaE3X0D+/wL/QTdfkP7/Cv8+/wv4LjEQTEg8cUAElHY2n3GglH43n3wvUXk/f3Dz1H42P3wjc390+KBxMHx8W6l5xDgoczh/QAA0eHAYUHOY5pt7eH9k+Th8cFA8cHAG3L2EdjHwcUwEsjgAcAmbvhR2OQ9gLcTJhM1EiQSMxEiESX8Mr/54DA9iqJMzSgAI2/AUkFRLW3kUcFROOU9tK3Fg5Q+F7ld/0XBWZ9j1GPiET43rcWDlCThgYImEKBRX2PUY+YwrcWDlCThkYImEJ9j1GPmMK3Fg5QuF75j9GPvN6X8Mr/54DA+NWxk/f2AOOQB+ST3EYAE4SEAAFJfV3jdZnLSESX8Mr/54DA2xxEWEAQQH2PY4enARRCk8f3//WPXY8YwgUJQQTZv5FH/bvBRwVE45j2yJxE2EgjrPkEI6rpBGmxA6dJBROGBv8R5wHOAUkTBGAMbbWDp4kFY+bHBo2K45YG3IOmiQWBRYFHY+vHAOOLBcKdjj6XI6zZBCOq6QQdsbOF9ACITbMF9wCRB4jBhUXpv6FHBUTjlPbCA6SJBRnAEwSADCOsCQQjqgkEMbMBSRMEIAyhtRMEEAyJtQFJEwSADC29AUkTBJAMDb0TByANY4znBhMHQA3jneemg8U0AIPHJAAThYQBogXdjcEV7/APloW0A6nEAIBE7/CPyeMaBaQJZRMFBXGX8Mr/54BAy7enDFDcSzcHAAFBF5PVRwGSB/mPvYndjbOFJQMBRbPVhQKX8Mr/54CgzBMFgD6X8Mr/54DgxzG01EiQSMxEiETv8A/i/bqDxTQAg8ckABOFhAGiBd2NwRXv8C+w3bKDxzQAA8ckAKIH2Y+TjQf/gyfKAIHnk7ddAJ3Ltzj3TzeJ9k83DfZP4QQFRJOLyL8TCckFkwzNBWOHDQCDJ8oAmcNjTIAAY1UECJMHcAwZoJMHkAwjKvoAcbIDKIuwg6cLAO7AM7gNAQYIswf5QAUIvsZC1u/gP+YDpwsAMlg3hfZPpoX8AOaGkAATBUUHl/DK/+eAwMeGRwMni7CDpQsAs439QB2PvpS2RyMk67AqhL6VI6C7AOF3s4WVQa6XkcMl/RMFzQXv8G+jI6CbAa234xoEkIMnygDjhgeQkweADJW/nETjkAeQ7/BvzgllEwUFcZfwyv/ngMC1l/DK/+eAwLrNsMBE4w8EjO/wT8wTBYA+l/DK/+eAwLMClOGw+kBqRNpESkm6SSpKmkoKS/ZbZlzWXEZdtl0NYYKAAAA=",
                    "text_start": 1341456384,
                    "data": "XAD2T8gQ9U8yEfVPzhH1T6oS9U8SE/VPwBL1TwAP9U9mEvVPphL1T+oR9U+wDvVPEhL1T7AO9U+kEPVP8BD1TzIR9U/OEfVPthD1TyoP9U9eD/VPshD1TwwV9U8yEfVP1hP1T9AU9U/SDfVP8hT1T9IN9U/SDfVP0g31T9IN9U/SDfVP0g31T9IN9U/SDfVPdBP1T9IN9U/uE/VP0BT1Tw==",
                    "data_start": 1341598716,
                    "bss_start": 1341521920
                }
            },
            "esp32p4rc1": {
                "mac_efuse_reg": 0x5012D044,
                "stub":
                {
                    "entry": 1341197206,
                    "text": "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",
                    "text_start": 1341194240,
                    "data": "XAD1T6wQ8U8WEfFPshHxT44S8U/2EvFPpBLxTwQP8U9KEvFPihLxT84R8U+0DvFP9hHxT7QO8U+IEPFP1BDxTxYR8U+yEfFPmhDxTy4P8U9iD/FPlhDxT/AU8U8WEfFPuhPxT7QU8U/WDfFP1hTxT9YN8U/WDfFP1g3xT9YN8U/WDfFP1g3xT9YN8U/WDfFPWBPxT9YN8U/SE/FPtBTxTw==",
                    "data_start": 1341533180,
                    "bss_start": 1341456384
                }
            }
        }
    }
};

/* CommonJS export for Node.js */
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ChipDescriptions;
}

/* For browser environments, ChipDescriptions is already available globally from this script */


    </script>
    <script>
/* Inlined from flasher.js */
/**
 * ESP32 Bootloader Command Codes
 * Commands for communication with ESP32 ROM bootloader and stub loader
 */
const FLASH_BEGIN = 0x02;
const FLASH_DATA = 0x03;
const FLASH_END = 0x04;
const MEM_BEGIN = 0x05;
const MEM_END = 0x06;
const MEM_DATA = 0x07;
const SYNC = 0x08;
const WRITE_REG = 0x09;
const READ_REG = 0x0a;
const SPI_SET_PARAMS = 0x0b;
const SPI_ATTACH = 0x0d;
const CHANGE_BAUDRATE = 0x0f;
const FLASH_DEFL_BEGIN = 0x10;
const FLASH_DEFL_DATA = 0x11;
const FLASH_DEFL_END = 0x12;
const SPI_FLASH_MD5 = 0x13;
const GET_SECURITY_INFO = 0x14;
const ERASE_FLASH = 0xd0;
const ERASE_REGION = 0xd1;
const READ_FLASH = 0xd2;
const RUN_USER_CODE = 0xd3;

/**
 * IMPORTANT: For browser usage, chips.js must be loaded BEFORE flasher.js
 * 
 * This will make ChipDescriptions available globally for flasher.js to use.
 * For Node.js, flasher.js will automatically require('./chips.js')
 */

/* Resolve ChipDescriptions for both browser and Node environments */
const ChipDescriptionsClass = typeof ChipDescriptions !== 'undefined'
    ? ChipDescriptions
    : (typeof require !== 'undefined' ? require('./chips.js') : null);

/* ESP32 Reset Reason Codes (from ESP-IDF esp_system.h) */
const RESET_REASON_MAP = {
    0: { name: 'NO_MEAN', desc: 'No reset reason' },
    1: { name: 'POWERON_RESET', desc: 'Vbat power on reset' },
    3: { name: 'RTC_SW_SYS_RESET', desc: 'Software reset digital core' },
    5: { name: 'DEEPSLEEP_RESET', desc: 'Deep Sleep reset digital core' },
    7: { name: 'TG0WDT_SYS_RESET', desc: 'Timer Group0 Watch dog reset digital core' },
    8: { name: 'TG1WDT_SYS_RESET', desc: 'Timer Group1 Watch dog reset digital core' },
    9: { name: 'RTCWDT_SYS_RESET', desc: 'RTC Watch dog Reset digital core' },
    10: { name: 'INTRUSION_RESET', desc: 'Intrusion tested to reset CPU' },
    11: { name: 'TG0WDT_CPU_RESET', desc: 'Timer Group0 reset CPU' },
    12: { name: 'RTC_SW_CPU_RESET', desc: 'Software reset CPU' },
    13: { name: 'RTCWDT_CPU_RESET', desc: 'RTC Watch dog Reset CPU' },
    15: { name: 'RTCWDT_BROWN_OUT_RESET', desc: 'Reset when the vdd voltage is not stable' },
    16: { name: 'RTCWDT_RTC_RESET', desc: 'RTC Watch dog reset digital core and rtc module' },
    17: { name: 'TG1WDT_CPU_RESET', desc: 'Timer Group1 reset CPU' },
    18: { name: 'SUPER_WDT_RESET', desc: 'Super watchdog reset digital core and rtc module' },
    19: { name: 'GLITCH_RTC_RESET', desc: 'Glitch reset digital core and rtc module' },
    20: { name: 'EFUSE_RESET', desc: 'eFuse reset digital core' },
    21: { name: 'USB_UART_CHIP_RESET', desc: 'USB UART reset digital core' },
    22: { name: 'USB_JTAG_CHIP_RESET', desc: 'USB JTAG reset digital core' },
    23: { name: 'POWER_GLITCH_RESET', desc: 'Power glitch reset digital core and rtc module' }
};

const CHIP_ID_MAP = {
    0x0000: 'esp32',
    0x0002: 'esp32s2',
    0x0005: 'esp32c3',
    0x0009: 'esp32s3',
    0x000C: 'esp32c2',
    0x000D: 'esp32c6',
    0x0010: 'esp32h2',
    0x0012: 'esp32p4',
    0x0017: 'esp32c5',
    0x0014: 'esp32c61',
    0x0019: 'esp32h21',
    0x001C: 'esp32h4',
    0x0020: 'esp32s31',
    0xFFFF: 'Invalid'
};

/**
 * SLIP Protocol Layer Handler
 * Implements Serial Line IP (RFC 1055) encoding/decoding for packet framing
 */
class SlipLayer {
    /**
     * Initialize SLIP layer with empty buffer
     */
    constructor() {
        this.buffer = [];
        this.escaping = false;
        this.verbose = true;
        this.logPackets = false;
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    /**
     * Log SLIP layer data with color coding
     * @param {Uint8Array} data - Data to log
     * @param {string} type - 'ENCODE' or 'DECODE'
     * @param {string} label - Description label
     */
    logSlipData(data, type, label) {
        if (!this.verbose) return;

        this._preSyncState = 'idle';
        const isEncode = type === 'ENCODE'; const color = isEncode ? 'color: #FFC107; font-weight: bold' : 'color: #9C27B0; font-weight: bold';

        const bgColor = isEncode ? 'background: #F57F17; color: #000' : 'background: #6A1B9A; color: #fff';
        const symbol = isEncode ? '' : '';

        const maxBytes = 128;
        const bytesToShow = Math.min(data.length, maxBytes);
        const truncated = data.length > maxBytes;

        let hexStr = '';
        let asciiStr = '';
        let lines = [];

        for (let i = 0; i < bytesToShow; i++) {
            const byte = data[i];
            hexStr += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
            asciiStr += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';

            if ((i + 1) % 16 === 0 || i === bytesToShow - 1) {
                const hexPadding = ' '.repeat(Math.max(0, (16 - ((i % 16) + 1)) * 3));
                lines.push(`    ${hexStr}${hexPadding} | ${asciiStr}`);
                hexStr = '';
                asciiStr = '';
            }
        }

        if (this.logPackets) {
            const truncMsg = truncated ? ` (showing ${bytesToShow}/${data.length} bytes)` : '';
            this.logDebug(`${symbol} SLIP ${type} ${label} [${data.length} bytes]${truncMsg}`);
            lines.forEach(line => this.logDebug(line));
        }
    }

    /**
     * Encode data using SLIP framing
     * Wraps packet with SLIP_END delimiters and escapes special bytes
     * @param {Uint8Array} packet - Raw packet data
     * @returns {Uint8Array} SLIP-framed packet with delimiters
     */
    encode(packet) {
        const SLIP_END = 0xC0;
        const SLIP_ESC = 0xDB;
        const SLIP_ESC_END = 0xDC;
        const SLIP_ESC_ESC = 0xDD;

        if (this.logPackets) {
            this.logSlipData(packet, 'ENCODE', 'Payload before framing');
        }

        let slipFrame = [SLIP_END];

        for (let byte of packet) {
            if (byte === SLIP_END) {
                slipFrame.push(SLIP_ESC, SLIP_ESC_END);
            } else if (byte === SLIP_ESC) {
                slipFrame.push(SLIP_ESC, SLIP_ESC_ESC);
            } else {
                slipFrame.push(byte);
            }
        }

        slipFrame.push(SLIP_END);
        const result = new Uint8Array(slipFrame);

        return result;
    }

    /**
     * Decode SLIP-framed packet stream
     * Extracts complete packets from framed data, handling escape sequences
     * @param {Uint8Array|ArrayLike} value - SLIP-encoded bytes
     * @returns {Uint8Array[]} Array of decoded complete packets
     */
    decode(value) {
        const SLIP_END = 0xC0;
        const SLIP_ESC = 0xDB;
        const SLIP_ESC_END = 0xDC;
        const SLIP_ESC_ESC = 0xDD;

        let outputPackets = [];

        for (let byte of value) {
            if (byte === SLIP_END) {
                if (this.buffer.length > 0) {
                    const packet = new Uint8Array(this.buffer);
                    outputPackets.push(packet);
                    this.buffer = [];
                }
            } else if (this.escaping) {
                if (byte === SLIP_ESC_END) {
                    this.buffer.push(0xC0);
                } else if (byte === SLIP_ESC_ESC) {
                    this.buffer.push(0xDB);
                }
                this.escaping = false;
            } else if (byte === SLIP_ESC) {
                this.escaping = true;
            } else {
                this.buffer.push(byte);
            }
        }

        if (this.logPackets) {
            // Log decoded packets
            for (let i = 0; i < outputPackets.length; i++) {
                const label = outputPackets.length > 1 ? `Decoded packet ${i + 1}/${outputPackets.length}` : 'Decoded packet';
                this.logSlipData(outputPackets[i], 'DECODE', label);
            }
        }

        return outputPackets;
    }
}

/**
 * WebUSBSerial - Web Serial API-like wrapper for WebUSB
 * Provides a familiar interface for serial communication over USB
 */
class WebUSBSerial {
    constructor() {
        this.device = null;
        this.interfaceNumber = null;
        this.endpointIn = null;
        this.endpointOut = null;
        this.controlInterface = null;
        this.readableStream = null;
        this.writableStream = null;
        this._reader = null;
        this._writer = null;
        this._readLoopRunning = false;
        this._usbDisconnectHandler = null;
        this._eventListeners = {
            'close': [],
            'disconnect': []
        };
        this.logger = null; /* optional {info, error} callbacks for UI logging */
        this.maxTransferSize = 0x10000;
    }

    /**
     * Request USB device (mimics navigator.serial.requestPort())
     * @returns {Promise<WebUSBSerial>} This instance
     */
    static async requestPort() {
        const filters = [
            { vendorId: 0x303A }, // Espressif
            { vendorId: 0x0403 }, // FTDI
            { vendorId: 0x1A86 }, // CH340
            { vendorId: 0x10C4 }, // CP210x
            { vendorId: 0x067B }  // PL2303
        ];

        const device = await navigator.usb.requestDevice({ filters });
        const port = new WebUSBSerial();
        port.device = device;
        return port;
    }

    /**
     * Open the USB device (mimics port.open())
     * @param {Object} options - {baudRate: number}
     * @returns {Promise<void>}
     */
    async open(options = {}) {
        if (!this.device) {
            throw new Error('No device selected');
        }

        /* If already open (e.g., prior attempt), close to avoid stale claims */
        if (this.device.opened) {
            try { await this.device.close(); } catch (e) { }
        }

        /* Best-effort reset before attempting to open (helps if host kept a stale claim) */
        try { if (this.device.reset) { await this.device.reset(); } } catch (e) { }

        const attemptOpenAndClaim = async () => {
            await this.device.open();
            try {
                /* Ensure configuration 1 is selected; some hosts keep a different active config */
                const currentCfg = this.device.configuration ? this.device.configuration.configurationValue : null;
                if (!currentCfg || currentCfg !== 1) {
                    await this.device.selectConfiguration(1);
                }
            } catch (e) { /* ignore config select errors */ }

            const config = this.device.configuration;

            /* Try to claim CDC control interface FIRST on Android/CH34x to unblock data iface claim */
            const preControlIface = config.interfaces.find(i => i.alternates && i.alternates[0] && i.alternates[0].interfaceClass === 0x02);
            if (preControlIface) {
                try {
                    await this.device.claimInterface(preControlIface.interfaceNumber);
                    /* Ensure alt setting 0 is active */
                    try { await this.device.selectAlternateInterface(preControlIface.interfaceNumber, 0); } catch (e) { }
                    this.controlInterface = preControlIface.interfaceNumber;
                    this.logMessage(`[WebUSB] Pre-claimed CDC control iface ${preControlIface.interfaceNumber}`);
                } catch (e) {
                    this.logError(`[WebUSB] Could not pre-claim CDC control iface ${preControlIface.interfaceNumber}: ${e && e.message ? e.message : e}`);
                }
            }

            /* Collect all bulk IN/OUT interfaces and try preferred ones first (CDC > vendor > other)
               Rationale: Espressif composite devices expose CDC data on iface 1 (class 0x0A) and JTAG/debug on vendor iface 2.
               Selecting CDC first avoids landing on a non-UART function that won't speak the ROM bootloader. */
            const candidates = [];
            for (const iface of config.interfaces) {
                const alt = iface.alternates[0];
                let hasIn = false, hasOut = false;
                for (const ep of alt.endpoints) {
                    if (ep.type === 'bulk' && ep.direction === 'in') hasIn = true;
                    if (ep.type === 'bulk' && ep.direction === 'out') hasOut = true;
                }
                if (hasIn && hasOut) {
                    let score = 2; /* default */
                    if (alt.interfaceClass === 0x0a) score = 0; /* CDC data first */
                    else if (alt.interfaceClass === 0xff) score = 1; /* vendor-specific next */
                    candidates.push({ iface, score });
                }
            }

            if (!candidates.length) {
                await this._dumpDeviceDetails('No suitable USB interface found');
                throw new Error('No suitable USB interface found');
            }

            candidates.sort((a, b) => a.score - b.score);
            let lastErr = null;
            for (const cand of candidates) {
                try {
                    /* Ensure alt setting 0 before claiming */
                    try { await this.device.selectAlternateInterface(cand.iface.interfaceNumber, 0); } catch (e) { }
                    await this.device.claimInterface(cand.iface.interfaceNumber);
                    this.interfaceNumber = cand.iface.interfaceNumber;

                    /* Get endpoints */
                    const alt = cand.iface.alternates[0];
                    for (const ep of alt.endpoints) {
                        if (ep.type === 'bulk' && ep.direction === 'in') {
                            this.endpointIn = ep.endpointNumber;
                        } else if (ep.type === 'bulk' && ep.direction === 'out') {
                            this.endpointOut = ep.endpointNumber;
                        }
                    }
                    /* Adopt endpoint packet size as transfer length (Android prefers max-packet) */
                    try {
                        const inEp = alt.endpoints.find(ep => ep.type === 'bulk' && ep.direction === 'in');
                        if (inEp && inEp.packetSize) {
                            this.maxTransferSize = Math.min(inEp.packetSize, 64);
                        }
                    } catch (e) { }
                    this.logMessage(`[WebUSB] Claimed iface ${cand.iface.interfaceNumber} (class=${alt.interfaceClass}) with IN=${this.endpointIn} OUT=${this.endpointOut}`);
                    return config;
                } catch (claimErr) {
                    lastErr = claimErr;
                    this.logError(`[WebUSB] claim failed on iface ${cand.iface.interfaceNumber} (class=${cand.iface.alternates[0].interfaceClass}): ${claimErr && claimErr.message ? claimErr.message : claimErr}`);
                }
            }

            await this._dumpDeviceDetails('All candidate interfaces failed to claim', lastErr);
            this.logMessage('[WebUSB] If you are on Windows and see repeat claim failures, ensure the interface is bound to WinUSB (e.g., via Zadig) and close any app using it.');
            throw lastErr || new Error('Unable to claim any USB interface');
        };

        let config;
        try {
            config = await attemptOpenAndClaim();
        } catch (err) {
            console.warn('[WebUSBSerial-flasher] open/claim failed:', err.message);
            await this._dumpDeviceDetails('open/claim failed (first attempt)', err);
            /* Retry once after a best-effort device reset/close to clear stale claims (common on Android) */
            console.warn('[WebUSBSerial-flasher] claimInterface failed, retrying after reset/close:', err.message);
            try { if (this.device.reset) { await this.device.reset(); } } catch (e) { }
            try { await this.device.close(); } catch (e) { }
            try {
                config = await attemptOpenAndClaim();
            } catch (err2) {
                await this._dumpDeviceDetails('claimInterface failed (retry)', err2);
                throw new Error(`Unable to claim USB interface. This can happen if another app has the device open or Android retained a stale claim. Unplug/replug the device, close other apps, and retry. Original: ${err2.message}`);
            }
        }

        /* Control iface may already be claimed in attemptOpenAndClaim; avoid double-claim */
        if (this.controlInterface == null) {
            const controlIface = config.interfaces.find(i =>
                i.alternates[0].interfaceClass === 0x02 &&
                i.interfaceNumber !== this.interfaceNumber
            );

            if (controlIface) {
                try {
                    await this.device.claimInterface(controlIface.interfaceNumber);
                    try { await this.device.selectAlternateInterface(controlIface.interfaceNumber, 0); } catch (e) { }
                    this.controlInterface = controlIface.interfaceNumber;
                } catch (e) {
                    /* Use data interface for control if claim fails */
                    this.controlInterface = this.interfaceNumber;
                }
            } else {
                this.controlInterface = this.interfaceNumber;
            }
        }

        // Set line coding
        const baudRate = options.baudRate || 115200;
        try {
            const lineCoding = new Uint8Array([
                baudRate & 0xFF,
                (baudRate >> 8) & 0xFF,
                (baudRate >> 16) & 0xFF,
                (baudRate >> 24) & 0xFF,
                0x00, // 1 stop bit
                0x00, // No parity
                0x08  // 8 data bits
            ]);

            await this.device.controlTransferOut({
                requestType: 'class',
                recipient: 'interface',
                request: 0x20, // SET_LINE_CODING
                value: 0,
                index: this.controlInterface
            }, lineCoding);
        } catch (e) {
            console.warn('Could not set line coding:', e.message);
        }

        // Assert DTR/RTS
        try {
            await this.device.controlTransferOut({
                requestType: 'class',
                recipient: 'interface',
                request: 0x22, // SET_CONTROL_LINE_STATE
                value: 0x03, // DTR=1, RTS=1
                index: this.controlInterface
            });
        } catch (e) {
            console.warn('Could not set control lines:', e.message);
        }

        // Create streams
        this._createStreams();

        // Setup disconnect handler
        this.logDebug('[WebUSBSerial-flasher] Setting up USB disconnect handler');
        this._usbDisconnectHandler = (event) => {
            this.logDebug('[WebUSBSerial-flasher] USB disconnect event fired, device:', event.device.productId);
            if (event.device === this.device) {
                this.logDebug('[WebUSBSerial-flasher] Device matches, firing close event');
                // Fire 'close' event to mimic Web Serial behavior
                this._fireEvent('close');
                this._cleanup();
            } else {
                this.logDebug('[WebUSBSerial-flasher] Device mismatch - different device disconnected');
            }
        };
        navigator.usb.addEventListener('disconnect', this._usbDisconnectHandler);
        this.logDebug('[WebUSBSerial-flasher] Disconnect handler registered with navigator.usb');
    }

    /**
     * Close the device (mimics port.close())
     * @returns {Promise<void>}
     */
    async close() {
        this._cleanup();
        if (this.device) {
            try {
                if (this.interfaceNumber !== null) {
                    await this.device.releaseInterface(this.interfaceNumber);
                }
                if (this.controlInterface !== null && this.controlInterface !== this.interfaceNumber) {
                    await this.device.releaseInterface(this.controlInterface);
                }
                await this.device.close();
            } catch (e) {
                // Ignore errors if device already disconnected
                if (!e.message || !e.message.includes('disconnected')) {
                    console.warn('Error closing device:', e.message || e);
                }
            }
            this.device = null;
        }
    }

    /* Dump detailed device info for diagnostics */
    async _dumpDeviceDetails(label, err) {
        try {
            if (!this.device) {
                this.logMessage(`[WebUSB] ${label}: no device set`);
                return;
            }
            const d = this.device;
            const lines = [];
            lines.push(`[WebUSB] ${label}: ${err && err.message ? err.message : err || ''}`);
            lines.push(`[WebUSB] Basic: opened=${d.opened} vid=0x${(d.vendorId || 0).toString(16).padStart(4, '0')} pid=0x${(d.productId || 0).toString(16).padStart(4, '0')}`);
            lines.push(`[WebUSB] Strings: product="${d.productName || 'n/a'}" manufacturer="${d.manufacturerName || 'n/a'}" serial="${d.serialNumber || 'n/a'}"`);
            const cfg = d.configuration;
            if (!cfg) {
                lines.push('[WebUSB] No active configuration');
                this.logMessage(lines.join('\n'));
                return;
            }
            lines.push(`[WebUSB] Active config: value=${cfg.configurationValue} interfaces=${cfg.interfaces.length}`);
            for (const iface of cfg.interfaces) {
                const alt = iface.alternates[0];
                lines.push(`[WebUSB]  iface ${iface.interfaceNumber}: class=${alt.interfaceClass} subclass=${alt.interfaceSubclass} proto=${alt.interfaceProtocol} eps=${alt.endpoints.length}`);
                for (const ep of alt.endpoints) {
                    lines.push(`[WebUSB]    ep ${ep.endpointNumber}: dir=${ep.direction} type=${ep.type} packetSize=${ep.packetSize}`);
                }
            }
            this.logMessage(lines.join('\n'));
        } catch (dumpErr) {
            this.logError(`[WebUSB] Failed to dump device details: ${dumpErr && dumpErr.message ? dumpErr.message : dumpErr}`);
        }
    }

    /**
     * Get device info (mimics port.getInfo())
     * @returns {Object} {usbVendorId, usbProductId}
     */
    getInfo() {
        if (!this.device) {
            return {};
        }
        return {
            usbVendorId: this.device.vendorId,
            usbProductId: this.device.productId
        };
    }

    /**
     * Set DTR/RTS signals (mimics port.setSignals())
     * @param {Object} signals - {dataTerminalReady, requestToSend}
     * @returns {Promise<void>}
     */
    async setSignals(signals) {
        if (!this.device) {
            throw new Error('Device not open');
        }

        var value = 0;
        value |= signals.dataTerminalReady ? 1 : 0;
        value |= signals.requestToSend ? 2 : 0;

        return this.device.controlTransferOut({
            requestType: 'class',
            recipient: 'interface',
            request: 0x22, /* CDC_SET_CONTROL_LINE_STATE */
            value: value,
            index: this.controlInterface
        });
    }

    /**
     * Get readable stream
     */
    get readable() {
        return this.readableStream;
    }

    /**
     * Get writable stream
     */
    get writable() {
        return this.writableStream;
    }

    /**
     * Create ReadableStream and WritableStream
     * @private
     */
    _createStreams() {
        // ReadableStream for incoming data
        this.readableStream = new ReadableStream({
            start: async (controller) => {
                this._readLoopRunning = true;

                try {
                    while (this._readLoopRunning && this.device) {
                        try {
                            /* Request one max-packet worth; large sizes can stall on some Android stacks */
                            const result = await this.device.transferIn(this.endpointIn, this.maxTransferSize);

                            if (result.status === 'ok') {
                                controller.enqueue(new Uint8Array(result.data.buffer, result.data.byteOffset, result.data.byteLength));
                                continue;
                            } else if (result.status === 'stall') {
                                await this.device.clearHalt('in', this.endpointIn);
                                await new Promise(r => setTimeout(r, 1));
                                continue;
                            } else {
                                console.warn('USB transferIn returned status:', result.status);
                            }
                            /* No data or zero-length transfer: immediately loop */
                            await new Promise(r => setTimeout(r, 1));
                        } catch (error) {
                            if (error.message && (error.message.includes('device unavailable') ||
                                error.message.includes('device has been lost') ||
                                error.message.includes('device was disconnected') ||
                                error.message.includes('No device selected'))) {
                                break;
                            }
                            if (error.message && (error.message.includes('transfer was cancelled') ||
                                error.message.includes('transfer error has occurred'))) {
                                continue;
                            }
                            /* Log other errors but continue */
                            console.warn('USB read error:', error.message);
                        }
                    }
                } catch (error) {
                    controller.error(error);
                } finally {
                    controller.close();
                }
            },
            cancel: () => {
                console.log('[WebUSBSerial-flasher] Read loop canceled');
                this._readLoopRunning = false;
            }
        });

        // WritableStream for outgoing data
        this.writableStream = new WritableStream({
            write: async (chunk) => {
                if (!this.device) {
                    throw new Error('Device not open');
                }
                await this.device.transferOut(this.endpointOut, chunk);
            }
        });
    }

    /**
     * Cleanup resources
     * @private
     */
    _cleanup() {
        console.log('[WebUSBSerial-flasher] Cleanup called');
        this._readLoopRunning = false;
        if (this._usbDisconnectHandler) {
            navigator.usb.removeEventListener('disconnect', this._usbDisconnectHandler);
            this._usbDisconnectHandler = null;
            console.log('[WebUSBSerial-flasher] Disconnect handler unregistered');
        }
    }

    /**
     * Fire event to all registered listeners
     * @private
     */
    _fireEvent(type) {
        const listeners = this._eventListeners[type] || [];
        console.log(`[WebUSBSerial-flasher] Firing '${type}' event to ${listeners.length} listener(s)`);
        listeners.forEach(listener => {
            try {
                listener();
            } catch (e) {
                console.error(`Error in ${type} event listener:`, e);
            }
        });
    }

    /**
     * Add event listener (mimics addEventListener for 'close' and 'disconnect')
     * @param {string} type - Event type
     * @param {Function} listener - Event handler
     */
    addEventListener(type, listener) {
        if (this._eventListeners[type]) {
            this._eventListeners[type].push(listener);
            console.log(`[WebUSBSerial-flasher] addEventListener('${type}') - now have ${this._eventListeners[type].length} listener(s)`);
        } else {
            console.log(`[WebUSBSerial-flasher] addEventListener('${type}') - unknown event type`);
        }
    }

    /**
     * Remove event listener
     * @param {string} type - Event type
     * @param {Function} listener - Event handler
     */
    removeEventListener(type, listener) {
        if (this._eventListeners[type]) {
            const index = this._eventListeners[type].indexOf(listener);
            if (index !== -1) {
                this._eventListeners[type].splice(index, 1);
            }
        }
    }
}

/**
 * ESP32 Bootloader Communication Handler
 * Manages serial communication with ESP32 devices using bootloader protocol
 * Supports reading/writing flash, downloading code to RAM, and firmware verification
 * @class ESPFlasher
 */
class ESPFlasher {

    /**
     * Initialize ESP32 flasher instance
     * Creates new instance with default configuration and empty state
     */
    constructor(options = {}) {
        this.devMode = options.devMode || false;
        this.logDebug = options.logDebug || ((msg) => { });
        this.logError = options.logError || ((msg) => { });
        this.logWarning = options.logWarning || ((msg) => { });
        this.logMessage = options.logMessage || ((msg) => { });
        this.logPackets = options.logPackets || false;

        /*
        Technical Limitation:
            Web Serial cannot change the baud rate without reopening the port, which may reset the device.
            Therefore, this tool keeps a single baud rate from start to end.
            ESP32 ROM prints its reset messages at 115200 baud.
            
            When using a USB-UART adapter with RX/TX wiring:
            - Use 115200 to see ROM reset messages (slower link), or
            - Use a higher baud (e.g., 921600) for speed but you will not see reset messages.

            This does not apply to native USB/JTAG interfaces of course.

            Normal ESP32 needs 115200 or 250000 for any operation.
        */
        this.initialBaudRate = options.initialBaudRate || 921600;



        this.chip_magic_addr = 0x40001000;
        this.chip_descriptions = new ChipDescriptionsClass().chip_descriptions;
        this.port = null;
        this.currentAddress = 0x0000;
        this.current_chip = "none";
        this.stubLoaded = false;
        this.responseHandlers = new Map();
        this.buffer = [];
        this.escaping = false;
        this.slipLayer = new SlipLayer();
        this.synced = false;
        this.consoleBuffer = '';
        this._preSyncState = 'idle';
        this.reader = null;
        this.dtrState = true;
        this.rtsState = true;

        /* Command execution lock to prevent concurrent command execution */
        this._commandLock = Promise.resolve();

        /* Persistent writer + queued writes to avoid WritableStream lock contention */
        this._activeWriter = null;
        this._writeChain = Promise.resolve();
    }

    /**
     * Ensure a single persistent WritableStreamDefaultWriter exists
     * @private
     */
    async _ensureWriter() {
        if (!this.port || !this.port.writable) {
            throw new Error('Port is not writable.');
        }
        if (!this._activeWriter) {
            this._activeWriter = this.port.writable.getWriter();
        }
        return this._activeWriter;
    }

    /**
     * Queue a write on the persistent writer to serialize all writes
     * @private
     */
    async _writeFrame(frame) {
        this._writeChain = this._writeChain.then(async () => {
            const writer = await this._ensureWriter();
            this.logSerialData(frame, true);
            await writer.write(frame);
        });
        return this._writeChain;
    }

    /**
     * Release the persistent writer if held
     * @private
     */
    _releaseWriter() {
        if (this._activeWriter) {
            try { this._activeWriter.releaseLock(); } catch (e) { }
            this._activeWriter = null;
        }
    }

    /**
     * Format bytes as colored hex dump for console
     * @param {Uint8Array} data - Data to format
     * @param {string} isTx - 'TX' or 'RX'
     * @param {number} maxBytes - Maximum bytes to show (default: 256)
     */
    logSerialData(data, isTx, maxBytes = 256) {
        if (!this.logPackets) return;

        const arrow = isTx ? '' : '';

        const bytesToShow = Math.min(data.length, maxBytes);
        const truncated = data.length > maxBytes;

        // Format hex string with spaces every 2 bytes and newline every 16 bytes
        let hexStr = '';
        let asciiStr = '';
        let lines = [];

        for (let i = 0; i < bytesToShow; i++) {
            const byte = data[i];
            hexStr += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
            asciiStr += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';

            if ((i + 1) % 16 === 0 || i === bytesToShow - 1) {
                // Pad hex string to align ASCII
                const hexPadding = ' '.repeat(Math.max(0, (16 - ((i % 16) + 1)) * 3));
                lines.push(`  ${hexStr}${hexPadding} | ${asciiStr}`);
                hexStr = '';
                asciiStr = '';
            }
        }
        if (this.logPackets) {
            const truncMsg = truncated ? ` (showing ${bytesToShow}/${data.length} bytes)` : '';
            this.logDebug(`${arrow} ${isTx} [${data.length} bytes]${truncMsg}`);
            lines.forEach(line => this.logDebug(line));
        }
    }

    /**
     * Open serial port and start reading packets
     * @async
     * @returns {Promise<void>}
     * @throws {Error} If port request fails
     */
    async openPort() {
        /* Require Web Serial API (available in Chrome/Edge) */
        if (typeof navigator === 'undefined' || !navigator.serial) {
            throw new Error('Web Serial API not available. Please use Chrome or Edge.');
        }

        const port = await navigator.serial.requestPort();
        return this.openPortWithPort(port);
    }

    /**
     * Open a provided serial port (Web Serial or WebUSB)
     * @async
     * @param {SerialPort|WebUSBSerial} port - Port instance to open
     * @returns {Promise<void>}
     * @throws {Error} If connection fails
     */
    async openPortWithPort(port) {
        return new Promise(async (resolve, reject) => {

            /* Open the port */
            try {
                this.port = port;

                /* If WebUSBSerial, provide logger callbacks so low-level dumps reach UI log */
                if (this.port instanceof WebUSBSerial) {
                    this.port.logger = {
                        info: (msg) => { this.logDebug && this.logDebug(msg); },
                        error: (msg) => { this.logError && this.logError(msg); }
                    };
                }

                await this.port.open({ baudRate: this.initialBaudRate });

                /* Get and log VID/PID information */
                const portInfo = this.port.getInfo();
                if (portInfo.usbVendorId !== undefined && portInfo.usbProductId !== undefined) {
                    const vid = portInfo.usbVendorId;
                    const pid = portInfo.usbProductId;
                    this.logDebug(`Device: VID=0x${vid.toString(16).padStart(4, '0').toUpperCase()}, PID=0x${pid.toString(16).padStart(4, '0').toUpperCase()}`);

                    /* Check for Espressif USB JTAG device */
                    if (vid === 0x303A) {
                        this.logDebug('Detected Espressif USB JTAG device - high baud rates supported, bootloader messages will be visible');
                        this.isEspressifUsbJtag = true;
                    } else {
                        this.isEspressifUsbJtag = false;
                    }
                } else {
                    this.logDebug('Device: VID/PID information not available (may not be a USB device)');
                    this.isEspressifUsbJtag = false;
                }
            } catch (error) {
                reject(error);
                return;
            }


            // Register for device lost (Web Serial API)
            if (navigator.serial) {
                navigator.serial.addEventListener('disconnect', (event) => {
                    if (event.target === this.port) {
                        this.logError(`The device was disconnected`);
                        this.disconnect();
                    }
                });
            }

            // Register for port closing
            if (this.port.addEventListener) {
                this.port.addEventListener('close', () => {
                    if (!this._disconnecting) {
                        this.logError('Device disconnected unexpectedly');
                    }
                });
            }

            resolve();

            /* Set up reading from the port */
            this.reader = this.port.readable.getReader();

            this.startRxLoop();
        });
    }

    async startRxLoop() {
        try {
            while (true) {
                if (typeof performance !== 'undefined' && performance.mark && performance.measure) {
                    performance.mark('esp32_flasher_receive_start');
                }
                const { value, done } = await this.reader.read();
                if (typeof performance !== 'undefined' && performance.mark && performance.measure) {
                    performance.mark('esp32_flasher_receive_end');
                    try {
                        performance.measure('esp32_flasher_receive', 'esp32_flasher_receive_start', 'esp32_flasher_receive_end');
                    } catch (measureErr) {
                    }
                }
                if (done) {
                    this.logDebug('Reader has been canceled');
                    break;
                }
                if (value) {
                    this.logSerialData(value, false);
                    this.parseResetMessages(value);
                    const packets = this.slipLayer.decode(value);
                    for (let packet of packets) {
                        await this.processPacket(packet);
                    }
                }
            }
        } catch (err) {
            // Handle cancellation
        } finally {
            if (this.reader) {
                this.reader.releaseLock();
                this.reader = null;
            }
        }
    }

    /**
     * Reopen the existing serial port with a new baud rate
     * Closes the current reader and port, then opens the same port at `baudRate`
     * and restarts the RX loop without re-requesting the device.
     * @async
     * @param {number} baudRate - New baud rate to use
     * @returns {Promise<void>}
     * @throws {Error} If port is not selected/openable
     */
    async reopenPort(baudRate) {
        if (!this.port) {
            throw new Error('No port selected. Call openPort() first to choose a device.');
        }

        /* Stop existing reader if any */
        if (this.reader) {
            try {
                await this.reader.cancel();
            } catch (error) {
                /* Ignore cancellation errors */
            }
            try {
                this.reader.releaseLock();
            } catch (e) {
                /* Ignore release errors */
            }
            this.reader = null;
        }

        /* Wait for pending writes and release writer before closing */
        try {
            await this._writeChain;
        } catch (e) { /* Ignore pending write errors on reopen */ }
        this._releaseWriter();

        /* Close and reopen the same port with new baud */
        try {
            await this.port.close();
        } catch (error) {
            /* Ignore close errors, we will try to open regardless */
        }

        const newBaud = baudRate || this.initialBaudRate;
        this.initialBaudRate = newBaud;
        await this.port.open({ baudRate: newBaud });

        /* Restart RX loop (do not re-register global listeners to avoid duplicates) */
        this.reader = this.port.readable.getReader();

        this.startRxLoop();
    }

    parseResetMessages(data) {
        /*
        ESP32
            ets Jun  8 2016 00:22:57

            rst:0x1 (POWERON_RESET),boot:0x1 (DOWNLOAD_BOOT(UART0/UART1/SDIO_FEI_REO_V2))
            waiting for download
           
        ESP32-S3 (normal)     
            ESP-ROM:esp32s3-20210327
            Build:Mar 27 2021
            rst:0x1 (POWERON),boot:0x0 (DOWNLOAD(USB/UART0))
            waiting for download

        ESP32-C3 (secure)
            ESP-ROM:esp32c3-api1-20210207
            Build:Feb  7 2021
            rst:0x15 (USB_UART_CHIP_RESET),boot:0x5 (DOWNLOAD(USB/UART0/1))
            Saved PC:0x4004d1f8
            wait uart download(secure mode)

        ESP32-C3 (normal)
            ESP-ROM:esp32c3-api1-20210207
            Build:Feb  7 2021
            rst:0x15 (USB_UART_CHIP_RESET),boot:0x7 (DOWNLOAD(USB/UART0/1))
            Saved PC:0x4004c0d4
            waiting for download

        */


        /* Only care about pre-sync console chatter */
        if (!data || !data.length) {
            return;
        }

        /* Accumulate printable ASCII and newlines */
        let chunk = '';
        for (let i = 0; i < data.length; i++) {
            const b = data[i];
            if (b === 10 || b === 13) {
                chunk += '\n';
            } else if (b >= 32 && b <= 126) {
                chunk += String.fromCharCode(b);
            }
        }

        if (!chunk.length) {
            return;
        }

        this.consoleBuffer = (this.consoleBuffer || '') + chunk;

        let newlineIdx = this.consoleBuffer.indexOf('\n');
        while (newlineIdx !== -1) {
            const line = this.consoleBuffer.slice(0, newlineIdx).trim();
            this.consoleBuffer = this.consoleBuffer.slice(newlineIdx + 1);
            if (line.length) {
                // Only print device messages if not yet synced
                if (!this.synced) {
                    this.logDebug(`[Device] ${line}`);
                }

                const lower = line.toLowerCase();
                const rstBootMatch = line.match(/rst:0x([0-9a-f]+)/i);
                const bootMatch = line.match(/boot:0x([0-9a-f]+)/i);

                if (rstBootMatch && bootMatch) {
                    const rst = parseInt(rstBootMatch[1], 16);
                    const boot = parseInt(bootMatch[1], 16);
                    const rstInfo = RESET_REASON_MAP[rst] || { name: 'UNKNOWN', desc: `Unknown reset reason 0x${rst.toString(16)}` };
                    this.deviceStateCallback && this.deviceStateCallback('reboot', { rst, rstName: rstInfo.name, rstDesc: rstInfo.desc, boot });
                    /* Enable mode detection after reboot line */
                    this._preSyncState = 'seen_reboot';
                }

                /* State machine: after reboot line, accept one mode line */
                if (this._preSyncState === 'seen_reboot') {
                    if (lower.includes('(secure mode)')) {
                        this.deviceStateCallback && this.deviceStateCallback('secure');
                        this._preSyncState = 'idle';
                    } else if (lower.includes('waiting for download') || lower.includes('wait uart download')) {
                        this.deviceStateCallback && this.deviceStateCallback('download');
                        this._preSyncState = 'idle';
                    }
                }

            }
            newlineIdx = this.consoleBuffer.indexOf('\n');
        }
    }

    /**
     * Read 32-bit value from chip register
     * @async
     * @param {number} addr - Register address
     * @returns {Promise<number>} Register value
     */
    async readReg(addr) {
        return this.executeCommand(this.buildCommandPacketU32(READ_REG, addr),
            async (resolve, reject, responsePacket) => {
                if (responsePacket) {
                    resolve(responsePacket.value);
                } else {
                    reject('Failed to read register');
                }
            });
    }


    /**
     * Detect if stub loader is running on device
     * @async
     * @returns {Promise<boolean>} True if stub loader active, false if ROM bootloader
     * @throws {Error} If detection fails
     * @description Distinguishes stub loader from ROM bootloader by magic address response size
     */
    async isStubLoader() {
        return this.executeCommand(this.buildCommandPacketU32(READ_REG, this.chip_magic_addr),
            async (resolve, reject, responsePacket) => {
                if (responsePacket && responsePacket.data) {
                    if (responsePacket.data.length == 2) {
                        resolve(true);
                    }
                    if (responsePacket.data.length == 4) {
                        resolve(false);
                    }
                    reject('Unexpected length');
                } else {
                    reject('Failed to read register');
                }
            });
    }

    /**
     * Execute command on device
     * @async
     * @param {Object} packet - Command packet from buildCommandPacket
     * @param {Function} packetResponseCbr - Response handler(resolve, reject, responsePacket)
     * @param {Function} [rawDataCbr] - Raw data handler
     * @param {number} [timeout=500] - Timeout in milliseconds
     * @param {Function} [checkTimeoutCbr] - Optional timeout check returning boolean
     * @returns {Promise<*>} Result from callback
     * @throws {Error} On timeout or command failure
     */
    async executeCommand(packet, packetResponseCbr, rawDataCbr, timeout = 500, checkTimeoutCbr = null) {
        /*
         Serialize command execution properly:
         - Do NOT create the command promise before acquiring the logical lock.
           Creating it early can start the async work and contend for the writable stream.
         - Instead, chain the creation to the existing lock so only one writer is active.
        */
        const run = () => this._executeCommandUnlocked(packet, packetResponseCbr, rawDataCbr, timeout, checkTimeoutCbr);
        this._commandLock = this._commandLock.then(run, run);
        return this._commandLock;
    }

    /**
     * Internal command execution (unlocked)
     * @async
     * @private
     */
    async _executeCommandUnlocked(packet, packetResponseCbr, rawDataCbr, timeout = 500, checkTimeoutCbr = null) {
        if (!this.port || !this.port.writable) {
            throw new Error("Port is not writable.");
        }

        if (this.devMode) {
            this.dumpPacket(this.parsePacket(packet.payload));
        }

        return new Promise(async (resolve, reject) => {
            /* Set timeout handler */
            let timeoutHandle = null;

            const scheduleTimeout = () => {
                timeoutHandle = setTimeout(() => {
                    if (checkTimeoutCbr) {
                        if (checkTimeoutCbr()) {
                            safeReject(new Error(`Timeout in command ${packet.command}`));
                        } else {
                            scheduleTimeout();
                        }
                    } else {
                        safeReject(new Error(`Timeout after ${timeout} ms waiting for response to command ${packet.command}`));
                    }
                }, timeout);
            };

            const safeResolve = (value) => { clearTimeout(timeoutHandle); return resolve(value); };
            const safeReject = (err) => { clearTimeout(timeoutHandle); return reject(err); };


            /* Register response handlers */
            this.responseHandlers.clear();

            /* decide which callbacks to register */
            if (rawDataCbr) {
                /* this command seems to have have normal response then raw data */
                this.responseHandlers.set(packet.command, async (response) => {
                    if (packetResponseCbr) {
                        return packetResponseCbr(safeResolve, safeReject, response);
                    }
                });
                this.responseHandlers.set(-1, async (response) => {
                    return rawDataCbr(safeResolve, safeReject, response);
                });
            } else {
                /* only normal response */
                this.responseHandlers.set(packet.command, async (response) => {
                    if (packetResponseCbr) {
                        return packetResponseCbr(safeResolve, safeReject, response);
                    }
                });
            }

            /* Send the packet with proper error handling */
            try {
                scheduleTimeout();
                if (typeof performance !== 'undefined' && performance.mark) {
                    performance.mark('esp32_flasher_send_start');
                }

                await this._writeFrame(this.slipLayer.encode(packet.payload));

                if (typeof performance !== 'undefined' && performance.mark && performance.measure) {
                    performance.mark('esp32_flasher_send_end');
                    try {
                        performance.measure('esp32_flasher_send', 'esp32_flasher_send_start', 'esp32_flasher_send_end');
                        performance.measure('esp32_flasher_latency', 'esp32_flasher_receive_end', 'esp32_flasher_send_start');
                        /* measured ~50-100us latency on USB-JTAG for register read flooding */
                    } catch (measureErr) {
                    }
                }
            } catch (error) {
                clearTimeout(timeoutHandle);
                reject(error);
            }
        });
    }

    /**
     * Disconnect from serial port
     * @async
     * @returns {Promise<void>}
     */
    async disconnect() {
        if (this._disconnecting) {
            return;
        }
        this._disconnecting = true;

        navigator.serial.removeEventListener('disconnect', this.disconnect);

        if (this.reader) {
            try {
                await this.reader.cancel();
            } catch (error) {
                this.logError('Error cancelling reader:', error);
            }
        }

        /* Release persistent writer before closing port */
        this._releaseWriter();

        if (this.port) {
            try {
                this.port.removeEventListener('close', this.disconnect);
                await this.port.close();
            } catch (error) {
                //this.logError('Error during disconnect:', error);
            }
            this.port = null;
        }

        this.synced = false;
        this.consoleBuffer = '';
        this._preSyncState = 'idle';
        this._disconnecting = false;

        this.disconnected && this.disconnected();
    }

    async setDtr(value) {
        try {
            this.dtrState = value;
            await this.port.setSignals({
                dataTerminalReady: value,
                requestToSend: this.rtsState,
            });
            return true;
        } catch (error) {
            console.error(`Could not set DTR: ${error}.`);
            return false;
        }
    }

    async setRts(value) {
        try {
            this.rtsState = value;
            await this.port.setSignals({
                dataTerminalReady: this.dtrState,
                requestToSend: value,
            });
            return true;
        } catch (error) {
            console.error(`Could not set RTS: ${error}.`);
            return false;
        }
    }

    async setDtrRts(dtr, rts) {
        if (!this.port) {
            this.logError("Port is not open. Cannot set signals.");
            return false;
        }

        this.dtrState = dtr;
        this.rtsState = rts;

        try {
            await this.port.setSignals({
                dataTerminalReady: dtr,
                requestToSend: rts,
            });
            return true;
        } catch (error) {
            this.logError(`Could not set signals: ${error}.`);
            return false;
        }
    }

    async setSignals(signals) {
        if (!this.port) {
            this.logError("Port is not open. Cannot set signals.");
            return false;
        }

        if (signals.dataTerminalReady !== undefined) {
            this.dtrState = signals.dataTerminalReady;
        }
        if (signals.requestToSend !== undefined) {
            this.rtsState = signals.requestToSend;
        }

        try {
            await this.setDtr(this.dtrState);
            await this.setRts(this.rtsState);
            return true;
        } catch (error) {
            this.logError(`Could not set signals: ${error}.`);
            return false;
        }
    }

    /**
     * Attempts to put the ESP device into bootloader mode using RTS/DTR signals.
     * Relies on the common DTR=EN, RTS=GPIO0 circuit. May not work on all boards.
     * @returns {Promise<boolean>} True if the sequence was sent, false if an error occurred (e.g., signals not supported).
     */
    async hardReset(bootloader = true) {
        if (!this.port) {
            this.logError("Port is not open. Cannot set signals.");
            return false;
        }

        this.synced = false;
        this.consoleBuffer = '';
        this._preSyncState = 'idle';

        this.logDebug("Automatic bootloader reset sequence...");

        try {

            if (this.isEspressifUsbJtag) {
                /* Native USB/JTAG interface - use the method described in ESP32-S3 Table 33.4-3. Reset SoC into Download Mode.
                   This procedure assumes the Windows CDC driver toggles DRT only when RTS is set explicitly. */

                /* set to known state first, but causes an extra reset usually */
                await this.setDtr(false);
                await this.setRts(false);

                if (bootloader) {
                    await this.setDtr(true);
                    await this.setRts(false);
                    await this.setRts(true);
                    await this.setDtr(false);
                }

                await this.setRts(false);
                await this.setRts(true);
            } else {
                /* high/low vs. asserted/deasserted logic is a bit pain here:
                   EN pin (RTS) - active low - to reset, pull low (EN high means RTS=false)
                   IO0 pin (DTR) - active low - to enter bootloader, pull low (IO0 high means DTR=false)
                */
                const setPins = async ({ io0PinHigh, enPinHigh }) => {
                    const io0Level = io0PinHigh ? false : true;
                    const enLevel = enPinHigh ? false : true;
                    await this.setSignals({ requestToSend: enLevel, dataTerminalReady: io0Level });
                };

                await setPins({ io0PinHigh: true, enPinHigh: true });
                await setPins({ io0PinHigh: false, enPinHigh: false });
                await setPins({ io0PinHigh: true, enPinHigh: false });
                await new Promise(r => setTimeout(r, 50));
                await setPins({ io0PinHigh: bootloader ? false : true, enPinHigh: true });
                await new Promise(r => setTimeout(r, 100));
                await setPins({ io0PinHigh: true, enPinHigh: true });
            }

            return true;
        } catch (error) {
            this.logError(`Could not set signals for automatic reset: ${error}. Please ensure device is in bootloader mode manually.`);
            return false;
        }
    }


    /**
     * Convert base64-encoded string to binary data
     * @param {string} base64 - Base64-encoded data string
     * @returns {Uint8Array} Decoded binary data
     * @description Decodes base64 string using native atob and converts to Uint8Array
     */
    base64ToByteArray(base64) {
        const binaryString = atob(base64);
        const byteArray = new Uint8Array(binaryString.length);
        for (let index = 0; index < binaryString.length; index++) {
            byteArray[index] = binaryString.charCodeAt(index);
        }
        return byteArray;
    }

    /**
     * Download binary payload to device RAM
     * @async
     * @param {number} address - Target RAM address
     * @param {string} payload - Base64-encoded binary data
     * @returns {Promise<void>}
     * @throws {Error} If download fails
     * @description Used for downloading stub loader and other code to RAM
     */
    async downloadMem(address, payload) {
        var binary = this.base64ToByteArray(payload);

        await this.executeCommand(this.buildCommandPacketU32(MEM_BEGIN, binary.length, 1, binary.length, address),
            async (resolve, reject, responsePacket) => {
                resolve();
            });
        await this.executeCommand(this.buildCommandPacketU32(MEM_DATA, binary.length, 0, 0, 0, binary),
            async (resolve, reject, responsePacket) => {
                resolve();
            });
    }

    /**
     * Synchronize with bootloader and detect chip type
     * @async
     * @returns {Promise<void>}
     * @throws {Error} If synchronization fails after all retries
     * @description Performs SYNC command with retry logic, then reads chip magic value
     *              to detect connected chip type (ESP32, ESP32-S3, etc.)
     */
    async sync() {
        const maxRetries = 4;
        const retryDelayMs = 100; /* Delay between retries (Android stacks can be slower) */
        const syncTimeoutMs = 300; /* Timeout for each individual sync attempt */
        let synchronized = false;

        this.logDebug(`Attempting to synchronize (${maxRetries} attempts)...`);

        const syncData = new Uint8Array([0x07, 0x07, 0x12, 0x20, ...Array(32).fill(0x55)]);
        const syncPacket = this.buildCommandPacket(SYNC, syncData);

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            this.logDebug(`Sync attempt ${attempt}...`);
            try {
                await this.executeCommand(
                    syncPacket,
                    async (resolve, reject, responsePacket) => {
                        // The ROM bootloader responds to SYNC with 0x08 0x00 status - check value maybe?
                        // For now, just receiving *any* response to SYNC is considered success here.
                        // If the command times out, the catch block below handles it.
                        resolve(); // Signal success for this attempt
                    },
                    null, // No default callback needed here
                    syncTimeoutMs // Use a specific timeout for sync
                );

                // If executeCommand resolved without throwing/rejecting:
                this.logDebug(`Synchronized successfully on attempt ${attempt}.`);
                synchronized = true;
                break; // Exit the retry loop on success

            } catch (error) {
                this.logDebug(`Sync attempt ${attempt} failed: ${error.message}`);
                if (attempt === maxRetries) {
                    this.logError(`Failed to synchronize after ${maxRetries} attempts.`);
                    // Throw an error to indicate overall failure of the sync process
                    throw new Error(`Failed to synchronize with device after ${maxRetries} attempts.`);
                }
                // Wait before the next retry
                await new Promise(resolve => setTimeout(resolve, retryDelayMs));
            }
        }

        // This part only runs if synchronized was set to true
        if (!synchronized) {
            // This should technically not be reached if the error is thrown above,
            // but adding as a safeguard.
            throw new Error("Synchronization failed (unexpected state).");
        }

        this.synced = true;

        // Read security information
        try {
            this.logDebug("Reading security information...");
            this.securityInfo = await this.getSecurityInfo();
            this.current_chip = CHIP_ID_MAP[this.securityInfo.chip_id_hex >>> 0] || "unknown";

            this.logDebug(`Security Info: Flags=${this.securityInfo.flags_hex}, Flash Crypt=${this.securityInfo.flash_crypt_cnt}, Chip ID=${this.securityInfo.chip_id_hex} (${this.current_chip}), ECO=${this.securityInfo.eco_version_hex}`);

            /* Log enabled security features */
            const enabledFlags = Object.entries(this.securityInfo.flags_decoded)
                .filter(([key, value]) => value)
                .map(([key, _]) => key);
            if (enabledFlags.length > 0) {
                this.logDebug(`  Enabled security features: ${enabledFlags.join(', ')}`);
            } else {
                this.logDebug(`  No security features enabled`);
            }

            if (this.securityInfo.flags_decoded.SECURE_BOOT_EN) {
                if (!this.securityInfo.flags_decoded.SECURE_DOWNLOAD_ENABLE) {
                    this.deviceStateCallback && this.deviceStateCallback('secure_boot');
                } else {
                    this.deviceStateCallback && this.deviceStateCallback('secure_download');
                }
            }

            /* if this command succeeded, we already have the chip type, so we can just return. only plain ESP32 doesn't have the security info command */
            return;
        } catch (error) {
            this.logDebug(`Failed to read security info: ${error.message}, maybe plain ESP32? Continuing to old chip detection...`);
        }

        // --- Chip Detection (Runs only after successful sync) ---
        this.logDebug("Reading chip magic value...");
        let currentValue;
        try {
            // Use a slightly longer timeout for register reads if needed
            currentValue = await this.readReg(this.chip_magic_addr);
        } catch (readError) {
            this.logError(`Failed to read magic value after sync: ${readError}`);
            throw new Error(`Successfully synced, but failed to read chip magic value: ${readError.message}`);
        }

        /* Function to check if the value matches any of the magic values */
        const isMagicValue = (stub, value) => {
            if (Array.isArray(stub.magic_value)) {
                return stub.magic_value.includes(value);
            } else {
                return stub.magic_value === value;
            }
        };

        let chipDetected = false;
        /* Iterate through each stub in the object */
        for (const desc in this.chip_descriptions) {
            if (this.chip_descriptions.hasOwnProperty(desc)) {
                const checkStub = this.chip_descriptions[desc];
                if (isMagicValue(checkStub, currentValue)) {
                    this.logDebug(`Detected Chip: ${desc} (Magic: 0x${currentValue.toString(16)})`);
                    this.current_chip = desc;
                    chipDetected = true;
                    break; // Found the chip
                }
            }
        }

        if (!chipDetected) {
            this.logError(`Synced, but chip magic value 0x${currentValue.toString(16)} is unknown.`);
            this.current_chip = "unknown"; // Mark as unknown
        }
    }

    /**
     * Read device MAC address from eFuses
     * @async
     * @returns {Promise<string>} MAC address as colon-separated hex string (e.g., "aa:bb:cc:dd:ee:ff")
     * @throws {Error} If register read fails
     * @description Reads MAC address from chip-specific eFuse registers
     */
    async readMac() {
        /* Read the MAC address registers */
        var chip = this.chip_descriptions[this.current_chip];
        if (!chip.mac_efuse_reg) {
            throw new Error(`MAC eFuse register not defined for chip ${this.current_chip}`);
        }
        const register1 = await this.readReg(chip.mac_efuse_reg);
        const register2 = await this.readReg(chip.mac_efuse_reg + 4);

        if (!register1 || !register2) {
            return;
        }

        const lower = (register1 >>> 0);
        const higher = (register2 >>> 0) & 0xFFFF;

        // Construct MAC address from register values
        const macBytes = new Uint8Array(6);
        macBytes[0] = (higher >> 8) & 0xFF;
        macBytes[1] = higher & 0xFF;
        macBytes[2] = (lower >> 24) & 0xFF;
        macBytes[3] = (lower >> 16) & 0xFF;
        macBytes[4] = (lower >> 8) & 0xFF;
        macBytes[5] = lower & 0xFF;

        function toHex(byte) {
            const hexString = byte.toString(16);
            return hexString.length === 1 ? '0' + hexString : hexString;
        }
        const mac = Array.from(macBytes)
            .map(byte => toHex(byte))
            .join(':');

        return mac;
    }

    /**
     * Read chip security information
     * @async
     * @returns {Promise<Object>} Security info object with flags, flash_crypt_cnt, key_purposes, chip_id, eco_version
     * @throws {Error} If read fails
     * @description Reads chip security configuration including encryption status and key purposes
     */
    async getSecurityInfo() {
        return this.executeCommand(
            this.buildCommandPacketU32(GET_SECURITY_INFO, 0),
            async (resolve, reject, responsePacket) => {
                if (responsePacket && responsePacket.data && responsePacket.data.length >= 20) {
                    const data = responsePacket.data;

                    /* Parse 32-bit flags (little-endian) */
                    const flags = (data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24)) >>> 0;

                    /* Decode security flags */
                    const decodedFlags = {
                        SECURE_BOOT_EN: !!(flags & (1 << 0)),
                        SECURE_BOOT_AGGRESSIVE_REVOKE: !!(flags & (1 << 1)),
                        SECURE_DOWNLOAD_ENABLE: !!(flags & (1 << 2)),
                        SECURE_BOOT_KEY_REVOKE0: !!(flags & (1 << 3)),
                        SECURE_BOOT_KEY_REVOKE1: !!(flags & (1 << 4)),
                        SECURE_BOOT_KEY_REVOKE2: !!(flags & (1 << 5)),
                        SOFT_DIS_JTAG: !!(flags & (1 << 6)),
                        HARD_DIS_JTAG: !!(flags & (1 << 7)),
                        DIS_USB: !!(flags & (1 << 8)),
                        DIS_DOWNLOAD_DCACHE: !!(flags & (1 << 9)),
                        DIS_DOWNLOAD_ICACHE: !!(flags & (1 << 10))
                    };

                    /* Parse 1 byte flash_crypt_cnt */
                    const flash_crypt_cnt = data[4];

                    /* Parse 7 bytes key_purposes */
                    const key_purposes = Array.from(data.slice(5, 12));

                    /* Parse 32-bit chip_id (little-endian) */
                    const chip_id = (data[12] | (data[13] << 8) | (data[14] << 16) | (data[15] << 24)) >>> 0;

                    /* Parse 32-bit eco_version (little-endian) */
                    const eco_version = (data[16] | (data[17] << 8) | (data[18] << 16) | (data[19] << 24)) >>> 0;

                    const securityInfo = {
                        flags: flags,
                        flags_hex: '0x' + flags.toString(16).toUpperCase().padStart(8, '0'),
                        flags_decoded: decodedFlags,
                        flash_crypt_cnt: flash_crypt_cnt,
                        key_purposes: key_purposes,
                        chip_id: chip_id,
                        chip_id_hex: '0x' + chip_id.toString(16).toUpperCase().padStart(8, '0'),
                        eco_version: eco_version,
                        eco_version_hex: '0x' + eco_version.toString(16).toUpperCase().padStart(8, '0')
                    };

                    resolve(securityInfo);
                } else {
                    reject('Invalid security info response');
                }
            },
            null,
            100
        );
    }

    /**
     * Test serial communication reliability
     * @async
     * @param {Function} [cbr] - Progress callback(percentComplete)
     * @returns {Promise<boolean>} True if test passed, false if failed
     * @description Performs 1-second stress test reading the same register repeatedly,
     *              verifying all reads return identical values
     */
    async testReliability(cbr) {

        var chip = this.chip_descriptions[this.current_chip];
        var reference = 0;

        try {
            reference = await this.executeCommand(this.buildCommandPacketU32(READ_REG, chip.mac_efuse_reg),
                async (resolve, reject, responsePacket) => {
                    if (responsePacket) {
                        resolve(responsePacket.value);
                    } else {
                        this.logError(`Test read failed`);
                        reject(`Test read failed`);
                    }
                });
        } catch (error) {
            this.logError(`Test read failed due to an error`, `${error.message}`);
            return false;
        }

        var duration = 1000;
        const endTime = Date.now() + duration;

        let totalReads = 0;
        let totalTime = 0;

        while (Date.now() < endTime) {
            try {
                const startTime = Date.now();

                var testread = await this.executeCommand(this.buildCommandPacketU32(READ_REG, chip.mac_efuse_reg),
                    async (resolve, reject, responsePacket) => {
                        if (responsePacket) {
                            resolve(responsePacket.value);
                        } else {
                            reject(`Test read failed`);
                        }
                    });

                const endTimeRead = Date.now();
                const readDuration = endTimeRead - startTime;

                totalTime += readDuration;
                totalReads++;

                /* Update the progress bar */
                const elapsed = Date.now() - (endTime - duration); // duration is the total time period (change to 30000 for 30 seconds)
                const progressPercentage = Math.min(100, (elapsed / duration) * 100); // Cap at 100%

                cbr && cbr(progressPercentage);

                /* Check if the read value differs from the reference */
                if (testread !== reference) {
                    this.logError(`Test read failed! Expected: 0x${reference.toString(16).padStart(8, '0')}, but got: 0x${testread.toString(16).padStart(8, '0')}`);
                    break;
                }
            } catch (error) {
                this.logError(`Test read failed due to an error`, `${error.message}`);
                return false;
            }
        }

        if (totalReads > 0) {
            const averageTime = totalTime / totalReads;
            this.logMessage(`Average read time: ${averageTime.toFixed(2)} ms over ${totalReads} reads.`);
        }

        return true;
    }

    /**
     * Download and execute stub loader on device
     * @async
     * @returns {Promise<boolean>} True if stub loaded successfully, false otherwise
     * @throws {Error} If stub loading or initialization fails
     * @description Downloads stub firmware to RAM and executes it.
     *              Stub provides additional capabilities like flash read/write and MD5.
     */
    async downloadStub() {
        var stub = this.chip_descriptions[this.current_chip].stub

        if (stub.data_start != undefined && stub.data != undefined) {
            await this.downloadMem(stub.data_start, stub.data);
        }
        await this.downloadMem(stub.text_start, stub.text);

        try {
            await this.executeCommand(this.buildCommandPacketU32(MEM_END, 0, stub.entry),
                async (resolve, reject, responsePacket) => {
                    this.logDebug("Final MEM_END ACK");
                },
                async (resolve, reject, rawData) => {
                    const decoder = new TextDecoder('utf-8');
                    const responseData = decoder.decode(rawData);

                    if (responseData == "OHAI") {
                        this.logDebug(`Stub loader executed successfully (received ${responseData})`);
                        this.stubLoaded = true;
                        resolve();
                    } else {
                        this.logError(`Unexpected stub response: ${responseData}`);
                        reject(`Unexpected response from stub: ${responseData}`);
                    }
                },
                3000 // Longer timeout for stub execution
            );
        } catch (error) {
            this.logDebug(error);
            this.logError("Failed to execute stub", "Is the device locked?");
            return false;
        }

        try {
            await this.executeCommand(this.buildCommandPacketU32(SPI_SET_PARAMS, 0, 0x800000, 64 * 1024, 4 * 1024, 256, 0xFFFF), async (resolve, reject, responsePacket) => {
                this.logDebug("SPI_SET_PARAMS configured");
                resolve();
            });
        } catch (error) {
            this.logError("Failed to configure SPI parameters", error.message);
            return false;
        }

        return true;
    }

    /**
     * Write data to flash memory
     * @async
     * @param {number} address - Target flash address
     * @param {Uint8Array} data - Binary data to write
     * @param {Function} [progressCallback] - Callback(bytesWritten, totalBytes)
     * @returns {Promise<void>}
     * @throws {Error} If write fails
     */
    async writeFlashPlain(address, data, progressCallback) {
        const MAX_PACKET_SIZE = 0x1000;
        const packets = Math.ceil(data.length / MAX_PACKET_SIZE);

        /* Send FLASH_BEGIN command with the total data size
           according to https://docs.espressif.com/projects/esptool/en/latest/esp32s3/advanced-topics/serial-protocol.html
           the ROM bootloader is also able to flash. unfortunately there are some issues with it.
           it doesn't respond anymore. use with stub only!
        */
        await this.executeCommand(
            this.buildCommandPacketU32(FLASH_BEGIN, data.length, packets,
                Math.min(MAX_PACKET_SIZE, data.length),
                address
            ),
            async (resolve) => {
                resolve();
            }
        );

        /* Split data into chunks and send FLASH_DATA commands */
        var seq = 0;
        for (let offset = 0; offset < data.length; offset += MAX_PACKET_SIZE) {
            const chunk = data.slice(offset, offset + MAX_PACKET_SIZE);

            /* Four 32-bit words: data size, sequence number, 0, 0, then data. Uses Checksum. */
            await this.executeCommand(
                this.buildCommandPacketU32(FLASH_DATA, chunk.length, seq++, 0, 0, chunk),
                async (resolve) => {
                    resolve();
                },
                null,
                5000
            );

            progressCallback && progressCallback(offset + chunk.length, data.length);
        }
    }

    /**
     * Read data from flash memory
     * @async
     * @param {number} address - Source flash address
     * @param {number} [totalLength=0x1000] - Number of bytes to read
     * @param {Function} [progressCallback] - Callback(bytesRead, totalBytes)
     * @returns {Promise<Uint8Array>} Read data (MD5 verified)
     * @throws {Error} If read fails or MD5 mismatch
     * 

       ESP32-C3
        [01:04:10] [DEBUG] ReadFlash timing: 262144 bytes in 22772ms
        [01:04:10] [DEBUG]   Data rate: 0.01 MB/s (11512 B/s)
        [01:04:10] [DEBUG]   Packet latency: min=348ms, max=358ms, avg=355.8ms
        [01:04:10] [DEBUG]   Packets received: 64

       ESP32-C6
        [01:05:00] [DEBUG] ReadFlash timing: 262144 bytes in 841ms
        [01:05:00] [DEBUG]   Data rate: 0.30 MB/s (311705 B/s)
        [01:05:00] [DEBUG]   Packet latency: min=13ms, max=14ms, avg=13.1ms
        [01:05:00] [DEBUG]   Packets received: 64

       ESP32-S3
        [01:06:29] [DEBUG] ReadFlash timing: 262144 bytes in 22762ms
        [01:06:29] [DEBUG]   Data rate: 0.01 MB/s (11517 B/s)
        [01:06:29] [DEBUG]   Packet latency: min=350ms, max=356ms, avg=355.6ms
        [01:06:29] [DEBUG]   Packets received: 64

     */
    async readFlashPlain(address, totalLength = 0x1000, cbr) {
        let blockSize = Math.min(totalLength, 0x1000);
        let maxInFlight = Math.min(totalLength, blockSize * 2);
        const packetCount = totalLength / blockSize;

        let packet = 0;
        let lastAckedLength = 0;
        var data = new Uint8Array(0);
        var lastDataTime = Date.now();

        /* Timing measurements */
        const readStartTime = Date.now();
        let packetLatencies = [];
        let lastPacketTime = readStartTime;
        let totalBytesReceived = 0;

        if (this.devMode) {
            this.logDebug(`[ReadFlashPlain] Starting ReadFlash:`, { address: `0x${address.toString(16)}`, length: totalLength, sectorSize: blockSize, packets: packetCount, maxInFlight: maxInFlight });
        }

        return this.executeCommand(
            this.buildCommandPacketU32(READ_FLASH, address, totalLength, blockSize, maxInFlight),
            async () => {
                packet = 0;
            },
            async (resolve, reject, rawData) => {
                const currentTime = Date.now();
                lastDataTime = currentTime;

                if (data.length == totalLength) {
                    if (rawData.length == 16) {
                        /* Calculate MD5 of received data */
                        const calculatedMD5 = this.calculateMD5(data);

                        /* Convert received MD5 bytes to hex string */
                        const receivedMD5 = Array.from(rawData)
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');

                        /* Compare MD5 hashes */
                        if (calculatedMD5.toLowerCase() === receivedMD5.toLowerCase()) {
                            /* Calculate and log timing statistics */
                            const totalTime = currentTime - readStartTime;
                            const dataRate = totalBytesReceived / (totalTime / 1000);
                            const avgLatency = packetLatencies.length > 0
                                ? packetLatencies.reduce((a, b) => a + b, 0) / packetLatencies.length
                                : 0;
                            const minLatency = packetLatencies.length > 0
                                ? Math.min(...packetLatencies)
                                : 0;
                            const maxLatency = packetLatencies.length > 0
                                ? Math.max(...packetLatencies)
                                : 0;

                            if (this.devMode) {
                                this.logDebug(`ReadFlash timing: ${totalBytesReceived} bytes in ${totalTime}ms`);
                                this.logDebug(`  Data rate: ${(dataRate / 1024 / 1024).toFixed(2)} MB/s (${dataRate.toFixed(0)} B/s)`);
                                this.logDebug(`  Packet latency: min=${minLatency}ms, max=${maxLatency}ms, avg=${avgLatency.toFixed(1)}ms`);
                                this.logDebug(`  Packets received: ${packetLatencies.length}`);
                            }

                            resolve(data);
                        } else {
                            const error = `MD5 mismatch! Expected: ${receivedMD5}, Got: ${calculatedMD5}`;
                            this.logError(error);
                            reject(new Error(error));
                        }
                    } else {
                        const error = `Unknown response length for MD5! Expected: 16, Got: ${rawData.length}`;
                        this.logError(error);
                        reject(new Error(error));
                    }
                } else {
                    /* Track packet latency */
                    const packetLatency = currentTime - lastPacketTime;
                    packetLatencies.push(packetLatency);
                    lastPacketTime = currentTime;
                    totalBytesReceived += rawData.length;

                    /* Append rawData to accumulated data */
                    const newData = new Uint8Array(data.length + rawData.length);
                    newData.set(data);
                    newData.set(rawData, data.length);
                    data = newData;
                    packet++;

                    /* Prepare response */
                    if (data.length >= (lastAckedLength + maxInFlight) || (data.length >= totalLength)) {

                        /* Encode and write response */
                        var resp = new Uint8Array(4);
                        resp[0] = (data.length >> 0) & 0xFF;
                        resp[1] = (data.length >> 8) & 0xFF;
                        resp[2] = (data.length >> 16) & 0xFF;
                        resp[3] = (data.length >> 24) & 0xFF;

                        await this._writeFrame(this.slipLayer.encode(resp));

                        /* move last acked length further */
                        lastAckedLength = Math.min(lastAckedLength + maxInFlight, totalLength);
                    }

                    /* Call progress callback */
                    if (cbr) {
                        cbr(data.length, totalLength);
                    }
                }
            },
            500,
            /* Timeout condition: if the last raw data callback was more than a second ago */
            () => {
                const timeSinceLastData = Date.now() - lastDataTime;
                const hasTimedOut = timeSinceLastData > 1000;
                if (hasTimedOut) {
                    this.logError(`[ReadFlashPlain] TIMEOUT CHECK: timeSinceLastData=${timeSinceLastData}ms, triggering timeout`);
                }
                return hasTimedOut;
            }
        );
    }

    /**
     * Calculate MD5 checksum of flash region
     * @async
     * @param {number} address - Start address
     * @param {number} length - Number of bytes
     * @returns {Promise<string>} MD5 hash (hex)
     * @throws {Error} If checksum fails
     */
    async checksumFlash(address, length) {
        return this.executeCommand(
            this.buildCommandPacketU32(SPI_FLASH_MD5, address, length, 0, 0),
            async (resolve, reject, responsePacket) => {
                /* MD5 response is in the data field */
                if (responsePacket && responsePacket.data) {
                    /* Convert data bytes to hex string */
                    const md5 = Array.from(responsePacket.data.slice(0, 16))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');
                    resolve(md5);
                } else {
                    reject('No MD5 data received');
                }
            },
            async (resolve, reject, rawData) => {
                /* Handle raw data response if it comes this way */
                const decoder = new TextDecoder('utf-8');
                const md5String = decoder.decode(rawData);
                resolve(md5String.trim());
            },
            1000 + length / 500 // Timeout based on length
        );
    }

    /**
     * Calculate local MD5 hash
     * @param {Uint8Array|string} data - Data to hash
     * @returns {string} MD5 hash (hex)
     */
    calculateMD5(data) {
        /* Create MD5 hash using the Md5 class */
        const md5 = new this.Md5();
        md5.update(data);
        return md5.hex();
    }

    /**
     * Read flash with comprehensive MD5 verification
     * @async
     * @param {number} address - Source address
     * @param {number} size - Number of bytes
     * @param {Function} [progressCallback] - Callback(read, total, stage)
     * @returns {Promise<Uint8Array>} Verified data
     * @throws {Error} If read/verification fails
     */
    async readFlash(address, size, progressCallback) {
        var blockSize = 64 * 0x1000;

        if (this.port instanceof WebUSBSerial) {
            blockSize = (this.port.maxTransferSize - 2) / 2; /* remove 2 bytes for SLIP overhead, divide by 2 because 0xC0 gets potentially escaped */
        }

        try {
            /* Step 1: Read data in blocks */
            this.logDebug(`ReadFlashSafe: Reading ${size} bytes in ${blockSize}-byte blocks...`);
            const allData = new Uint8Array(size);
            let offset = 0;

            while (offset < size) {
                const readSize = Math.min(blockSize, size - offset);
                let cbr = (read, readBlockSize) => {
                    progressCallback && progressCallback(offset + read, size, 'reading');
                }
                const blockData = await this.readFlashPlain(address + offset, readSize, cbr);

                /* Copy block to buffer */
                allData.set(blockData.slice(0, readSize), offset);
                offset += readSize;

                /* Call progress callback */
                progressCallback && progressCallback(offset, size, 'reading');

                if (this.devMode) {
                    this.logDebug(`ReadFlashSafe: Read ${offset}/${size} bytes (${Math.round((offset / size) * 100)}%)`);
                }
            }

            /* Step 2: Calculate MD5 of read data */
            progressCallback && progressCallback(size, size, 'calc MD5 of input');
            this.logDebug(`ReadFlashSafe: Calculating MD5 of read data...`);
            const actualMD5 = await this.calculateMD5(allData);
            this.logDebug(`Actual MD5: ${actualMD5}`);

            /* Step 3: Get expected MD5 from flash */
            progressCallback && progressCallback(size, size, 'calc MD5 onchip');

            this.logDebug(`ReadFlashSafe: Calculating expected MD5 for ${size} bytes at 0x${address.toString(16).padStart(8, '0')}...`);
            const expectedMD5 = await this.checksumFlash(address, size);
            this.logDebug(`Expected MD5: ${expectedMD5}`);

            /* Step 4: Compare MD5 hashes */
            if (expectedMD5.toLowerCase() !== actualMD5.toLowerCase()) {
                this.logError(`ReadFlashSafe FAILED: MD5 mismatch!`);
                this.logError(`  Expected: ${expectedMD5}`);
                this.logError(`  Actual:   ${actualMD5}`);
                throw new Error(`MD5 verification failed: expected ${expectedMD5}, got ${actualMD5}`);
            }

            this.logDebug(`ReadFlashSafe: MD5 verification passed `);
            return allData;

        } catch (error) {
            this.logError(`ReadFlashSafe failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * Write flash with MD5 verification
     * @async
     * @param {number} address - Target address
     * @param {Uint8Array} data - Data to write
     * @param {Function} [progressCbr] - Callback(written, total, stage)
     * @returns {Promise<Object>} {success: boolean, md5: string}
     * @throws {Error} If write/verification fails
     */
    async writeFlash(address, data, progressCbr) {
        try {
            /* Step 1: Write data to flash */
            this.logDebug(`WriteFlashSafe: Writing ${data.length} bytes to 0x${address.toString(16).padStart(8, '0')}...`);
            await this.writeFlashPlain(address, data, (offset, total) => {
                progressCbr && progressCbr(offset, total, 'Writing');
            });
            this.logDebug(`WriteFlashSafe: Write complete`);

            /* Step 2: Calculate MD5 of input data */
            progressCbr && progressCbr(data.length, data.length, 'Calculating MD5 of input');
            this.logDebug(`WriteFlashSafe: Calculating MD5 of ${data.length} bytes to write...`);
            const expectedMD5 = this.calculateMD5(data);
            this.logDebug(`Input data MD5: ${expectedMD5}`);

            /* Step 3: Get MD5 from device */
            progressCbr && progressCbr(data.length, data.length, 'Calculating MD5 on device');
            this.logDebug(`WriteFlashSafe: Calculating MD5 on device for verification...`);
            const deviceMD5 = await this.checksumFlash(address, data.length);
            this.logDebug(`Device MD5: ${deviceMD5}`);

            /* Step 4: Compare MD5 hashes */
            if (expectedMD5.toLowerCase() !== deviceMD5.toLowerCase()) {
                this.logError(`WriteFlashSafe FAILED: MD5 mismatch!`);
                this.logError(`  Expected: ${expectedMD5}`);
                this.logError(`  Device:   ${deviceMD5}`);
                throw new Error(`MD5 verification failed after write: expected ${expectedMD5}, got ${deviceMD5}`);
            }

            this.logDebug(`WriteFlashSafe: MD5 verification passed `);

            progressCbr && progressCbr(data.length, data.length, expectedMD5, 'Verified');

            return { success: true, md5: expectedMD5 };

        } catch (error) {
            this.logError(`WriteFlashSafe failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * Check if flash memory is erased
     * @async
     * @param {Function} [cbr] - Progress callback
     * @returns {Promise<void>}
     */
    async blankCheck(startAddress = 0x000000, endAddress = 0x800000, cbr = null) {
        const blockSize = 0x1000;

        let totalReads = 0;
        let totalTime = 0;
        let erasedBytesTotal = 0;
        let currentAddress = startAddress;

        while (currentAddress < endAddress) {

            try {
                const startTime = Date.now();
                var rawData = await this.readFlashPlain(currentAddress, blockSize);
                const endTimeRead = Date.now();
                const readDuration = endTimeRead - startTime;

                var erasedBytes = 0;
                for (var pos = 0; pos < rawData.length; pos++) {
                    if (rawData[pos] == 0xFF) {
                        erasedBytes++;
                    }
                }

                currentAddress += rawData.length;
                erasedBytesTotal += erasedBytes;
                totalTime += readDuration;
                totalReads++;

                cbr && cbr(currentAddress, startAddress, endAddress, blockSize, erasedBytes, erasedBytesTotal);
            } catch (error) {
                this.logError(`Read failed due to an error`, `${error.message}`);
                this.disconnect();
                break;
            }
        }

        if (totalReads > 0) {
            const averageTime = totalTime / totalReads;
            this.logDebug(`Average read time: ${averageTime.toFixed(2)} ms over ${totalReads} reads.`);
        }
    }

    /**
     * Write/Read stress test
     * @async
     * @param {number} address - Test address
     * @param {number} size - Test data size
     * @param {Function} [cbr] - Progress callback
     * @returns {Promise<Object>} Test result
     * @throws {Error} On critical failure
     */
    async writeReadTest(address, size, cbr) {
        try {
            /* Step 1: Read original data */
            this.logDebug(`Test: Reading original ${size} bytes from 0x${address.toString(16).padStart(8, '0')}...`);
            cbr && cbr('reading_original', 0, 3);
            const originalData = await this.readFlashPlain(address, size);
            this.logDebug(`Original data read complete`);

            /* Hexdump original data (first 64 bytes) */
            const dumpSize = Math.min(64, size);
            this.logDebug(`Original data hexdump (first ${dumpSize} bytes):`);
            for (let i = 0; i < dumpSize; i += 16) {
                const chunk = originalData.slice(i, i + 16);
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                const ascii = Array.from(chunk).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
                this.logDebug(`  ${(address + i).toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`);
            }

            /* Step 2: Generate random data */
            this.logDebug(`Test: Generating ${size} bytes of random data...`);
            cbr && cbr('generating_random', 1, 3);
            const randomData = new Uint8Array(size);
            for (let i = 0; i < size; i++) {
                randomData[i] = Math.floor(Math.random() * 256);
            }
            this.logDebug(`Random data generated`);

            /* Hexdump random data (first 64 bytes) */
            this.logDebug(`Random data hexdump (first ${dumpSize} bytes):`);
            for (let i = 0; i < dumpSize; i += 16) {
                const chunk = randomData.slice(i, i + 16);
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                const ascii = Array.from(chunk).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
                this.logDebug(`  ${(address + i).toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`);
            }

            /* Step 3: Write random data to flash */
            this.logDebug(`Test: Writing ${size} bytes to flash at 0x${address.toString(16).padStart(8, '0')}...`);
            cbr && cbr('writing', 2, 3);
            await this.writeFlashPlain(address, randomData, (offset, total) => {
                const percent = Math.round((offset / total) * 100);
                cbr && cbr('writing', 2, 3, percent);
            });
            this.logDebug(`Write complete`);

            /* Step 4: Read back the data */
            this.logDebug(`Test: Reading back ${size} bytes from 0x${address.toString(16).padStart(8, '0')}...`);
            cbr && cbr('reading_back', 3, 3);
            const readbackData = await this.readFlashPlain(address, size);
            this.logDebug(`Readback complete`);

            /* Hexdump readback data (first 64 bytes) */
            this.logDebug(`Readback data hexdump (first ${dumpSize} bytes):`);
            for (let i = 0; i < dumpSize; i += 16) {
                const chunk = readbackData.slice(i, i + 16);
                const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                const ascii = Array.from(chunk).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
                this.logDebug(`  ${(address + i).toString(16).padStart(8, '0')}: ${hex.padEnd(47, ' ')} |${ascii}|`);
            }

            /* Step 5: Verify data matches */
            let errors = 0;
            let firstError = -1;
            for (let i = 0; i < size; i++) {
                if (randomData[i] !== readbackData[i]) {
                    if (firstError === -1) {
                        firstError = i;
                    }
                    errors++;
                }
            }

            const result = {
                success: errors === 0,
                errors: errors,
                firstError: firstError,
                address: address,
                size: size,
                originalData: originalData,
                randomData: randomData,
                readbackData: readbackData
            };

            if (errors === 0) {
                this.logDebug(` Test PASSED: All ${size} bytes match!`);
            } else {
                this.logError(` Test FAILED: ${errors} byte(s) mismatch!`);
                this.logError(`  First error at offset 0x${firstError.toString(16).padStart(4, '0')} (byte ${firstError})`);
                this.logError(`  Expected: 0x${randomData[firstError].toString(16).padStart(2, '0')}, Got: 0x${readbackData[firstError].toString(16).padStart(2, '0')}`);
            }

            cbr && cbr('complete', 3, 3, 100, result);
            return result;

        } catch (error) {
            this.logError(`Write/Read test failed: ${error.message}`);
            cbr && cbr('error', 0, 3, 0, { success: false, error: error.message });
            throw error;
        }
    }

    /**
     * Build command packet with 32-bit arguments
     * @param {number} command - Command code
     * @param {...(number|Uint8Array)} values - Arguments
     * @returns {Object} {command, payload: Uint8Array}
     */
    buildCommandPacketU32(command, ...values) {
        /* Calculate total length for data */
        let totalLength = 0;
        values.forEach(value => {
            if (typeof value === 'number') {
                totalLength += 4; // uint32 is 4 bytes
            } else if (value instanceof Uint8Array) {
                totalLength += value.length;
            }
        });

        /* Convert each uint32_t to little-endian bytes or append byte arrays */
        const data = new Uint8Array(totalLength);
        let offset = 0;
        values.forEach(value => {
            if (typeof value === 'number') {
                data[offset] = (value >> 0) & 0xFF;
                data[offset + 1] = (value >> 8) & 0xFF;
                data[offset + 2] = (value >> 16) & 0xFF;
                data[offset + 3] = (value >> 24) & 0xFF;
                offset += 4;
            } else if (value instanceof Uint8Array) {
                data.set(value, offset);
                offset += value.length;
            }
        });

        /* Call the original function with the constructed data */
        return this.buildCommandPacket(command, data);
    }

    /**
     * Build raw command packet
     * @param {number} command - Command code
     * @param {Uint8Array} data - Payload
     * @returns {Object} {command, payload: Uint8Array}
     */
    buildCommandPacket(command, data) {
        /* Construct command packet */
        const direction = 0x00;
        const size = data.length;
        let checksum = 0;

        if (size > 32) {
            checksum = 0xEF;
            for (let index = 16; index < size; index++) {
                checksum ^= data[index];
            }
        }

        const packet = new Uint8Array(8 + size);
        packet[0] = direction;
        packet[1] = command;
        packet[2] = size & 0xff;
        packet[3] = (size >> 8) & 0xff;
        packet[4] = checksum & 0xff;
        packet[5] = (checksum >> 8) & 0xff;
        packet[6] = (checksum >> 16) & 0xff;
        packet[7] = (checksum >> 24) & 0xff;
        packet.set(data, 8);

        var ret = {};

        ret.command = command;
        ret.payload = packet;

        return ret;
    }

    /**
     * Debug dump packet to console
     * @param {Object} pkt - Parsed packet
     */
    dumpPacket(pkt) {
        if (!this.devMode) {
            return;
        }

        /* Log command execution with parameters */
        const commandNames = {
            0x02: 'FLASH_BEGIN', 0x03: 'FLASH_DATA', 0x04: 'FLASH_END',
            0x05: 'MEM_BEGIN', 0x06: 'MEM_END', 0x07: 'MEM_DATA',
            0x08: 'SYNC', 0x09: 'WRITE_REG', 0x0a: 'READ_REG',
            0x0b: 'SPI_SET_PARAMS', 0x0d: 'SPI_ATTACH', 0x0f: 'CHANGE_BAUDRATE',
            0x10: 'FLASH_DEFL_BEGIN', 0x11: 'FLASH_DEFL_DATA', 0x12: 'FLASH_DEFL_END',
            0x13: 'SPI_FLASH_MD5', 0x14: 'GET_SECURITY_INFO',
            0xd0: 'ERASE_FLASH', 0xd1: 'ERASE_REGION', 0xd2: 'READ_FLASH', 0xd3: 'RUN_USER_CODE'
        };
        const cmdName = commandNames[packet.command] || `0x${packet.command.toString(16)}`;
        this.logDebug(`[CMD] ${cmdName} (0x${packet.command.toString(16).padStart(2, '0')})`, 'params:', pkt);

        if (pkt.dir == 0) {
            this.logDebug(`Command: `, pkt);
            this.logDebug(`Command raw: ${Array.from(pkt.raw).map(byte => byte.toString(16).padStart(2, '0')).join(' ')}`);
        }
        if (pkt.dir == 1) {
            this.logDebug(`Response: `, pkt);
            this.logDebug(`Response raw: ${Array.from(pkt.raw).map(byte => byte.toString(16).padStart(2, '0')).join(' ')}`);
        }
    }

    /**
     * Parse raw packet bytes
     * @param {Uint8Array} packet - Raw packet data
     * @returns {Object|null} Parsed packet or null if invalid
     */
    parsePacket(packet) {
        var pkt = {};

        pkt.dir = packet[0];
        pkt.command = packet[1];
        pkt.size = packet[2] | (packet[3] << 8);
        pkt.value = (packet[4] | (packet[5] << 8) | (packet[6] << 16) | (packet[7] << 24)) >>> 0;

        if (pkt.dir > 2 || packet.length != 8 + pkt.size) {
            return null;
        }
        pkt.data = packet.slice(8, 8 + pkt.size);
        pkt.raw = packet;

        return pkt;
    }

    /**
     * Process received packet
     * @async
     * @param {Uint8Array} packet - Raw packet bytes
     * @returns {Promise<void>}
     */
    async processPacket(packet) {
        var pkt = this.parsePacket(packet);

        if (pkt && pkt.dir === 0x01) {
            this.dumpPacket(pkt);
            /* Call response handler if registered */
            if (this.responseHandlers.has(pkt.command)) {
                var handler = this.responseHandlers.get(pkt.command);
                await handler(pkt);
            }
        } else {
            //this.logDebug(`Received raw SLIP: ${ Array.from(packet).map(byte => byte.toString(16).padStart(2, '0')).join(' ') }`);

            if (this.responseHandlers.has(-1)) {
                var handler = this.responseHandlers.get(-1);
                await handler(packet);
            }
        }
    }

    /* ==================== MD5 Hash Implementation ==================== */
    /**
     * MD5 Hash Implementation (from js-md5 library)
     * Standalone client-side hashing for data verification
     */
    Md5 = (function () {
        const ARRAY_BUFFER = typeof ArrayBuffer !== 'undefined';
        const HEX_CHARS = '0123456789abcdef'.split('');
        const EXTRA = [128, 32768, 8388608, -2147483648];
        const SHIFT = [0, 8, 16, 24];
        const FINALIZE_ERROR = 'finalize already called';

        let blocks = [], buffer8;
        if (ARRAY_BUFFER) {
            const buffer = new ArrayBuffer(68);
            buffer8 = new Uint8Array(buffer);
            blocks = new Uint32Array(buffer);
        }

        function formatMessage(message) {
            if (typeof message === 'string') {
                return [message, true];
            }
            if (message instanceof ArrayBuffer) {
                return [new Uint8Array(message), false];
            }
            if (message.constructor === Uint8Array || message.constructor === Array) {
                return [message, false];
            }
            return [message, false];
        }

        /**
         * Md5 class
         * @class Md5
         * @description This is internal class.
         * @see {@link md5.create}
         */
        function Md5(sharedMemory) {
            if (sharedMemory) {
                blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                    blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                    blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                    blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                this.blocks = blocks;
                this.buffer8 = buffer8;
            } else {
                if (ARRAY_BUFFER) {
                    var buffer = new ArrayBuffer(68);
                    this.buffer8 = new Uint8Array(buffer);
                    this.blocks = new Uint32Array(buffer);
                } else {
                    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                }
            }
            this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
            this.finalized = this.hashed = false;
            this.first = true;
        }

        /**
         * from https://www.npmjs.com/package/js-md5
         * @method update
         * @memberof Md5
         * @instance
         * @description Update hash
         * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
         * @returns {Md5} Md5 object.
         * @see {@link md5.update}
         */
        Md5.prototype.update = function (message) {
            if (this.finalized) {
                throw new Error(FINALIZE_ERROR);
            }

            var result = formatMessage(message);
            message = result[0];
            var isString = result[1];
            var code, index = 0, i, length = message.length, blocks = this.blocks;
            var buffer8 = this.buffer8;

            while (index < length) {
                if (this.hashed) {
                    this.hashed = false;
                    blocks[0] = blocks[16];
                    blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                }

                if (isString) {
                    if (ARRAY_BUFFER) {
                        for (i = this.start; index < length && i < 64; ++index) {
                            code = message.charCodeAt(index);
                            if (code < 0x80) {
                                buffer8[i++] = code;
                            } else if (code < 0x800) {
                                buffer8[i++] = 0xc0 | (code >>> 6);
                                buffer8[i++] = 0x80 | (code & 0x3f);
                            } else if (code < 0xd800 || code >= 0xe000) {
                                buffer8[i++] = 0xe0 | (code >>> 12);
                                buffer8[i++] = 0x80 | ((code >>> 6) & 0x3f);
                                buffer8[i++] = 0x80 | (code & 0x3f);
                            } else {
                                code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
                                buffer8[i++] = 0xf0 | (code >>> 18);
                                buffer8[i++] = 0x80 | ((code >>> 12) & 0x3f);
                                buffer8[i++] = 0x80 | ((code >>> 6) & 0x3f);
                                buffer8[i++] = 0x80 | (code & 0x3f);
                            }
                        }
                    } else {
                        for (i = this.start; index < length && i < 64; ++index) {
                            code = message.charCodeAt(index);
                            if (code < 0x80) {
                                blocks[i >>> 2] |= code << SHIFT[i++ & 3];
                            } else if (code < 0x800) {
                                blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                            } else if (code < 0xd800 || code >= 0xe000) {
                                blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                            } else {
                                code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
                                blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];
                                blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                            }
                        }
                    }
                } else {
                    if (ARRAY_BUFFER) {
                        for (i = this.start; index < length && i < 64; ++index) {
                            buffer8[i++] = message[index];
                        }
                    } else {
                        for (i = this.start; index < length && i < 64; ++index) {
                            blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];
                        }
                    }
                }
                this.lastByteIndex = i;
                this.bytes += i - this.start;
                if (i >= 64) {
                    this.start = i - 64;
                    this.hash();
                    this.hashed = true;
                } else {
                    this.start = i;
                }
            }
            if (this.bytes > 4294967295) {
                this.hBytes += this.bytes / 4294967296 << 0;
                this.bytes = this.bytes % 4294967296;
            }
            return this;
        };

        /**
         * Finalize hash computation
         * @method finalize
         * @memberof Md5
         * @description Pads message and performs final hash operations
         */
        Md5.prototype.finalize = function () {
            if (this.finalized) {
                return;
            }
            this.finalized = true;
            var blocks = this.blocks, i = this.lastByteIndex;
            blocks[i >>> 2] |= EXTRA[i & 3];
            if (i >= 56) {
                if (!this.hashed) {
                    this.hash();
                }
                blocks[0] = blocks[16];
                blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                    blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                    blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                    blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            }
            blocks[14] = this.bytes << 3;
            blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
            this.hash();
        };

        /**
         * Internal hash computation round
         * @method hash
         * @memberof Md5
         * @description Performs one MD5 hash block computation
         */
        Md5.prototype.hash = function () {
            var a, b, c, d, bc, da, blocks = this.blocks;

            if (this.first) {
                a = blocks[0] - 680876937;
                a = (a << 7 | a >>> 25) - 271733879 << 0;
                d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
                d = (d << 12 | d >>> 20) + a << 0;
                c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;
                c = (c << 17 | c >>> 15) + d << 0;
                b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;
                b = (b << 22 | b >>> 10) + c << 0;
            } else {
                a = this.h0;
                b = this.h1;
                c = this.h2;
                d = this.h3;
                a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;
                a = (a << 7 | a >>> 25) + b << 0;
                d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;
                d = (d << 12 | d >>> 20) + a << 0;
                c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;
                c = (c << 17 | c >>> 15) + d << 0;
                b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;
                b = (b << 22 | b >>> 10) + c << 0;
            }

            a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;
            b = (b << 20 | b >>> 12) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[5] - 378558;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[8] - 2022574463;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[11] + 1839030562;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[14] - 35309556;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[1] - 1530992060;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[4] + 1272893353;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[7] - 155497632;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[10] - 1094730640;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[13] + 681279174;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[0] - 358537222;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[3] - 722521979;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[6] + 76029189;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[9] - 640364487;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[12] - 421815835;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[15] + 530742520;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[2] - 995338651;
            b = (b << 23 | b >>> 9) + c << 0;
            a += (c ^ (b | ~d)) + blocks[0] - 198630844;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[5] - 57434055;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[10] - 1051523;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[15] - 30611744;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[4] - 145523070;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[2] + 718787259;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[9] - 343485551;
            b = (b << 21 | b >>> 11) + c << 0;

            if (this.first) {
                this.h0 = a + 1732584193 << 0;
                this.h1 = b - 271733879 << 0;
                this.h2 = c - 1732584194 << 0;
                this.h3 = d + 271733878 << 0;
                this.first = false;
            } else {
                this.h0 = this.h0 + a << 0;
                this.h1 = this.h1 + b << 0;
                this.h2 = this.h2 + c << 0;
                this.h3 = this.h3 + d << 0;
            }
        };

        /**
         * @method hex
         * @memberof Md5
         * @instance
         * @description Output hash as hex string
         * @returns {String} Hex string
         * @see {@link md5.hex}
         * @example
         * hash.hex();
         */
        Md5.prototype.hex = function () {
            this.finalize();

            var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;

            return HEX_CHARS[(h0 >>> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
                HEX_CHARS[(h0 >>> 12) & 0x0F] + HEX_CHARS[(h0 >>> 8) & 0x0F] +
                HEX_CHARS[(h0 >>> 20) & 0x0F] + HEX_CHARS[(h0 >>> 16) & 0x0F] +
                HEX_CHARS[(h0 >>> 28) & 0x0F] + HEX_CHARS[(h0 >>> 24) & 0x0F] +
                HEX_CHARS[(h1 >>> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
                HEX_CHARS[(h1 >>> 12) & 0x0F] + HEX_CHARS[(h1 >>> 8) & 0x0F] +
                HEX_CHARS[(h1 >>> 20) & 0x0F] + HEX_CHARS[(h1 >>> 16) & 0x0F] +
                HEX_CHARS[(h1 >>> 28) & 0x0F] + HEX_CHARS[(h1 >>> 24) & 0x0F] +
                HEX_CHARS[(h2 >>> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
                HEX_CHARS[(h2 >>> 12) & 0x0F] + HEX_CHARS[(h2 >>> 8) & 0x0F] +
                HEX_CHARS[(h2 >>> 20) & 0x0F] + HEX_CHARS[(h2 >>> 16) & 0x0F] +
                HEX_CHARS[(h2 >>> 28) & 0x0F] + HEX_CHARS[(h2 >>> 24) & 0x0F] +
                HEX_CHARS[(h3 >>> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
                HEX_CHARS[(h3 >>> 12) & 0x0F] + HEX_CHARS[(h3 >>> 8) & 0x0F] +
                HEX_CHARS[(h3 >>> 20) & 0x0F] + HEX_CHARS[(h3 >>> 16) & 0x0F] +
                HEX_CHARS[(h3 >>> 28) & 0x0F] + HEX_CHARS[(h3 >>> 24) & 0x0F];
        };
        return Md5;
    })();
}

/* CommonJS export for Node.js */
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ESPFlasher;
}
    </script>
    <script>
/* Inlined from esp32-parser.js */
// ESP32 Firmware Parser JavaScript Implementation
// Based on the C implementation from esp32.c

/**
 * SparseImage - Abstraction layer for accessing binary data with caching
 * Acts like a Uint8Array but lazily loads data from a device/source through a callback
 * 
 * Use cases:
 * 1. Reading from slow devices (e.g., flash memory over serial)
 * 2. Working with large files where only portions are needed
 * 3. Caching frequently accessed regions
 * 
 * Example usage:
 * ```javascript
 * // Create a SparseImage with a read callback
 * const sparseImage = new SparseImage(1024 * 1024, (address, size) => {
 *     // This callback is called when data is not in cache
 *     // Read from your device here
 *     return deviceRead(address, size); // Should return Uint8Array
 * });
 * 
 * // Wrap in proxy for array-like access
 * const buffer = SparseImage._createProxy(sparseImage);
 * 
 * // Access like a normal Uint8Array - data is fetched automatically
 * const byte = buffer[0x1000];
 * const chunk = buffer.subarray(0x1000, 0x2000);
 * ```
 * 
 * Architecture:
 * - ReadBuffer: Array of {address, data} segments containing cached read data
 * - ReadData callback: Called to fetch missing data from device/source
 * - Automatic merging: Adjacent/overlapping segments are merged to optimize memory
 * 
 * Future enhancement:
 * - WriteBuffer: Parallel buffer for tracking writes before committing to device
 *   - Reads check WriteBuffer first, then ReadBuffer
 *   - Allows batching writes and deferred commit operations
 */
class SparseImage {
    constructor(size, readDataCallback = null, writeDataCallback = null, flushPrepareCallback = null, sectorSize = 0x1000) {
        this.size = size;
        this.readDataCallback = readDataCallback;
        this.writeDataCallback = writeDataCallback;
        this.flushPrepareCallback = flushPrepareCallback;
        this.sectorSize = sectorSize || 0x1000;
        this.readBuffer = []; // Array of {address, data} structures
        this.writeBuffer = []; // Array of {address, data} structures
        this.length = size;
        /* Lock to ensure _ensureData executes serially */
        this._ensureDataLock = Promise.resolve();

        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    /**
     * Initialize from an existing ArrayBuffer/Uint8Array
     */
    static fromBuffer(arrayBuffer, sectorSize = 0x1000) {
        const buffer = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
        const sparseImage = new SparseImage(buffer.length, null, null, null, sectorSize);
        sparseImage.readBuffer.push({
            address: 0,
            data: buffer
        });
        return sparseImage;
    }

    /**
     * Find which buffer segment contains the given address
     */
    _findSegment(address, list = this.readBuffer) {
        for (const segment of list) {
            const endAddress = segment.address + segment.data.length;
            if (address >= segment.address && address < endAddress) {
                return segment;
            }
        }
        return null;
    }

    /**
     * Check if a range is fully covered by existing segments
     */
    _isRangeCovered(address, size, list = this.readBuffer) {
        let checkPos = address;
        const endAddress = address + size;

        while (checkPos < endAddress) {
            const segment = this._findSegment(checkPos, list);
            if (!segment) {
                return false;
            }
            checkPos = segment.address + segment.data.length;
        }
        return true;
    }

    /**
     * Check if a range is covered by either write or read buffers
     */
    _isRangeCoveredAny(address, size) {
        let checkPos = address;
        const endAddress = address + size;
        while (checkPos < endAddress) {
            const w = this._findSegment(checkPos, this.writeBuffer);
            if (w) {
                checkPos = Math.min(endAddress, w.address + w.data.length);
                continue;
            }
            const r = this._findSegment(checkPos, this.readBuffer);
            if (r) {
                checkPos = Math.min(endAddress, r.address + r.data.length);
                continue;
            }
            return false;
        }
        return true;
    }

    /**
     * Find the first gap within [address, address+size) not covered by write/read buffers.
     * Returns { start, size } or null if fully covered.
     */
    _findFirstGapRange(address, size) {
        const endAddress = address + size;
        let pos = address;
        while (pos < endAddress) {
            const w = this._findSegment(pos, this.writeBuffer);
            if (w) {
                pos = Math.min(endAddress, w.address + w.data.length);
                continue;
            }
            const r = this._findSegment(pos, this.readBuffer);
            if (r) {
                pos = Math.min(endAddress, r.address + r.data.length);
                continue;
            }
            /* pos is not covered: determine gap end at next segment start or endAddress */
            let nextStart = endAddress;
            for (const s of this.writeBuffer) {
                if (s.address > pos && s.address < nextStart) nextStart = s.address;
            }
            for (const s of this.readBuffer) {
                if (s.address > pos && s.address < nextStart) nextStart = s.address;
            }
            return { start: pos, size: nextStart - pos };
        }
        return null;
    }

    _mergeSegmentsGeneric(list) {
        if (list.length <= 1) return list;

        const indexed = list.map((segment, idx) => ({ ...segment, _idx: idx }));
        indexed.sort((a, b) => {
            if (a.address === b.address) {
                return a._idx - b._idx;
            }
            return a.address - b.address;
        });

        const merged = [];
        let current = indexed[0];

        for (let i = 1; i < indexed.length; i++) {
            const next = indexed[i];
            const currentEnd = current.address + current.data.length;

            if (next.address <= currentEnd) {
                const mergedEnd = Math.max(currentEnd, next.address + next.data.length);
                const mergedSize = mergedEnd - current.address;
                const mergedData = new Uint8Array(mergedSize);
                mergedData.set(current.data, 0);
                const nextOffset = next.address - current.address;
                mergedData.set(next.data, nextOffset);
                current = {
                    address: current.address,
                    data: mergedData
                };
            } else {
                merged.push({ address: current.address, data: current.data });
                current = next;
            }
        }
        merged.push({ address: current.address, data: current.data });
        return merged;
    }

    /**
     * Merge adjacent or overlapping segments in the readBuffer
     */
    _mergeSegments() {
        this.readBuffer = this._mergeSegmentsGeneric(this.readBuffer);
    }

    _mergeWriteSegments() {
        this.writeBuffer = this._mergeSegmentsGeneric(this.writeBuffer);
    }

    _effectiveByte(pos) {
        const w = this._findSegment(pos, this.writeBuffer);
        if (w) return w.data[pos - w.address] & 0xFF;
        const r = this._findSegment(pos, this.readBuffer);
        if (r) return r.data[pos - r.address] & 0xFF;
        return 0xFF;
    }

    _materializeRange(start, end) {
        const len = end - start;
        const out = new Uint8Array(len);
        out.fill(0xFF);

        for (const seg of this.readBuffer) {
            const s0 = seg.address;
            const s1 = seg.address + seg.data.length;
            const o0 = Math.max(start, s0);
            const o1 = Math.min(end, s1);
            if (o0 < o1) {
                const dstOff = o0 - start;
                const srcOff = o0 - s0;
                out.set(seg.data.subarray(srcOff, srcOff + (o1 - o0)), dstOff);
            }
        }

        for (const seg of this.writeBuffer) {
            const s0 = seg.address;
            const s1 = seg.address + seg.data.length;
            const o0 = Math.max(start, s0);
            const o1 = Math.min(end, s1);
            if (o0 < o1) {
                const dstOff = o0 - start;
                const srcOff = o0 - s0;
                out.set(seg.data.subarray(srcOff, srcOff + (o1 - o0)), dstOff);
            }
        }

        return out;
    }

    _materializeReadRange(start, end) {
        const len = end - start;
        const out = new Uint8Array(len);
        out.fill(0xFF);

        for (const seg of this.readBuffer) {
            const s0 = seg.address;
            const s1 = seg.address + seg.data.length;
            const o0 = Math.max(start, s0);
            const o1 = Math.min(end, s1);
            if (o0 < o1) {
                const dstOff = o0 - start;
                const srcOff = o0 - s0;
                out.set(seg.data.subarray(srcOff, srcOff + (o1 - o0)), dstOff);
            }
        }

        return out;
    }

    _addSegment(list, address, data) {
        list.push({ address, data });
        return this._mergeSegmentsGeneric(list);
    }

    /**
     * Read data from the sparse image, fetching from device if necessary
     */
    async _ensureData(address, size) {
        /* Acquire lock to ensure only one _ensureData executes at a time */
        const run = () => this._ensureDataUnlocked(address, size);
        this._ensureDataLock = this._ensureDataLock.then(run, run);
        return this._ensureDataLock;
    }

    /**
     * Internal _ensureData implementation (unlocked)
     * @private
     */
    async _ensureDataUnlocked(address, size) {
        if (address < 0 || address >= this.size) {
            throw new RangeError(`Address ${address} out of bounds [0, ${this.size})`);
        }

        // Clamp size to available data
        size = Math.min(size, this.size - address);

        // If range is already covered by write or read cache, nothing to do
        if (this._isRangeCoveredAny(address, size)) return;

        // Fill gaps: either by read callback (preferred) or zero-fill if no callback
        let safety = 64;
        while (!this._isRangeCoveredAny(address, size) && safety-- > 0) {
            const gap = this._findFirstGapRange(address, size);
            if (!gap || gap.size <= 0) break;

            if (!this.readDataCallback) {
                /* No callback - create zero segment only for the uncovered gap */
                const data = new Uint8Array(gap.size);
                this.readBuffer = this._addSegment(this.readBuffer, gap.start, data);
                continue;
            }

            /* Call the callback; it may return more/less and with its own base address */
            const res = await this.readDataCallback(gap.start, gap.size);
            let a = null;
            let d = null;
            if (res instanceof Uint8Array) {
                a = gap.start;
                d = res;
            } else if (res && res.buffer instanceof ArrayBuffer && res.byteLength !== undefined) {
                /* Accept ArrayBufferView-like */
                a = gap.start;
                d = new Uint8Array(res.buffer, res.byteOffset || 0, res.byteLength);
            } else if (res && typeof res === 'object') {
                const rAddr = res.address !== undefined ? res.address : gap.start;
                const rData = res.data;
                if (rData instanceof Uint8Array) {
                    a = rAddr;
                    d = rData;
                } else if (rData && rData.buffer instanceof ArrayBuffer && rData.byteLength !== undefined) {
                    a = rAddr;
                    d = new Uint8Array(rData.buffer, rData.byteOffset || 0, rData.byteLength);
                }
            }

            if (d && d.length > 0) {
                this.readBuffer = this._addSegment(this.readBuffer, a, d);
                // loop will re-check coverage
            } else {
                // No progress possible from callback, avoid infinite loop
                break;
            }
        }
    }

    write(address, data) {
        if (address < 0 || address >= this.size) {
            throw new RangeError(`Address ${address} out of bounds [0, ${this.size})`);
        }
        const normalized = data instanceof Uint8Array ? data : new Uint8Array(data);
        const start = address;
        const end = Math.min(address + normalized.length, this.size);
        if (end <= start) return;

        const fmtRanges = (list) => list.map(s => `[0x${s.address.toString(16)}-0x${(s.address + s.data.length).toString(16)})`).join(', ');
        const preRanges = fmtRanges(this.writeBuffer);
        // this.logDebug('SparseImage.write start', { address: start, length: normalized.length, preRanges });
        const sectorSize = this.sectorSize || 0x1000;
        const touchedSectors = new Set();

        /* Helper: find write buffer segment that covers pos */
        const findWriteSeg = (pos) => this._findSegment(pos, this.writeBuffer);

        /* Helper: find any cached segment (write preferred, then read) that covers pos */
        const findCachedSeg = (pos) => findWriteSeg(pos) || this._findSegment(pos, this.readBuffer);

        /* Helper: merge touching/overlapping segments after modifications */
        const mergeWrites = () => {
            this.writeBuffer = this._mergeSegmentsGeneric(this.writeBuffer);
        };

        /* Helper: mark sectors touched by a range */
        const markSectors = (rangeStart, rangeEnd) => {
            for (let s = Math.floor(rangeStart / sectorSize) * sectorSize; s < rangeEnd; s += sectorSize) {
                touchedSectors.add(s);
            }
        };

        /* Helper: compute next boundary where coverage changes */
        const nextBoundary = (pos, limit) => {
            let nb = limit;
            for (const s of [...this.readBuffer, ...this.writeBuffer]) {
                if (s.address > pos && s.address < nb) nb = s.address;
                const sEnd = s.address + s.data.length;
                if (sEnd > pos && sEnd < nb) nb = sEnd;
            }
            const sectorEnd = Math.min(limit, (Math.floor(pos / sectorSize) + 1) * sectorSize);
            if (sectorEnd > pos && sectorEnd < nb) nb = sectorEnd;
            return nb;
        };

        let pos = start;
        let remaining = end - start;

        while (remaining > 0) {
            /* Case 1: existing write buffer covers current position */
            const wseg = findWriteSeg(pos);
            if (wseg) {
                const offset = pos - wseg.address;
                const span = Math.min(remaining, wseg.data.length - offset);
                wseg.data.set(normalized.subarray(pos - start, pos - start + span), offset);
                markSectors(pos, pos + span);
                pos += span;
                remaining -= span;
                continue;
            }

            /* Case 2: cached (read) data covers current position */
            const cseg = findCachedSeg(pos);
            if (cseg) {
                const offset = pos - cseg.address;
                const span = Math.min(remaining, cseg.data.length - offset);

                /* Check matching prefix */
                let matchLen = 0;
                while (matchLen < span) {
                    const desired = normalized[pos - start + matchLen] & 0xFF;
                    if (cseg.data[offset + matchLen] !== desired) break;
                    matchLen++;
                }

                if (matchLen > 0) {
                    pos += matchLen;
                    remaining -= matchLen;
                    continue;
                }

                /* Mismatch: see if full sector is FULLY cached in readBuffer */
                const sectorStart = Math.floor(pos / sectorSize) * sectorSize;
                const sectorEnd = Math.min(sectorStart + sectorSize, this.size);
                if (this._isRangeCovered(sectorStart, sectorEnd - sectorStart, this.readBuffer)) {
                    const sectorBuf = this._materializeRange(sectorStart, sectorEnd);
                    const writeStart = pos;
                    const writeEnd = Math.min(end, sectorEnd);
                    sectorBuf.set(
                        normalized.subarray(writeStart - start, writeEnd - start),
                        writeStart - sectorStart
                    );
                    this.writeBuffer = this._addSegment(this.writeBuffer, sectorStart, sectorBuf);
                    markSectors(sectorStart, sectorEnd);
                    pos = writeEnd;
                    remaining = end - pos;
                    continue;
                }

                /* Not fully cached: create a new segment until the next boundary */
                const boundary = nextBoundary(pos, end);
                const writeEnd = Math.min(boundary, end);
                const slice = normalized.slice(pos - start, writeEnd - start);
                this.writeBuffer = this._addSegment(this.writeBuffer, pos, slice);
                markSectors(pos, writeEnd);
                mergeWrites();
                pos = writeEnd;
                remaining = end - pos;
                continue;
            }

            /* Case 3: no cache coverage; create a new segment up to next sector/boundary */
            const boundary = nextBoundary(pos, end);
            const writeEnd = Math.min(boundary, end);
            const slice = normalized.slice(pos - start, writeEnd - start);
            this.writeBuffer = this._addSegment(this.writeBuffer, pos, slice);
            markSectors(pos, writeEnd);
            mergeWrites();
            pos = writeEnd;
            remaining = end - pos;
        }

        /* Cleanup: remove sectors we touched that are identical to cached data */
        for (const sectorStart of touchedSectors) {
            const sectorEnd = Math.min(sectorStart + sectorSize, this.size);

            /* Only prune if the sector is fully backed by real read cache and matches */
            const readCovered = this._isRangeCovered(sectorStart, sectorEnd - sectorStart, this.readBuffer);
            if (!readCovered) {
                continue;
            }

            const baseline = this._materializeReadRange(sectorStart, sectorEnd);
            const combined = this._materializeRange(sectorStart, sectorEnd);

            let identical = baseline.length === combined.length;
            if (identical) {
                for (let i = 0; i < combined.length; i++) {
                    if (combined[i] !== baseline[i]) {
                        identical = false;
                        break;
                    }
                }
            }

            if (identical) {
                const pruned = [];
                for (const seg of this.writeBuffer) {
                    const segStart = seg.address;
                    const segEnd = seg.address + seg.data.length;
                    if (segEnd <= sectorStart || segStart >= sectorEnd) {
                        pruned.push(seg);
                        continue;
                    }

                    if (segStart < sectorStart) {
                        const left = seg.data.slice(0, sectorStart - segStart);
                        if (left.length) pruned.push({ address: segStart, data: left });
                    }

                    if (segEnd > sectorEnd) {
                        const right = seg.data.slice(sectorEnd - segStart);
                        if (right.length) pruned.push({ address: sectorEnd, data: right });
                    }
                }
                this.writeBuffer = this._mergeSegmentsGeneric(pruned);
            }
        }

        /* Ensure buffers are merged after all operations */
        mergeWrites();

        const postRanges = fmtRanges(this.writeBuffer);
        // this.logDebug('SparseImage.write done', { address: start, length: normalized.length, preRanges, postRanges });
    }

    fill(value, start = 0, end = this.size) {
        if (start < 0 || start >= this.size) {
            throw new RangeError(`Address ${start} out of bounds [0, ${this.size})`);
        }
        end = Math.min(end, this.size);
        if (end <= start) return;

        const desired = value & 0xFF;
        const len = end - start;
        const buf = new Uint8Array(len);
        buf.fill(desired);
        // this.logDebug('SparseImage.fill', { start, end, len, desired });
        this.write(start, buf);
    }

    async flush() {
        if (!this.writeBuffer.length) return;

        // Consolidate write segments first (touching/overlapping writes coalesce)
        this._mergeWriteSegments();

        /* Call prepare callback if provided */
        if (this.flushPrepareCallback) {
            await this.flushPrepareCallback(this);
        }

        // Flush to backing store if provided
        if (this.writeDataCallback) {
            // Deterministic order: ascending address
            const toWrite = [...this.writeBuffer].sort((a, b) => a.address - b.address);
            for (const segment of toWrite) {
                await this.writeDataCallback(segment.address, segment.data);
            }
        }

        // Merge read+write with explicit priority: write data overrides read data
        this.readBuffer = this._mergeReadAndWriteWithPriority(this.readBuffer, this.writeBuffer);

        // Clear pending writes
        this.writeBuffer = [];
    }

    async clear(){
        this.readBuffer = [];
        this.writeBuffer = [];
    }

    /**
     * Merge read and write buffers into a single read buffer, ensuring
     * write data has priority over read data in any overlap. Touching
     * segments are merged into a single continuous segment.
     */
    _mergeReadAndWriteWithPriority(readList, writeList) {
        if ((!readList || readList.length === 0) && (!writeList || writeList.length === 0)) {
            return [];
        }

        const annotated = [];
        if (readList && readList.length) {
            for (const s of readList) annotated.push({ address: s.address, data: s.data, _src: 'r' });
        }
        if (writeList && writeList.length) {
            for (const s of writeList) annotated.push({ address: s.address, data: s.data, _src: 'w' });
        }

        // Sort by address to form contiguous/touching groups
        annotated.sort((a, b) => a.address - b.address);

        const result = [];
        let group = [];
        let groupStart = null;
        let groupEnd = null;

        const flushGroup = () => {
            if (!group.length) return;
            const length = groupEnd - groupStart;
            const mergedData = new Uint8Array(length);

            // Overlay order: read first, then write (write overrides)
            for (const seg of group) {
                if (seg._src !== 'r') continue;
                const off = seg.address - groupStart;
                mergedData.set(seg.data, off);
            }
            for (const seg of group) {
                if (seg._src !== 'w') continue;
                const off = seg.address - groupStart;
                mergedData.set(seg.data, off);
            }

            result.push({ address: groupStart, data: mergedData });
            group = [];
            groupStart = null;
            groupEnd = null;
        };

        for (const seg of annotated) {
            const segStart = seg.address;
            const segEnd = seg.address + seg.data.length;
            if (groupStart === null) {
                // start new group
                groupStart = segStart;
                groupEnd = segEnd;
                group.push(seg);
                continue;
            }
            // Merge if overlapping or touching
            if (segStart <= groupEnd) {
                group.push(seg);
                if (segEnd > groupEnd) groupEnd = segEnd;
            } else {
                // Gap: finalize previous group
                flushGroup();
                // start new group
                groupStart = segStart;
                groupEnd = segEnd;
                group.push(seg);
            }
        }

        flushGroup();
        return result;
    }

    /**
     * Get a single byte at the given offset (Uint8Array-like interface)
     * NOTE: Assumes data is already loaded. Use async methods to ensure data first.
     */
    _get(index) {
        if (index < 0 || index >= this.size) {
            return undefined;
        }

        // Write buffer overrides read buffer
        const wseg = this._findSegment(index, this.writeBuffer);
        if (wseg) {
            return wseg.data[index - wseg.address];
        }

        const segment = this._findSegment(index, this.readBuffer);
        if (!segment) {
            return 0; // Return 0 for unread data
        }

        return segment.data[index - segment.address];
    }

    /**
     * Proxy handler to make SparseImage act like a Uint8Array
     */
    static _createProxy(sparseImage) {
        return new Proxy(sparseImage, {
            get(target, prop) {
                if (typeof prop === 'symbol') {
                    return target[prop];
                }
                // Handle numeric indices
                const index = Number(prop);
                if (Number.isInteger(index) && index >= 0) {
                    return target._get(index);
                }

                // Handle standard properties and methods
                if (prop in target) {
                    const value = target[prop];
                    return typeof value === 'function' ? value.bind(target) : value;
                }

                return undefined;
            },

            set(target, prop, value) {
                if (typeof prop === 'symbol') {
                    target[prop] = value;
                    return true;
                }
                const index = Number(prop);
                if (Number.isInteger(index) && index >= 0) {
                    const byte = Number(value) & 0xFF;
                    target.write(index, Uint8Array.of(byte));
                    return true;
                }

                target[prop] = value;
                return true;
            },

            has(target, prop) {
                if (typeof prop === 'symbol') {
                    return prop in target;
                }
                const index = Number(prop);
                if (Number.isInteger(index) && index >= 0 && index < target.size) {
                    return true;
                }
                return prop in target;
            }
        });
    }

    /**
     * Get a subarray (similar to Uint8Array.subarray)
     * SYNC version - assumes data is already loaded via prefetch/ensureData
     */
    subarray(start, end) {
        start = start || 0;
        end = end === undefined ? this.size : end;

        const size = end - start;

        const result = new Uint8Array(size);
        for (let pos = start, idx = 0; pos < end; pos++, idx++) {
            result[idx] = this._get(pos);
        }

        return result;
    }

    /**
     * Get a subarray asynchronously (ensures data is loaded first)
     */
    async subarray_async(start, end) {
        start = start || 0;
        end = end === undefined ? this.size : end;

        const size = end - start;

        // Ensure all data is loaded first
        await this._ensureData(start, size);

        const result = new Uint8Array(size);
        for (let pos = start, idx = 0; pos < end; pos++, idx++) {
            result[idx] = this._get(pos);
        }

        return result;
    }

    /**
     * Get a slice (creates a copy, similar to Uint8Array.slice)
     * SYNC version - assumes data is already loaded
     */
    slice(start, end) {
        return this.subarray(start, end);
    }

    /**
     * Get a slice asynchronously (ensures data is loaded first)
     */
    async slice_async(start, end) {
        return await this.subarray_async(start, end);
    }

    /**
     * Create a DataView for this SparseImage
     */
    createDataView() {
        return new SparseImageDataView(this);
    }



    /**
     * Pre-fetch a range of data
     */
    async prefetch(address, size) {
        return await this._ensureData(address, size);
    }
}


class FATParser {
    constructor(sparseImage, startOffset, size) {
        if (!sparseImage) {
            throw new Error('FATParser requires a SparseImage');
        }
        this.sparseImage = sparseImage;
        this.startOffset = startOffset;
        this.size = size;
        this.buffer = SparseImage._createProxy(sparseImage);
        this.view = sparseImage.createDataView();
        this.fatInfo = null;
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    async initialize() {
        this.fatInfo = await this.parse();
        return this.fatInfo;
    }

    async parseWearLeveling() {
        const WL_SECTOR_SIZE = 0x1000;
        const WL_STATE_RECORD_SIZE = 16;
        const WL_STATE_COPY_COUNT = 2;
        const offset = this.startOffset;
        const length = this.size;

        const totalSectors = Math.floor(length / WL_SECTOR_SIZE);
        const wlStateSize = 64 + WL_STATE_RECORD_SIZE * totalSectors;
        const wlStateSectors = Math.ceil(wlStateSize / WL_SECTOR_SIZE);
        const wlSectorsSize = (wlStateSectors * WL_SECTOR_SIZE * WL_STATE_COPY_COUNT) + WL_SECTOR_SIZE;
        const fatSectors = totalSectors - 1 - (WL_STATE_COPY_COUNT * wlStateSectors);

        const stateOffset = offset + length - wlSectorsSize;
        if (stateOffset + 64 > this.sparseImage.size) {
            return { error: 'Cannot read wear leveling state' };
        }

        const wlState = {
            pos: await this.view.getUint32(stateOffset, true),
            maxPos: await this.view.getUint32(stateOffset + 4, true),
            moveCount: await this.view.getUint32(stateOffset + 8, true),
            accessCount: await this.view.getUint32(stateOffset + 12, true),
            maxCount: await this.view.getUint32(stateOffset + 16, true),
            blockSize: await this.view.getUint32(stateOffset + 20, true),
            version: await this.view.getUint32(stateOffset + 24, true),
            deviceId: await this.view.getUint32(stateOffset + 28, true)
        };

        let totalRecords = 0;
        let recordOffset = stateOffset + 64;
        for (let i = 0; i < wlStateSize && recordOffset + WL_STATE_RECORD_SIZE <= this.sparseImage.size; i++) {
            let isEmpty = true;
            for (let j = 0; j < WL_STATE_RECORD_SIZE; j++) {
                if ((await this.view.getUint8(recordOffset + j)) !== 0xFF) {
                    isEmpty = false;
                    break;
                }
            }
            if (isEmpty) break;
            totalRecords++;
            recordOffset += WL_STATE_RECORD_SIZE;
        }

        return {
            wlState: wlState,
            totalSectors: totalSectors,
            wlSectorsSize: wlSectorsSize,
            fatSectors: fatSectors,
            totalRecords: totalRecords,
            dataOffset: offset,
            dataSize: length - wlSectorsSize
        };
    }

    wlTranslateSector(wlInfo, sector) {
        let translated = (sector + wlInfo.wlState.moveCount) % wlInfo.fatSectors;
        if (translated >= wlInfo.totalRecords) {
            translated += 1;
        }
        return translated;
    }

    /*
     * Read from a logical sector, with wear leveling translation applied
     * Returns absolute offset in sparseImage for the given logical sector
     */
    wlSectorToOffset(wlInfo, logicalSector) {
        const WL_SECTOR_SIZE = 0x1000;
        const physicalSector = this.wlTranslateSector(wlInfo, logicalSector);
        return this.startOffset + physicalSector * WL_SECTOR_SIZE;
    }

    async parse() {
        const WL_SECTOR_SIZE = 0x1000;
        const wlInfo = await this.parseWearLeveling();
        if (wlInfo.error) {
            return { error: wlInfo.error };
        }

        const sector0Physical = this.wlTranslateSector(wlInfo, 0);
        const bootSectorOffset = this.wlSectorToOffset(wlInfo, 0);
        if (bootSectorOffset + 512 > this.sparseImage.size) {
            return { error: 'Cannot read FAT boot sector' };
        }

        const bootSig = await this.view.getUint16(bootSectorOffset + 510, true);
        if (bootSig !== 0xAA55) {
            return { error: `Invalid boot sector signature: 0x${bootSig.toString(16).toUpperCase()} (expected 0xAA55)` };
        }

        const bytesPerSector = await this.view.getUint16(bootSectorOffset + 11, true);
        const sectorsPerCluster = await this.view.getUint8(bootSectorOffset + 13);
        const reservedSectors = await this.view.getUint16(bootSectorOffset + 14, true);
        const numFATs = await this.view.getUint8(bootSectorOffset + 16);
        const rootEntryCount = await this.view.getUint16(bootSectorOffset + 17, true);
        const totalSectors16 = await this.view.getUint16(bootSectorOffset + 19, true);
        const sectorsPerFAT = await this.view.getUint16(bootSectorOffset + 22, true);
        const totalSectors32 = await this.view.getUint32(bootSectorOffset + 32, true);

        if (bytesPerSector === 0 || sectorsPerCluster === 0 || numFATs === 0) {
            return { error: 'Invalid FAT boot sector parameters' };
        }

        const totalSectors = totalSectors16 || totalSectors32;
        const rootDirSectors = Math.ceil((rootEntryCount * 32) / bytesPerSector);
        const firstDataSector = reservedSectors + (numFATs * sectorsPerFAT) + rootDirSectors;
        const dataSectors = totalSectors - firstDataSector;
        const totalClusters = Math.floor(dataSectors / sectorsPerCluster);

        let fatType;
        if (totalClusters < 4085) fatType = 'FAT12';
        else if (totalClusters < 65525) fatType = 'FAT16';
        else fatType = 'FAT32';

        let volumeLabel = '';
        for (let i = 0; i < 11; i++) {
            const c = await this.view.getUint8(bootSectorOffset + 43 + i);
            if (c === 0 || c === 0x20) break;
            volumeLabel += String.fromCharCode(c);
        }

        const rootDirOffset = this.wlSectorToOffset(wlInfo, reservedSectors + numFATs * sectorsPerFAT);

        const files = await this.parseDirectory(wlInfo, rootDirOffset, rootEntryCount,
            bytesPerSector, sectorsPerCluster, reservedSectors, numFATs, sectorsPerFAT, '', true);

        this.fatInfo = {
            fatType: fatType,
            volumeLabel: volumeLabel || '(no label)',
            bytesPerSector: bytesPerSector,
            sectorsPerCluster: sectorsPerCluster,
            reservedSectors: reservedSectors,
            numFATs: numFATs,
            sectorsPerFAT: sectorsPerFAT,
            totalSectors: totalSectors,
            totalClusters: totalClusters,
            files: files,
            wearLeveling: wlInfo
        };

        return this.fatInfo;
    }

    async parseDirectory(wlInfo, dirOffset, maxEntries, bytesPerSector, sectorsPerCluster,
        reservedSectors, numFATs, sectorsPerFAT, parentPath, isRoot = false) {
        const WL_SECTOR_SIZE = 0x1000;
        const files = [];
        const firstDataSector = reservedSectors + numFATs * sectorsPerFAT +
            Math.ceil((maxEntries || 512) * 32 / bytesPerSector);

        const maxIter = isRoot ? maxEntries : 512;

        for (let i = 0; i < maxIter; i++) {
            const entryOffset = dirOffset + i * 32;
            if (entryOffset + 32 > this.sparseImage.size) break;
            const firstByte = await this.view.getUint8(entryOffset);
            if (firstByte === 0x00) break;
            if (firstByte === 0xE5 || firstByte === 0x05) continue;
            const attr = await this.view.getUint8(entryOffset + 11);
            if (attr === 0x0F) continue;
            if (attr & 0x08) continue;

            let name = '';
            for (let j = 0; j < 8; j++) {
                const c = await this.view.getUint8(entryOffset + j);
                if (c !== 0x20 && c >= 0x20 && c <= 0x7E) name += String.fromCharCode(c);
            }
            let ext = '';
            for (let j = 0; j < 3; j++) {
                const c = await this.view.getUint8(entryOffset + 8 + j);
                if (c !== 0x20 && c >= 0x20 && c <= 0x7E) ext += String.fromCharCode(c);
            }
            if (name.length === 0 || name === '.' || name === '..') continue;
            if (ext) name += '.' + ext;

            const size = await this.view.getUint32(entryOffset + 28, true);
            const cluster = await this.view.getUint16(entryOffset + 26, true);

            const attributes = [];
            if (attr & 0x01) attributes.push('Read-only');
            if (attr & 0x02) attributes.push('Hidden');
            if (attr & 0x04) attributes.push('System');
            if (attr & 0x08) attributes.push('Volume');
            if (attr & 0x10) attributes.push('Directory');
            if (attr & 0x20) attributes.push('Archive');

            const date = await this.view.getUint16(entryOffset + 24, true);
            const time = await this.view.getUint16(entryOffset + 22, true);
            const year = ((date >> 9) & 0x7F) + 1980;
            const month = (date >> 5) & 0x0F;
            const day = date & 0x1F;
            const hour = (time >> 11) & 0x1F;
            const minute = (time >> 5) & 0x3F;
            const second = (time & 0x1F) * 2;

            const isDirectory = !!(attr & 0x10);
            const fullPath = parentPath ? `${parentPath}/${name}` : name;

            const fileEntry = {
                name: name,
                path: fullPath,
                size: size,
                cluster: cluster,
                attributes: attributes,
                isDirectory: isDirectory,
                date: `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`,
                time: `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:${second.toString().padStart(2, '0')}`,
                directorySector: dirOffset,
                directoryEntry: i
            };

            files.push(fileEntry);

            if (isDirectory && cluster >= 2 && cluster < 0xFFF0) {
                const clusterSector = firstDataSector + (cluster - 2) * sectorsPerCluster;
                const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

                if (clusterOffset + sectorsPerCluster * WL_SECTOR_SIZE <= this.sparseImage.size) {
                    const subFiles = await this.parseDirectory(wlInfo, clusterOffset, null,
                        bytesPerSector, sectorsPerCluster, reservedSectors, numFATs, sectorsPerFAT, fullPath, false);
                    fileEntry.children = subFiles;
                }
            }
        }

        return files;
    }

    async readFATEntry(cluster) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const fatOffset = fatInfo.reservedSectors * WL_SECTOR_SIZE;
        const fatType = fatInfo.fatType;

        if (fatType === 'FAT12') {
            const entryOffset = fatOffset + Math.floor(cluster * 1.5);
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;
            const val = await this.view.getUint16(sectorOffset + byteOffset, true);
            if (cluster & 1) {
                return val >> 4;
            } else {
                return val & 0x0FFF;
            }
        } else if (fatType === 'FAT16') {
            const entryOffset = fatOffset + cluster * 2;
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;
            return await this.view.getUint16(sectorOffset + byteOffset, true);
        } else {
            const entryOffset = fatOffset + cluster * 4;
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;
            return (await this.view.getUint32(sectorOffset + byteOffset, true)) & 0x0FFFFFFF;
        }
    }

    async extractFile(fileEntry) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const bytesPerCluster = fatInfo.bytesPerSector * fatInfo.sectorsPerCluster;
        const firstDataSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT +
            Math.ceil(512 * 32 / fatInfo.bytesPerSector);

        const clusters = [];
        let currentCluster = fileEntry.cluster;
        const maxClusters = Math.ceil(fileEntry.size / bytesPerCluster) + 10;

        while (currentCluster >= 2 && currentCluster < 0xFFF0 && clusters.length < maxClusters) {
            clusters.push(currentCluster);
            currentCluster = await this.readFATEntry(currentCluster);
        }

        const fileData = new Uint8Array(fileEntry.size);
        let bytesRead = 0;

        for (const cluster of clusters) {
            const clusterSector = firstDataSector + (cluster - 2) * fatInfo.sectorsPerCluster;
            const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

            const bytesToRead = Math.min(bytesPerCluster, fileEntry.size - bytesRead);
            if (clusterOffset + bytesToRead <= this.sparseImage.size) {
                fileData.set(await this.buffer.slice_async(clusterOffset, clusterOffset + bytesToRead), bytesRead);
                bytesRead += bytesToRead;
            }
            if (bytesRead >= fileEntry.size) break;
        }

        return new Blob([fileData], { type: 'application/octet-stream' });
    }

    /*
     * Find a file entry by its full path
     * @param {string} targetPath - Full path to search for (e.g., "CERT/CA.DER")
     * @returns {Object|null} - File entry if found, null otherwise
     */
    findFileByPath(targetPath) {
        if (!this.fatInfo || !this.fatInfo.files) {
            return null;
        }

        const searchRecursive = (files, path) => {
            if (!files) return null;
            for (const file of files) {
                if (file.path === path) {
                    return file;
                }
                if (file.children) {
                    const found = searchRecursive(file.children, path);
                    if (found) return found;
                }
            }
            return null;
        };

        return searchRecursive(this.fatInfo.files, targetPath);
    }

    /*
     * Delete a file by:
     * 1. Clearing all its clusters with 0xFF
     * 2. Setting FAT entries to unused (0x0000)
     * 3. Marking the directory entry as deleted (0xE5)
     */
    async deleteFile(fileEntry) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const bytesPerCluster = fatInfo.bytesPerSector * fatInfo.sectorsPerCluster;
        const firstDataSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT +
            Math.ceil(512 * 32 / fatInfo.bytesPerSector);

        /* Step 1: Get all clusters used by the file */
        const clusters = [];
        let currentCluster = fileEntry.cluster;
        const maxClusters = Math.ceil(fileEntry.size / bytesPerCluster) + 10;

        while (currentCluster >= 2 && currentCluster < 0xFFF0 && clusters.length < maxClusters) {
            clusters.push(currentCluster);
            currentCluster = await this.readFATEntry(currentCluster);
        }

        /* Step 2: Clear all clusters with 0xFF */
        const clearData = new Uint8Array(WL_SECTOR_SIZE);
        clearData.fill(0xFF);

        for (const cluster of clusters) {
            const clusterSector = firstDataSector + (cluster - 2) * fatInfo.sectorsPerCluster;
            const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

            /* Write 0xFF to each sector in the cluster */
            for (let i = 0; i < fatInfo.sectorsPerCluster; i++) {
                const sectorOffset = clusterOffset + i * WL_SECTOR_SIZE;
                this.sparseImage.write(sectorOffset, clearData);
            }
        }

        /* Step 3: Mark FAT entries as unused (0x0000) */
        for (const cluster of clusters) {
            const fatOffset = fatInfo.reservedSectors * WL_SECTOR_SIZE;
            const fatType = fatInfo.fatType;

            if (fatType === 'FAT12') {
                const entryOffset = fatOffset + Math.floor(cluster * 1.5);
                const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
                const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
                const byteOffset = entryOffset % WL_SECTOR_SIZE;

                /* Read current FAT entry */
                const val = await this.view.getUint16(sectorOffset + byteOffset, true);
                let newVal = val;

                if (cluster & 1) {
                    /* Odd cluster: upper 12 bits */
                    newVal = (val & 0x0FFF);
                } else {
                    /* Even cluster: lower 12 bits */
                    newVal = (val & 0xF000);
                }

                /* Write back the modified FAT entry */
                const writeData = new Uint8Array(2);
                new DataView(writeData.buffer).setUint16(0, newVal, true);
                this.sparseImage.write(sectorOffset + byteOffset, writeData);

            } else if (fatType === 'FAT16') {
                const entryOffset = fatOffset + cluster * 2;
                const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
                const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
                const byteOffset = entryOffset % WL_SECTOR_SIZE;

                const writeData = new Uint8Array(2);
                writeData.fill(0x00);
                this.sparseImage.write(sectorOffset + byteOffset, writeData);

            } else {
                /* FAT32 */
                const entryOffset = fatOffset + cluster * 4;
                const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
                const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
                const byteOffset = entryOffset % WL_SECTOR_SIZE;

                const writeData = new Uint8Array(4);
                writeData.fill(0x00);
                this.sparseImage.write(sectorOffset + byteOffset, writeData);
            }
        }

        /* Step 4: Mark directory entry as deleted (0xE5) */
        if (fileEntry.directorySector !== undefined && fileEntry.directoryEntry !== undefined) {
            const entryOffset = fileEntry.directorySector + fileEntry.directoryEntry * 32;
            const deleteMarker = new Uint8Array(1);
            deleteMarker[0] = 0xE5;
            this.sparseImage.write(entryOffset, deleteMarker);
        }

        return { success: true, clustersCleared: clusters.length };
    }

    /*
     * Add a file to the FAT filesystem
     * @param {string} path - Full path including filename (e.g., "dir/subdir/file.txt")
     * @param {Uint8Array} data - Binary data to write
     * @returns {Object} - Result with success status and details
     */
    async addFile(path, data) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const bytesPerCluster = fatInfo.bytesPerSector * fatInfo.sectorsPerCluster;
        const firstDataSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT +
            Math.ceil(512 * 32 / fatInfo.bytesPerSector);

        /* Parse path into directory path and filename */
        const parts = path.split('/').filter(p => p.length > 0);
        const filename = parts.pop();
        const dirPath = parts.join('/');

        if (!filename || filename.length > 12) {
            return { success: false, error: 'Invalid filename (max 8.3 format)' };
        }

        /* Parse filename into name and extension */
        const nameParts = filename.split('.');
        let name = nameParts[0].toUpperCase().padEnd(8, ' ').substring(0, 8);
        let ext = (nameParts[1] || '').toUpperCase().padEnd(3, ' ').substring(0, 3);

        /* Step 1: Find the target directory */
        const dirEntry = await this._findDirectory(dirPath);
        if (!dirEntry.found) {
            return { success: false, error: `Directory not found: ${dirPath || '(root)'}` };
        }

        /* Step 2: Find a free directory entry (prioritize deleted entries 0xE5) */
        const freeEntry = await this._findFreeDirectoryEntry(dirEntry.offset, dirEntry.isRoot, dirEntry.maxEntries);
        if (!freeEntry) {
            return { success: false, error: 'No free directory entries available' };
        }

        /* Step 3: Allocate clusters for the file */
        const clustersNeeded = Math.ceil(data.length / bytesPerCluster);
        const allocatedClusters = await this._allocateClusters(clustersNeeded);
        if (allocatedClusters.length < clustersNeeded) {
            return { success: false, error: 'Not enough free clusters' };
        }

        /* Step 4: Write data to allocated clusters */
        let bytesWritten = 0;
        for (let i = 0; i < allocatedClusters.length; i++) {
            const cluster = allocatedClusters[i];
            const clusterSector = firstDataSector + (cluster - 2) * fatInfo.sectorsPerCluster;
            const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

            const bytesToWrite = Math.min(bytesPerCluster, data.length - bytesWritten);
            const clusterData = data.slice(bytesWritten, bytesWritten + bytesToWrite);

            /* Write data to cluster */
            this.sparseImage.write(clusterOffset, clusterData);

            /* If less than full cluster, fill remainder with 0xFF */
            if (bytesToWrite < bytesPerCluster) {
                const fillData = new Uint8Array(bytesPerCluster - bytesToWrite);
                fillData.fill(0xFF);
                this.sparseImage.write(clusterOffset + bytesToWrite, fillData);
            }

            bytesWritten += bytesToWrite;
        }

        /* Step 5: Update FAT chain */
        for (let i = 0; i < allocatedClusters.length; i++) {
            const cluster = allocatedClusters[i];
            const nextCluster = (i < allocatedClusters.length - 1) ? allocatedClusters[i + 1] : 0xFFFF;
            await this._writeFATEntry(cluster, nextCluster);
        }

        /* Step 6: Write directory entry */
        const now = new Date();
        const dirEntryData = new Uint8Array(32);

        /* Filename (8 bytes) + Extension (3 bytes) */
        for (let i = 0; i < 8; i++) dirEntryData[i] = name.charCodeAt(i);
        for (let i = 0; i < 3; i++) dirEntryData[8 + i] = ext.charCodeAt(i);

        /* Attributes (1 byte): 0x20 = Archive */
        dirEntryData[11] = 0x20;

        /* Reserved (10 bytes) */
        for (let i = 12; i < 22; i++) dirEntryData[i] = 0x00;

        /* Time (2 bytes) */
        const time = ((now.getHours() & 0x1F) << 11) |
            ((now.getMinutes() & 0x3F) << 5) |
            ((now.getSeconds() / 2) & 0x1F);
        new DataView(dirEntryData.buffer).setUint16(22, time, true);

        /* Date (2 bytes) */
        const date = (((now.getFullYear() - 1980) & 0x7F) << 9) |
            (((now.getMonth() + 1) & 0x0F) << 5) |
            (now.getDate() & 0x1F);
        new DataView(dirEntryData.buffer).setUint16(24, date, true);

        /* First cluster (2 bytes) */
        new DataView(dirEntryData.buffer).setUint16(26, allocatedClusters[0], true);

        /* File size (4 bytes) */
        new DataView(dirEntryData.buffer).setUint32(28, data.length, true);

        /* Write directory entry */
        this.sparseImage.write(freeEntry.offset, dirEntryData);

        return {
            success: true,
            filename: filename,
            size: data.length,
            clusters: allocatedClusters.length,
            startCluster: allocatedClusters[0]
        };
    }

    /* Helper: Find directory by path */
    async _findDirectory(path) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;

        /* Root directory */
        if (!path || path === '') {
            const rootDirSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT;
            const rootDirOffset = this.wlSectorToOffset(wlInfo, rootDirSector);
            const maxEntries = 512; // Standard for FAT16 root directory

            return {
                found: true,
                offset: rootDirOffset,
                isRoot: true,
                maxEntries: maxEntries
            };
        }

        /* Navigate to subdirectory */
        const parts = path.split('/').filter(p => p.length > 0);
        let currentDir = fatInfo.files;

        for (const part of parts) {
            const found = currentDir.find(f => f.isDirectory && f.name.toLowerCase() === part.toLowerCase());
            if (!found) {
                return { found: false, error: `Directory not found: ${part}` };
            }
            currentDir = found.children || [];

            /* Get directory cluster offset */
            if (found.cluster >= 2 && found.cluster < 0xFFF0) {
                const firstDataSector = fatInfo.reservedSectors + fatInfo.numFATs * fatInfo.sectorsPerFAT +
                    Math.ceil(512 * 32 / fatInfo.bytesPerSector);
                const clusterSector = firstDataSector + (found.cluster - 2) * fatInfo.sectorsPerCluster;
                const clusterOffset = this.wlSectorToOffset(wlInfo, clusterSector);

                return {
                    found: true,
                    offset: clusterOffset,
                    isRoot: false,
                    maxEntries: null // Subdirectory size limited by cluster
                };
            }
        }

        return { found: false, error: 'Invalid directory structure' };
    }

    /* Helper: Find free directory entry, prioritizing deleted entries */
    async _findFreeDirectoryEntry(dirOffset, isRoot, maxEntries) {
        const WL_SECTOR_SIZE = 0x1000;
        const maxIter = maxEntries || 512;
        let firstFreeEntry = null;

        for (let i = 0; i < maxIter; i++) {
            const entryOffset = dirOffset + i * 32;
            if (entryOffset + 32 > this.sparseImage.size) break;

            const firstByte = await this.view.getUint8(entryOffset);

            /* Deleted entry (0xE5) - prioritize this */
            if (firstByte === 0xE5) {
                return { offset: entryOffset, index: i, wasDeleted: true };
            }

            /* End of directory (0x00) - use this if no deleted entry found */
            if (firstByte === 0x00) {
                if (!firstFreeEntry) {
                    firstFreeEntry = { offset: entryOffset, index: i, wasDeleted: false };
                }
                break;
            }
        }

        return firstFreeEntry;
    }

    /* Helper: Allocate free clusters */
    async _allocateClusters(count) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const allocated = [];

        /* Scan FAT for free clusters (value 0x0000) */
        for (let cluster = 2; cluster < fatInfo.totalClusters && allocated.length < count; cluster++) {
            const entry = await this.readFATEntry(cluster);
            if (entry === 0x0000) {
                allocated.push(cluster);
            }
        }

        return allocated;
    }

    /* Helper: Write FAT entry */
    async _writeFATEntry(cluster, value) {
        const WL_SECTOR_SIZE = 0x1000;
        const fatInfo = this.fatInfo;
        const wlInfo = fatInfo.wearLeveling;
        const fatOffset = fatInfo.reservedSectors * WL_SECTOR_SIZE;
        const fatType = fatInfo.fatType;

        if (fatType === 'FAT12') {
            const entryOffset = fatOffset + Math.floor(cluster * 1.5);
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;

            /* Read current value */
            const currentVal = await this.view.getUint16(sectorOffset + byteOffset, true);
            let newVal;

            if (cluster & 1) {
                /* Odd cluster: upper 12 bits */
                newVal = (currentVal & 0x000F) | ((value & 0x0FFF) << 4);
            } else {
                /* Even cluster: lower 12 bits */
                newVal = (currentVal & 0xF000) | (value & 0x0FFF);
            }

            const writeData = new Uint8Array(2);
            new DataView(writeData.buffer).setUint16(0, newVal, true);
            this.sparseImage.write(sectorOffset + byteOffset, writeData);

        } else if (fatType === 'FAT16') {
            const entryOffset = fatOffset + cluster * 2;
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;

            const writeData = new Uint8Array(2);
            new DataView(writeData.buffer).setUint16(0, value & 0xFFFF, true);
            this.sparseImage.write(sectorOffset + byteOffset, writeData);

        } else {
            /* FAT32 */
            const entryOffset = fatOffset + cluster * 4;
            const sector = Math.floor(entryOffset / WL_SECTOR_SIZE);
            const sectorOffset = this.wlSectorToOffset(wlInfo, sector);
            const byteOffset = entryOffset % WL_SECTOR_SIZE;

            const writeData = new Uint8Array(4);
            new DataView(writeData.buffer).setUint32(0, value & 0x0FFFFFFF, true);
            this.sparseImage.write(sectorOffset + byteOffset, writeData);
        }
    }
}




class SpiffsParser {
    constructor(sparseImage, startOffset, size) {
        if (!sparseImage) {
            throw new Error('SpiffsParser requires a SparseImage');
        }
        this.sparseImage = sparseImage;
        this.startOffset = startOffset;
        this.size = size;
        this.buffer = SparseImage._createProxy(sparseImage);
        this.view = sparseImage.createDataView();
        this.spiffsInfo = null;
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    async initialize() {
        this.spiffsInfo = await this.parse();
        return this.spiffsInfo;
    }

    async parse() {
        const offset = this.startOffset;
        const size = this.size;

        this.logDebug(`[SPIFFS] Parsing partition at offset 0x${offset.toString(16)}, size ${size} bytes`);

        const defaultBlockSize = 4096;
        const headerData = await this.buffer.slice_async(offset, offset + Math.min(defaultBlockSize, size));
        const view = new DataView(headerData.buffer, headerData.byteOffset);

        let magic = 0;
        let pageSize = 256;
        let blockSizeActual = 4096;
        let validHeader = false;

        this.logDebug(`[SPIFFS] Scanning for magic number...`);
        for (let i = 0; i < Math.min(512, headerData.length - 4); i += 4) {
            try {
                const testMagic = view.getUint32(i, true);
                if (testMagic === 0x20160902) {
                    magic = testMagic;
                    validHeader = true;
                    this.logDebug(`[SPIFFS] Found magic at offset 0x${i.toString(16)}`);
                    if (i + 16 <= headerData.length) {
                        const cfgPhysSize = view.getUint32(i + 4, true);
                        const cfgLogBlockSize = view.getUint32(i + 8, true);
                        const cfgLogPageSize = view.getUint32(i + 12, true);
                        this.logDebug(`[SPIFFS] Config: phys=${cfgPhysSize}, blockSize=${cfgLogBlockSize}, pageSize=${cfgLogPageSize}`);
                        if (cfgLogBlockSize > 0 && cfgLogBlockSize <= 65536 &&
                            cfgLogPageSize > 0 && cfgLogPageSize <= 2048) {
                            blockSizeActual = cfgLogBlockSize;
                            pageSize = cfgLogPageSize;
                        }
                    }
                    break;
                }
            } catch (e) {
                continue;
            }
        }

        if (!validHeader) {
            this.logDebug(`[SPIFFS] No magic found, trying pattern detection...`);
            validHeader = await this.detectByPattern(headerData);
            this.logDebug(`[SPIFFS] Pattern detection result: ${validHeader}`);
        }

        const files = [];
        const pagesPerBlock = Math.floor(blockSizeActual / pageSize);
        this.logDebug(`[SPIFFS] Config: blockSize=${blockSizeActual}, pageSize=${pageSize}, pagesPerBlock=${pagesPerBlock}`);
        this.logDebug(`[SPIFFS] Scanning ${Math.floor(size / blockSizeActual)} blocks...`);

        for (let blockIdx = 0; blockIdx < Math.floor(size / blockSizeActual); blockIdx++) {
            const blockOffset = offset + blockIdx * blockSizeActual;
            this.logDebug(`[SPIFFS] ===== Block ${blockIdx}: offset 0x${blockOffset.toString(16)} =====`);
            const blockData = await this.buffer.slice_async(blockOffset, blockOffset + Math.min(blockSizeActual, size - blockIdx * blockSizeActual));

            for (let pageIdx = 0; pageIdx < pagesPerBlock; pageIdx++) {
                const pageStart = pageIdx * pageSize;
                if (pageStart + pageSize > blockData.length) break;

                const objId = blockData[pageStart] | (blockData[pageStart + 1] << 8);
                const span = blockData[pageStart + 2] | (blockData[pageStart + 3] << 8);
                const flags = blockData[pageStart + 4];

                if (objId === 0xFFFF || objId === 0x0000) continue;

                let fileSize = 0;
                let type = 0;
                let nameStr = '[NO NAME]';
                const isIndexHeader = (span === 0);

                if (isIndexHeader) {
                    if (pageStart + 12 <= blockData.length) {
                        fileSize = (blockData[pageStart + 8] |
                            (blockData[pageStart + 9] << 8) |
                            (blockData[pageStart + 10] << 16) |
                            (blockData[pageStart + 11] << 24)) >>> 0;
                    }
                    type = blockData[pageStart + 12];
                    const nameStartIdx = pageStart + 13;
                    if (nameStartIdx < blockData.length) {
                        let nameBytes = [];
                        for (let i = nameStartIdx; i < Math.min(nameStartIdx + 256, pageStart + pageSize); i++) {
                            if (blockData[i] === 0 || blockData[i] === 0xFF) break;
                            if (blockData[i] >= 32 && blockData[i] < 127) nameBytes.push(blockData[i]); else break;
                        }
                        if (nameBytes.length > 0) nameStr = String.fromCharCode(...nameBytes);
                    }
                }

                const isDeleted = (flags & 0x80) === 0;
                this.logDebug(`[SPIFFS] ===== Page at Block ${blockIdx}, Page ${pageIdx} (offset 0x${pageStart.toString(16)}) =====`);
                this.logDebug(`[SPIFFS]   Offset 0-1: obj_id = 0x${objId.toString(16).padStart(4, '0')}`);
                this.logDebug(`[SPIFFS]   Offset 2-3: span_ix = ${span} (0x${span.toString(16).padStart(4, '0')})`);
                this.logDebug(`[SPIFFS]   Offset 4:   flags = 0x${flags.toString(16).padStart(2, '0')} ${isDeleted ? '[DELETED]' : '[VALID]'}`);

                if (isIndexHeader) {
                    const sizeIsUndefined = fileSize === 0xFFFFFFFF;
                    const sizeLog = sizeIsUndefined ? 'undefined (0xFFFFFFFF)' : `${fileSize} bytes (0x${fileSize.toString(16)})`;
                    this.logDebug(`[SPIFFS]   Offset 8-11: size = ${sizeLog}`);
                    this.logDebug(`[SPIFFS]   Offset 12:   type = ${type} (${type === 0x01 ? 'FILE' : type === 0x02 ? 'DIR' : 'UNKNOWN'})`);
                    this.logDebug(`[SPIFFS]   Offset 13+:  name = "${nameStr}"`);

                    if ((type === 0x01 || type === 0x02) && nameStr !== '[NO NAME]' && nameStr.startsWith('/')) {
                        const displayName = isDeleted ? `${nameStr} (deleted)` : nameStr;
                        files.push({
                            name: displayName,
                            objId: objId,
                            size: fileSize > 0 && fileSize < 0xFFFFFFFF ? fileSize : 0,
                            blockIdx: blockIdx,
                            pageIdx: pageIdx,
                            type: type,
                            span: span,
                            flags: flags,
                            deleted: isDeleted
                        });
                        this.logDebug(`[SPIFFS]  Added to file list: "${displayName}" (deleted=${isDeleted})`);
                    } else {
                        this.logDebug(`[SPIFFS]  Skipped: not a valid file (type=${type}, name="${nameStr}")`);
                    }
                } else {
                    this.logDebug(`[SPIFFS]   (Data page, span_ix=${span})`);
                }
            }
        }

        this.logDebug(`[SPIFFS] Parsing complete. Found ${files.length} files.`);
        return {
            valid: validHeader || files.length > 0,
            magic: magic,
            blockSize: blockSizeActual,
            pageSize: pageSize,
            totalSize: size,
            files: files,
            filesCount: files.length
        };
    }

    async detectByPattern(data) {
        let foundPattern = false;
        for (let i = 0; i < Math.min(2048, data.length - 64); i += 256) {
            const b0 = data[i];
            const b1 = data[i + 1];
            const flags = data[i + 2];
            const objId = b0 | (b1 << 8);
            if (objId !== 0xFFFF && objId !== 0x0000 && flags !== 0xFF) {
                for (let j = i + 12; j < i + 64 && j < data.length; j++) {
                    if (data[j] === 0x2F) {
                        this.logDebug(`[SPIFFS] Pattern detected at offset 0x${i.toString(16)}: objId=0x${objId.toString(16)}, flags=0x${flags.toString(16)}`);
                        foundPattern = true;
                        break;
                    }
                }
                if (foundPattern) break;
            }
        }
        return foundPattern;
    }

    async readFile(file) {
        const offset = this.startOffset;
        const blockSize = this.spiffsInfo.blockSize;
        const pageSize = this.spiffsInfo.pageSize;
        const pagesPerBlock = Math.floor(blockSize / pageSize);
        const fileSize = file.size >>> 0;

        this.logDebug(`[SPIFFS] ========== Reading file "${file.name}" ==========`);
        this.logDebug(`[SPIFFS] objId(header)=0x${file.objId.toString(16)}, size=${fileSize} bytes`);
        this.logDebug(`[SPIFFS] Header page: block=${file.blockIdx}, page=${file.pageIdx}`);

        if (!fileSize) {
            this.logDebug(`[SPIFFS] File size is 0, returning empty array`);
            return new Uint8Array(0);
        }

        const IX_FLAG_MASK = 0x8000;
        const dataObjId = (file.objId & ~IX_FLAG_MASK) & 0xFFFF;

        const totalBlocks = Math.floor(this.spiffsInfo.totalSize / blockSize) || Math.floor(this.size / blockSize);
        const dataHeaderLen = 5;
        const dataPerPage = pageSize - dataHeaderLen;

        const spixToAddr = new Map();
        let pagesFound = 0;
        this.logDebug(`[SPIFFS] Scanning for data pages: target obj_id=0x${dataObjId.toString(16)}`);

        for (let blk = 0; blk < totalBlocks; blk++) {
            const blockBase = offset + blk * blockSize;
            const blockData = await this.buffer.slice_async(blockBase, blockBase + blockSize);
            for (let pg = 0; pg < pagesPerBlock; pg++) {
                const pageOffInBlock = pg * pageSize;
                if (pageOffInBlock + dataHeaderLen > blockData.length) break;
                const objId = blockData[pageOffInBlock] | (blockData[pageOffInBlock + 1] << 8);
                const span = blockData[pageOffInBlock + 2] | (blockData[pageOffInBlock + 3] << 8);
                const flags = blockData[pageOffInBlock + 4];
                if (objId === 0xFFFF || objId === 0x0000) continue;
                const isDeleted = (flags & 0x80) === 0;
                if (isDeleted) continue;
                if (objId === dataObjId) {
                    const paddr = blockBase + pageOffInBlock;
                    if (!spixToAddr.has(span)) {
                        spixToAddr.set(span, paddr);
                        pagesFound++;
                        if (pagesFound <= 8) {
                            this.logDebug(`[SPIFFS]   Data page: blk=${blk}, pg=${pg}, span_ix=${span}, paddr=0x${paddr.toString(16)}`);
                        }
                    }
                }
            }
        }

        this.logDebug(`[SPIFFS] Found ${pagesFound} data pages for obj_id=0x${dataObjId.toString(16)} (data_per_page=${dataPerPage})`);
        if (pagesFound === 0) {
            const headerOffset = offset + file.blockIdx * blockSize + file.pageIdx * pageSize;
            const naiveContent = headerOffset + pageSize;
            console.warn(`[SPIFFS] WARNING: No data pages found via scan. Falling back to next-page heuristic at 0x${naiveContent.toString(16)}`);
            const fileData = await this.buffer.slice_async(naiveContent, naiveContent + fileSize);
            this.logDebug(`[SPIFFS] Fallback read first 32 bytes: ${Array.from(fileData.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
            return fileData;
        }

        const out = new Uint8Array(fileSize);
        let curOff = 0;
        let logPreview = [];
        while (curOff < fileSize) {
            const spix = Math.floor(curOff / dataPerPage);
            const pageOff = curOff % dataPerPage;
            const lenToRead = Math.min(fileSize - curOff, dataPerPage - pageOff);
            if (!spixToAddr.has(spix)) {
                console.warn(`[SPIFFS] Missing data page for span_ix=${spix}, filling with 0xFF for ${lenToRead} bytes`);
                out.fill(0xFF, curOff, curOff + lenToRead);
                curOff += lenToRead;
                continue;
            }
            const paddr = spixToAddr.get(spix);
            const dataStart = paddr + dataHeaderLen + pageOff;
            const dataEnd = dataStart + lenToRead;
            const chunk = await this.buffer.slice_async(dataStart, dataEnd);
            out.set(chunk, curOff);
            if (logPreview.length < 4) {
                logPreview.push({ spix, paddr: dataStart, len: lenToRead });
            }
            curOff += lenToRead;
        }

        this.logDebug(`[SPIFFS] Read complete: ${out.length} bytes`);
        if (logPreview.length) {
            for (const e of logPreview) {
                this.logDebug(`[SPIFFS]   Read spix=${e.spix} at 0x${e.paddr.toString(16)} len=${e.len}`);
            }
        }
        this.logDebug(`[SPIFFS] First 32 bytes (hex): ${Array.from(out.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
        return out;
    }
}

class OTADataParser {
    constructor(sparseImage, offset, length) {
        if (!sparseImage) {
            throw new Error('OTADataParser requires a SparseImage');
        }
        if (offset === undefined || length === undefined) {
            throw new Error('OTADataParser requires offset and length parameters');
        }
        this.sparseImage = sparseImage;
        this.offset = offset;
        this.length = length;
        this.otaInfo = null;
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };

        // CRC32 lookup table for esp_rom_crc32_le
        this.crc32_le_table = new Uint32Array([
            0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
            0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
            0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
            0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
            0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
            0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
            0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
            0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
            0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
            0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
            0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
            0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
            0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
            0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
            0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
            0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,

            0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
            0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
            0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
            0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
            0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
            0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
            0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
            0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
            0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
            0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
            0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
            0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
            0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
            0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
            0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
            0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
        ]);
    }


    async initialize() {
        const OTA_DATA_SIZE = 0x1000;  // 4096 bytes (one sector)
        const data = await this.sparseImage.subarray_async(this.offset, this.offset + (OTA_DATA_SIZE * 2));

        // ESP32 IDF uses two sectors to store information about which partition is running
        // They are defined as the OTA data partition, two esp_ota_select_entry_t structures
        // are saved in the two sectors, named otadata[0] (first sector) and otadata[1] (second sector)
        // 
        // If otadata[0].ota_seq == otadata[1].ota_seq == 0xFFFFFFFF, OTA info partition is in init status
        // So it will boot factory application (if there is), otherwise boot ota[0]
        // 
        // If both ota_seq != 0, it will choose max seq, and calculate (max_seq - 1) % max_ota_app_number
        // to determine which OTA partition to boot (subtype mask 0x0F)

        // OTA image states
        const ESP_OTA_IMG_NEW = 0x0;
        const ESP_OTA_IMG_PENDING_VERIFY = 0x1;
        const ESP_OTA_IMG_VALID = 0x2;
        const ESP_OTA_IMG_INVALID = 0x3;
        const ESP_OTA_IMG_ABORTED = 0x4;
        const ESP_OTA_IMG_UNDEFINED = 0xFFFFFFFF;

        const entries = [];
        for (let i = 0; i < 2; i++) {
            const offset = i * OTA_DATA_SIZE;
            const view = new DataView(data.buffer, data.byteOffset + offset, OTA_DATA_SIZE);

            const seq = view.getUint32(0, true);
            const otaState = view.getUint32(24, true);  // Read as uint32
            const crc = view.getUint32(28, true);

            // CRC32 is calculated over first 4 bytes (sequence number) using esp_rom_crc32_le(UINT32_MAX, &ota_seq, 4)
            const dataForCRC = new Uint8Array(data.buffer, data.byteOffset + offset, 4);
            const calculatedCRC = this.calculateCRC32(dataForCRC);
            const crcValid = crc === calculatedCRC;

            // Entry is invalid if: seq == 0xFFFFFFFF OR ota_state == INVALID OR ota_state == ABORTED
            const isInvalid = seq === 0xFFFFFFFF || otaState === ESP_OTA_IMG_INVALID || otaState === ESP_OTA_IMG_ABORTED;

            // Entry is valid if: NOT invalid AND CRC matches
            const isValid = !isInvalid && crcValid;

            entries.push({
                index: i,
                sequence: seq,
                otaState: otaState,
                otaStateName: this.getOTAStateName(otaState),
                crc: crc,
                calculatedCRC: calculatedCRC,
                crcValid: crcValid,
                isValid: isValid,
                isEmpty: seq === 0xFFFFFFFF
            });
        }

        // Determine which entry is active using bootloader_common_get_active_otadata logic
        // Both must be valid, then choose highest sequence
        let activeEntry = null;
        if (entries[0].isValid && entries[1].isValid) {
            activeEntry = entries[0].sequence > entries[1].sequence ? 0 : 1;
        } else if (entries[0].isValid) {
            activeEntry = 0;
        } else if (entries[1].isValid) {
            activeEntry = 1;
        }

        this.otaInfo = {
            entries: entries,
            activeEntry: activeEntry
        };

        return this.otaInfo;
    }

    getOTAStateName(state) {
        const states = {
            0x0: 'NEW',
            0x1: 'PENDING_VERIFY',
            0x2: 'VALID',
            0x3: 'INVALID',
            0x4: 'ABORTED',
            0xFFFFFFFF: 'UNDEFINED'
        };
        return states[state] || `Unknown (0x${state.toString(16)})`;
    }

    // CRC32 using esp_rom_crc32_le() algorithm with lookup table
    // Matches ROM implementation: esp_rom_crc32_le(UINT32_MAX, &ota_seq, 4)
    calculateCRC32(data) {
        let crc = 0;  // Input 0xFFFFFFFF gets inverted to 0
        for (let i = 0; i < data.length; i++) {
            crc = this.crc32_le_table[(crc ^ data[i]) & 0xff] ^ (crc >>> 8);
        }
        return (~crc) >>> 0;  // Invert and return
    }
}

class NVSParser {
    constructor(sparseImage, startOffset, size) {
        if (!sparseImage) {
            throw new Error('NVSParser requires a SparseImage');
        }
        this.sparseImage = sparseImage;
        this.startOffset = startOffset;
        this.size = size;
        this.buffer = SparseImage._createProxy(sparseImage);
        this.view = sparseImage.createDataView();
        this.pages = null;
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    async initialize() {
        this.pages = await this.parse();
        return this.pages;
    }

    static bytesToHex(bytes, separator = '') {
        return Array.from(bytes)
            .map(b => b.toString(16).padStart(2, '0').toUpperCase())
            .join(separator);
    }

    static crc32Byte(crc, d) {
        for (let i = 0; i < 8; i++) {
            const bit = d & 1;
            crc ^= bit;
            crc = (crc & 1) ? (crc >>> 1) ^ 0xEDB88320 : crc >>> 1;
            d >>>= 1;
        }
        return crc >>> 0;
    }

    static crc32(data, offset = 0, length = null) {
        let crc = 0;
        const len = length ?? data.length - offset;
        for (let i = 0; i < len; i++) {
            crc = NVSParser.crc32Byte(crc, data[offset + i]);
        }
        return (~crc) >>> 0;
    }

    static crc32Header(data, offset = 0) {
        const buf = new Uint8Array(0x20 - 4);
        buf.set(data.subarray(offset, offset + 4), 0);
        buf.set(data.subarray(offset + 8, offset + 8 + 0x18), 4);
        return NVSParser.crc32(buf, 0, 0x1C);
    }

    async readString(offset, maxLength) {
        let result = '';
        for (let i = 0; i < maxLength; i++) {
            const byte = await this.view.getUint8(offset + i);
            if (byte === 0) break;
            if (byte >= 32 && byte <= 126) {
                result += String.fromCharCode(byte);
            } else if (byte !== 0) {
                return result;
            }
        }
        return result;
    }

    getNVSTypeName(datatype) {
        const types = {
            0x01: 'U8',
            0x02: 'U16',
            0x04: 'U32',
            0x08: 'U64',
            0x11: 'I8',
            0x12: 'I16',
            0x14: 'I32',
            0x18: 'I64',
            0x21: 'String',
            0x42: 'Blob',
            0x48: 'Blob Index'
        };
        return types[datatype] || `Unknown (0x${datatype.toString(16)})`;
    }

    getNVSItemState(stateBitmap, index) {
        const bmpIdx = Math.floor(index / 4);
        const bmpBit = (index % 4) * 2;
        return (stateBitmap[bmpIdx] >> bmpBit) & 3;
    }

    setNVSItemState(stateBitmap, index, state) {
        const bmpIdx = Math.floor(index / 4);
        const bmpBit = (index % 4) * 2;
        stateBitmap[bmpIdx] &= ~(3 << bmpBit);
        stateBitmap[bmpIdx] |= (state << bmpBit);
    }

    async parseItem(offset, namespaces) {
        if (offset + 32 > this.sparseImage.size) {
            return null;
        }

        const nsIndex = await this.view.getUint8(offset);
        const datatype = await this.view.getUint8(offset + 1);
        const span = await this.view.getUint8(offset + 2);
        const chunkIndex = await this.view.getUint8(offset + 3);
        const crc32 = await this.view.getUint32(offset + 4, true);
        const key = await this.readString(offset + 8, 16);

        if (span === 0 || span > 126) {
            console.warn(`Invalid span ${span} at offset ${offset}`);
            return null;
        }

        if (nsIndex !== 0 && (!key || key.length === 0)) {
            return null;
        }

        if (nsIndex !== 0) {
            for (let i = 0; i < key.length; i++) {
                const code = key.charCodeAt(i);
                if (code < 32 || code > 126) {
                    return null;
                }
            }
        }

        if (datatype === 0xFF || datatype === 0x00) {
            return null;
        }

        if (nsIndex === 0xFF) {
            return null;
        }

        const headerCrcCalc = NVSParser.crc32Header(this.buffer, offset);

        const item = {
            nsIndex: nsIndex,
            datatype: datatype,
            span: span,
            chunkIndex: chunkIndex,
            crc32: crc32 >>> 0,
            headerCrcCalc: headerCrcCalc >>> 0,
            headerCrcValid: (crc32 >>> 0) === (headerCrcCalc >>> 0),
            key: key,
            value: null,
            typeName: this.getNVSTypeName(datatype),
            isBlobChunk: false,
            offset: offset - this.startOffset,
            entrySize: 32
        };

        if (nsIndex === 0) {
            const namespaceIndex = await this.view.getUint8(offset + 24);
            item.value = namespaceIndex;
            item.namespace = key;
        } else {
            switch (datatype) {
                case 0x01:
                    item.value = await this.view.getUint8(offset + 24);
                    break;
                case 0x02:
                    item.value = await this.view.getUint16(offset + 24, true);
                    break;
                case 0x04:
                    item.value = await this.view.getUint32(offset + 24, true);
                    break;
                case 0x08:
                    item.value = (await this.view.getBigUint64(offset + 24, true)).toString();
                    break;
                case 0x11:
                    item.value = await this.view.getInt8(offset + 24);
                    break;
                case 0x12:
                    item.value = await this.view.getInt16(offset + 24, true);
                    break;
                case 0x14:
                    item.value = await this.view.getInt32(offset + 24, true);
                    break;
                case 0x18:
                    item.value = (await this.view.getBigInt64(offset + 24, true)).toString();
                    break;
                case 0x21: {
                    const strSize = await this.view.getUint16(offset + 24, true);
                    const strCrc = (await this.view.getUint32(offset + 28, true)) >>> 0;
                    if (strSize > 0 && strSize < 4096 && offset + 32 + strSize <= this.sparseImage.size) {
                        const strData = new Uint8Array(strSize);
                        for (let i = 0; i < strSize; i++) {
                            strData[i] = await this.view.getUint8(offset + 32 + i);
                        }
                        const allErased = strData.every(b => b === 0xFF);
                        let strValue = '';
                        for (let i = 0; i < strData.length; i++) {
                            if (strData[i] === 0) break;
                            if (strData[i] >= 32 && strData[i] <= 126) {
                                strValue += String.fromCharCode(strData[i]);
                            }
                        }
                        item.value = allErased ? '<erased>' : strValue;
                        item.rawValue = strData;
                        const dataCrcCalc = NVSParser.crc32(strData, 0, strSize);
                        item.dataCrcStored = strCrc >>> 0;
                        item.dataCrcCalc = dataCrcCalc >>> 0;
                        item.dataCrcValid = (dataCrcCalc >>> 0) === (strCrc >>> 0);
                        item.size = strSize;
                        item.entrySize = 32 + strSize;
                    } else {
                        item.value = '<invalid string>';
                        item.size = 0;
                    }
                    break;
                }
                case 0x42: {
                    const blobSize = await this.view.getUint16(offset + 24, true);
                    const blobCrc = (await this.view.getUint32(offset + 28, true)) >>> 0;
                    if (chunkIndex !== 0xFF) {
                        item.chunkIndex = chunkIndex;
                    }
                    if (blobSize > 0 && blobSize < 4096 && offset + 32 + blobSize <= this.sparseImage.size) {
                        const blobData = new Uint8Array(blobSize);
                        for (let i = 0; i < blobSize; i++) {
                            blobData[i] = await this.view.getUint8(offset + 32 + i);
                        }
                        const allErased = blobData.every(b => b === 0xFF);
                        item.value = allErased ? '<erased>' : NVSParser.bytesToHex(blobData, ' ');
                        item.rawValue = blobData;
                        const dataCrcCalc = NVSParser.crc32(blobData, 0, blobSize);
                        item.dataCrcStored = blobCrc >>> 0;
                        item.dataCrcCalc = dataCrcCalc >>> 0;
                        item.dataCrcValid = (dataCrcCalc >>> 0) === (blobCrc >>> 0);
                        item.size = blobSize;
                        item.entrySize = 32 + blobSize;
                    } else {
                        item.value = '<invalid blob>';
                        item.size = 0;
                    }
                    break;
                }
                case 0x48:
                    item.totalSize = await this.view.getUint32(offset + 24, true);
                    item.chunkCount = await this.view.getUint8(offset + 28);
                    item.chunkStart = await this.view.getUint8(offset + 29);
                    item.isBlobIndex = true;
                    item.value = `${item.chunkCount} chunks, ${item.totalSize} bytes total`;
                    break;
            }
        }

        return item;
    }

    async parse() {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;
        const NVS_PAGE_STATE = {
            UNINIT: 0xFFFFFFFF,
            ACTIVE: 0xFFFFFFFE,
            FULL: 0xFFFFFFFC,
            FREEING: 0xFFFFFFF8,
            CORRUPT: 0xFFFFFFF0
        };

        const pages = [];
        const namespaces = new Map();
        namespaces.set(0, '');

        //this.logDebug(`[NVS Parse] Starting NVS parse for partition at offset 0x${this.startOffset.toString(16)}, length 0x${this.size.toString(16)}`);

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;

            const state = await this.view.getUint32(blockOffset, true);
            const seq = await this.view.getUint32(blockOffset + 4, true);
            const version = await this.view.getUint8(blockOffset + 8);
            const crc32 = await this.view.getUint32(blockOffset + 28, true);

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);
            }

            let stateName = 'UNKNOWN';
            if (state === NVS_PAGE_STATE.UNINIT) {
                stateName = 'UNINIT';
                //this.logDebug(`[NVS Parse] Page at 0x${blockOffset.toString(16)}: UNINIT, skipping`);
                continue;
            } else if (state === NVS_PAGE_STATE.ACTIVE) {
                stateName = 'ACTIVE';
            } else if (state === NVS_PAGE_STATE.FULL) {
                stateName = 'FULL';
            } else if (state === NVS_PAGE_STATE.FREEING) {
                stateName = 'FREEING';
            } else if (state === NVS_PAGE_STATE.CORRUPT) {
                stateName = 'CORRUPT';
                //this.logDebug(`[NVS Parse] Page at 0x${blockOffset.toString(16)}: CORRUPT, skipping`);
                continue;
            }

            //this.logDebug(`[NVS Parse] Page at 0x${blockOffset.toString(16)}: state=${stateName}, seq=${seq}, version=${version}`);

            const page = {
                offset: blockOffset,
                state: stateName,
                seq: seq,
                version: version,
                crc32: crc32,
                items: []
            };

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                //this.logDebug(`[NVS Parse]   Entry ${entry}: state=${itemState} (0=ERASED, 2=WRITTEN, 3=EMPTY)`);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const nsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);

                //this.logDebug(`[NVS Parse]     nsIndex=${nsIndex}, datatype=0x${datatype.toString(16)}, span=${span}`);

                if (span === 0 || span > 126) {
                    console.warn(`[NVS Parse]     Invalid span ${span} at offset ${entryOffset}, skipping`);
                    continue;
                }

                if (nsIndex === 0 && datatype !== 0xFF && datatype !== 0x00) {
                    const key = await this.readString(entryOffset + 8, 16);
                    const namespaceIndex = await this.view.getUint8(entryOffset + 24);
                    //this.logDebug(`[NVS Parse]     Namespace definition: "${key}" -> index ${namespaceIndex}`);
                    if (key && namespaceIndex < 255) {
                        namespaces.set(namespaceIndex, key);
                    }
                }

                const item = await this.parseItem(entryOffset, namespaces);
                if (item) {
                    //this.logDebug(`[NVS Parse]     Parsed item: nsIndex=${item.nsIndex}, key="${item.key}", type=${item.typeName}, value=${JSON.stringify(item.value)}`);
                    page.items.push(item);
                    if (item.span > 1) {
                        entry += item.span - 1;
                    }
                } else {
                    this.logDebug(`[NVS Parse]     Item parsing returned null, skipping`);
                }
            }

            if (page.items.length > 0) {
                //this.logDebug(`[NVS Parse] Page added with ${page.items.length} items`);
                pages.push(page);
            } else {
                //this.logDebug(`[NVS Parse] Page has no items, not added`);
            }
        }

        for (const page of pages) {
            for (const item of page.items) {
                if (item.nsIndex !== undefined && item.nsIndex !== 0) {
                    item.namespace = namespaces.get(item.nsIndex) || `ns_${item.nsIndex}`;
                }
            }
        }

        //this.logDebug(`[NVS Parse] Parse complete: ${pages.length} pages, ${pages.reduce((sum, p) => sum + p.items.length, 0)} total items`);
        return pages;
    }

    /**
     * Build a map of namespace names to their indices
     * Returns: { name: index, ... }
     */
    async buildNamespaceMap() {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;
        const namespaceMap = {};

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);

                if (itemNsIndex === 0 && datatype !== 0xFF && datatype !== 0x00) {
                    const itemKey = await this.readString(entryOffset + 8, 16);
                    const namespaceIndex = await this.view.getUint8(entryOffset + 24);
                    if (itemKey && namespaceIndex < 255) {
                        namespaceMap[itemKey] = namespaceIndex;
                    }
                }

                entry += span - 1;
            }
        }

        return namespaceMap;
    }

    /**
     * Add a new namespace entry to NVS
     */
    async addNamespace(namespaceName) {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;

        let maxNsIndex = 0;
        const usedIndices = new Set();

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;

            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);
            }

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);
                const itemKey = await this.readString(entryOffset + 8, 16);

                if (itemNsIndex === 0 && datatype !== 0xFF && datatype !== 0x00) {
                    const existingIndex = await this.view.getUint8(entryOffset + 24);
                    usedIndices.add(existingIndex);
                    if (existingIndex > maxNsIndex) maxNsIndex = existingIndex;

                    if (itemKey === namespaceName) {
                        throw new Error(`Namespace "${namespaceName}" already exists with index ${existingIndex}`);
                    }
                }

                entry += span - 1;
            }
        }

        let newNsIndex = 1;
        while (usedIndices.has(newNsIndex) && newNsIndex < 255) newNsIndex++;
        if (newNsIndex >= 255) throw new Error('No available namespace indices (max 254 namespaces)');

        this.logDebug(`[NVS AddNamespace] Creating namespace "${namespaceName}" with index ${newNsIndex}`);

        const entry = new Uint8Array(32);
        entry[0] = 0;
        entry[1] = 0x01;
        entry[2] = 1;
        entry[3] = 0xFF;

        const keyBytes = new TextEncoder().encode(namespaceName);
        for (let i = 0; i < Math.min(keyBytes.length, 15); i++) entry[8 + i] = keyBytes[i];
        entry[8 + Math.min(keyBytes.length, 15)] = 0;
        entry[24] = newNsIndex;

        const headerCrc = NVSParser.crc32Header(entry);
        new DataView(entry.buffer).setUint32(4, headerCrc, true);

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;
            if (state !== 0xFFFFFFFE && state !== 0xFFFFFFFC) continue;

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

            for (let entryIdx = 0; entryIdx < MAX_ENTRY_COUNT; entryIdx++) {
                const itemState = this.getNVSItemState(stateBitmap, entryIdx);
                if (itemState === 3 || itemState === 0) {
                    const entryOffset = blockOffset + 64 + entryIdx * 32;
                    this.logDebug(`[NVS AddNamespace] Writing namespace definition at entry ${entryIdx}, offset 0x${entryOffset.toString(16)}`);
                    this.sparseImage.write(entryOffset, entry);
                    this.setNVSItemState(stateBitmap, entryIdx, 2);
                    this.sparseImage.write(blockOffset + 32, stateBitmap);
                    this.logDebug(`[NVS AddNamespace] Successfully added namespace "${namespaceName}" with index ${newNsIndex}`);
                    return;
                }
            }
        }

        throw new Error('No space available in NVS partition for namespace definition');
    }

    /**
     * Delete an item by namespace + key, and also delete the vice versa entry (Blob <-> BlobIndex)
     */
    async deleteItem(namespace, key) {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;
        const BLOB_TYPE = 0x42;
        const BLOB_INDEX_TYPE = 0x48;

        this.logDebug(`[NVS Delete] Starting delete for ${namespace}.${key}`);

        /* Build namespace map first */
        const namespaceMap = await this.buildNamespaceMap();
        this.logDebug(`[NVS Delete] Namespace map:`, namespaceMap);

        const nsIndex = namespaceMap[namespace];
        if (nsIndex === undefined) {
            this.logDebug(`[NVS Delete] Namespace "${namespace}" not found in map`);
            throw new Error(`NVS namespace ${namespace} not found`);
        }
        this.logDebug(`[NVS Delete] Target namespace "${namespace}" has index ${nsIndex}`);

        let foundItemType = null;

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

            const stateName =
                state === 0xFFFFFFFF ? 'UNINIT' :
                    state === 0xFFFFFFFE ? 'ACTIVE' :
                        state === 0xFFFFFFFC ? 'FULL' :
                            state === 0xFFFFFFF8 ? 'FREEING' :
                                state === 0xFFFFFFF0 ? 'CORRUPT' : `UNKNOWN(0x${state.toString(16)})`;
            this.logDebug(`[NVS Delete] Scanning page at 0x${blockOffset.toString(16)} state=${stateName}`);

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);
                const itemKey = await this.readString(entryOffset + 8, 16);

                this.logDebug(`[NVS Delete]   Entry ${entry}: ns=${itemNsIndex}, type=0x${datatype.toString(16)}, span=${span}, key="${itemKey}"`);

                /* Skip namespace definitions */
                if (itemNsIndex === 0) {
                    entry += span - 1;
                    continue;
                }

                if (itemNsIndex === nsIndex && itemKey === key) {
                    foundItemType = datatype;
                    this.logDebug(`[NVS Delete]   Found target item at entry ${entry}, offset 0x${entryOffset.toString(16)}, span=${span}. Erasing...`);
                    for (let slice = 0; slice < span; slice++) {
                        const sliceOffset = entryOffset + slice * 32;
                        const erasedEntry = new Uint8Array(32);
                        erasedEntry.fill(0xFF);
                        this.sparseImage.write(sliceOffset, erasedEntry);
                        this.setNVSItemState(stateBitmap, entry + slice, 3);
                    }
                    this.sparseImage.write(blockOffset + 32, stateBitmap);
                    this.logDebug(`[NVS Delete]   Erase complete and state bitmap updated for page at 0x${blockOffset.toString(16)}`);
                    break;
                }

                entry += span - 1;
            }

            if (foundItemType !== null) break;
        }

        if (foundItemType === null) {
            this.logDebug(`[NVS Delete] Item ${namespace}.${key} not found (nsIndex=${nsIndex})`);
            throw new Error(`NVS item ${namespace}.${key} not found`);
        }

        /* If deleting a Blob (0x42), also delete the BlobIndex (0x48) */
        /* If deleting a BlobIndex (0x48), also delete the Blob chunks (0x42) */
        if (foundItemType === BLOB_TYPE || foundItemType === BLOB_INDEX_TYPE) {
            const complementaryType = (foundItemType === BLOB_TYPE) ? BLOB_INDEX_TYPE : BLOB_TYPE;
            this.logDebug(`[NVS Delete] Item is a Blob${foundItemType === BLOB_TYPE ? 'Index' : ''}, searching for complementary ${complementaryType === BLOB_TYPE ? 'Blob' : 'BlobIndex'} entry...`);

            for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
                const blockOffset = this.startOffset + sectorOffset;
                if (blockOffset + 64 > this.sparseImage.size) break;
                const state = await this.view.getUint32(blockOffset, true);
                if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

                const stateBitmap = new Uint8Array(32);
                for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

                for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                    const itemState = this.getNVSItemState(stateBitmap, entry);
                    if (itemState !== 2) continue;

                    const entryOffset = blockOffset + 64 + entry * 32;
                    if (entryOffset + 32 > this.sparseImage.size) break;

                    const itemNsIndex = await this.view.getUint8(entryOffset);
                    const datatype = await this.view.getUint8(entryOffset + 1);
                    const span = await this.view.getUint8(entryOffset + 2);
                    const itemKey = await this.readString(entryOffset + 8, 16);

                    /* Skip if not the complementary type or wrong namespace/key */
                    if (datatype !== complementaryType || itemNsIndex !== nsIndex || itemKey !== key) {
                        entry += span - 1;
                        continue;
                    }

                    this.logDebug(`[NVS Delete]   Found complementary ${complementaryType === BLOB_TYPE ? 'Blob' : 'BlobIndex'} entry at entry ${entry}, offset 0x${entryOffset.toString(16)}, span=${span}. Erasing...`);
                    for (let slice = 0; slice < span; slice++) {
                        const sliceOffset = entryOffset + slice * 32;
                        const erasedEntry = new Uint8Array(32);
                        erasedEntry.fill(0xFF);
                        this.sparseImage.write(sliceOffset, erasedEntry);
                        this.setNVSItemState(stateBitmap, entry + slice, 3);
                    }
                    this.sparseImage.write(blockOffset + 32, stateBitmap);
                    this.logDebug(`[NVS Delete]   Complementary entry erase complete`);
                    return;
                }
            }

            this.logDebug(`[NVS Delete] No complementary ${complementaryType === BLOB_TYPE ? 'Blob' : 'BlobIndex'} entry found for ${namespace}.${key}`);
        }
    }

    /**
     * Add an item
     */
    async addItem(namespace, key, type, value) {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;

        const item = this.createItem(key, type, value);
        let nsIndex = -1;

        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;

            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);

            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;

                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;

                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);
                const itemKey = await this.readString(entryOffset + 8, 16);

                if (itemNsIndex === 0 && datatype !== 0xFF && datatype !== 0x00 && itemKey === namespace) {
                    nsIndex = await this.view.getUint8(entryOffset + 24);
                }

                entry += span - 1;
            }

            if (nsIndex !== -1) {
                for (let entry = 0; entry < MAX_ENTRY_COUNT && (entry + item.span - 1 < MAX_ENTRY_COUNT); entry++) {
                    let hasSpace = true;
                    for (let slice = 0; slice < item.span; slice++) {
                        const sliceState = this.getNVSItemState(stateBitmap, entry + slice);
                        if (sliceState === 2) { hasSpace = false; break; }
                    }

                    if (hasSpace) {
                        const entryOffset = blockOffset + 64 + entry * 32;

                        /* Set nsIndex for all entries and calculate header CRC */
                        for (let i = 0; i < item.entries.length; i++) {
                            if (item.entries[i][0] === 0) {
                                item.entries[i][0] = nsIndex;
                                const headerCrc = NVSParser.crc32Header(item.entries[i]);
                                new DataView(item.entries[i].buffer).setUint32(4, headerCrc, true);
                            }
                        }

                        this.logDebug(`[NVS Add] Writing item at entry ${entry}, nsIndex=${nsIndex}, key="${key}", span=${item.span}, entries=${item.entries.length}`);

                        for (let slice = 0; slice < item.entries.length; slice++) {
                            const sliceOffset = entryOffset + slice * 32;
                            this.sparseImage.write(sliceOffset, item.entries[slice]);
                            this.setNVSItemState(stateBitmap, entry + slice, 2);
                        }

                        this.sparseImage.write(blockOffset + 32, stateBitmap);
                        this.logDebug(`[NVS Add] Successfully added item to partition`);
                        return;
                    }

                    const curState = this.getNVSItemState(stateBitmap, entry);
                    if (curState === 2) {
                        const entryOffset = blockOffset + 64 + entry * 32;
                        const entrySpan = await this.view.getUint8(entryOffset + 2);
                        entry += entrySpan - 1;
                    }
                }
            }
        }

        throw new Error(`No space available in NVS partition or namespace ${namespace} not found`);
    }

    /**
     * Create entries for an item
     */
    createItem(key, type, value) {
        const typeMap = {
            'U8': 0x01, 'U16': 0x02, 'U32': 0x04, 'U64': 0x08,
            'I8': 0x11, 'I16': 0x12, 'I32': 0x14, 'I64': 0x18,
            'String': 0x21, 'Blob': 0x42, 'BlobSmall': 0x42
        };

        const datatype = typeMap[type];
        if (!datatype) throw new Error(`Unknown type: ${type}`);

        const entry = new Uint8Array(32);
        entry.fill(0xFF);
        entry[0] = 0; /* nsIndex will be set later */
        entry[1] = datatype;
        entry[3] = 0xFF; /* chunkIndex */

        const keyBytes = new TextEncoder().encode(key.substring(0, 15));
        entry.set(keyBytes, 8);
        entry[8 + keyBytes.length] = 0;

        const entries = [];

        switch (type) {
            case 'U8': {
                const val = parseInt(value);
                if (isNaN(val) || val < 0 || val > 255) throw new Error('Invalid U8 value');
                entry[24] = val;
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'U16': {
                const val = parseInt(value);
                if (isNaN(val) || val < 0 || val > 65535) throw new Error('Invalid U16 value');
                new DataView(entry.buffer).setUint16(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'U32': {
                const val = parseInt(value);
                if (isNaN(val) || val < 0 || val > 4294967295) throw new Error('Invalid U32 value');
                new DataView(entry.buffer).setUint32(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'U64': {
                const val = BigInt(value);
                if (val < 0n || val > 18446744073709551615n) throw new Error('Invalid U64 value');
                new DataView(entry.buffer).setBigUint64(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'I8': {
                const val = parseInt(value);
                if (isNaN(val) || val < -128 || val > 127) throw new Error('Invalid I8 value');
                new DataView(entry.buffer).setInt8(24, val);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'I16': {
                const val = parseInt(value);
                if (isNaN(val) || val < -32768 || val > 32767) throw new Error('Invalid I16 value');
                new DataView(entry.buffer).setInt16(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'I32': {
                const val = parseInt(value);
                if (isNaN(val) || val < -2147483648 || val > 2147483647) throw new Error('Invalid I32 value');
                new DataView(entry.buffer).setInt32(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'I64': {
                const val = BigInt(value);
                if (val < -9223372036854775808n || val > 9223372036854775807n) throw new Error('Invalid I64 value');
                new DataView(entry.buffer).setBigInt64(24, val, true);
                entry[2] = 1;
                entries.push(entry);
                break;
            }
            case 'String': {
                const strBytes = new TextEncoder().encode(value);
                if (strBytes.length > 64) throw new Error('String too long (max 64 bytes)');
                new DataView(entry.buffer).setUint16(24, strBytes.length, true);
                const dataCrc = NVSParser.crc32(strBytes);
                new DataView(entry.buffer).setUint32(28, dataCrc, true);
                const span = 1 + Math.ceil(strBytes.length / 32);
                entry[2] = span;
                entries.push(entry);
                const dataEntry = new Uint8Array(32 * (span - 1));
                dataEntry.fill(0xFF);
                dataEntry.set(strBytes, 0);
                for (let i = 0; i < span - 1; i++) entries.push(dataEntry.slice(i * 32, (i + 1) * 32));
                break;
            }
            case 'BlobSmall': {
                const hexBytes = value.split(/\s+/).filter(b => b).map(b => parseInt(b, 16));
                if (hexBytes.some(b => isNaN(b) || b < 0 || b > 255)) throw new Error('Invalid hex bytes');
                if (hexBytes.length > 32) throw new Error('BlobSmall too long (max 32 bytes)');
                const blobData = new Uint8Array(hexBytes);

                /* Small blob: single entry without blob index */
                new DataView(entry.buffer).setUint16(24, blobData.length, true);
                /* Reserved bytes (26-27) must stay 0xFF to match firmware */
                entry[26] = 0xFF;
                entry[27] = 0xFF;
                const dataCrc = NVSParser.crc32(blobData);
                new DataView(entry.buffer).setUint32(28, dataCrc, true);
                const span = 1 + Math.ceil(blobData.length / 32);
                entry[2] = span;
                entry[3] = 0; /* chunkIndex for first chunk */
                entries.push(entry);
                if (span > 1) {
                    const dataEntry = new Uint8Array(32 * (span - 1));
                    dataEntry.fill(0xFF);
                    dataEntry.set(blobData, 0);
                    for (let i = 0; i < span - 1; i++) entries.push(dataEntry.slice(i * 32, (i + 1) * 32));
                }
                break;
            }
            case 'Blob': {
                const hexBytes = value.split(/\s+/).filter(b => b).map(b => parseInt(b, 16));
                if (hexBytes.some(b => isNaN(b) || b < 0 || b > 255)) throw new Error('Invalid hex bytes');
                if (hexBytes.length > 1984) throw new Error('Blob too long (max 1984 bytes)');
                const blobData = new Uint8Array(hexBytes);

                {
                    /* Large blob: write blob chunks first, then blob index (firmware order) */
                    const indexEntry = new Uint8Array(32);
                    indexEntry.fill(0x00);
                    indexEntry[0] = 0; /* nsIndex will be set later */
                    indexEntry[1] = 0x48; /* Blob Index type */
                    indexEntry[2] = 1; /* span */
                    indexEntry[3] = 0xFF; /* chunkIndex */
                    const keyBytes = new TextEncoder().encode(key.substring(0, 15));
                    indexEntry.set(keyBytes, 8);
                    indexEntry[8 + keyBytes.length] = 0;
                    new DataView(indexEntry.buffer).setUint32(24, blobData.length, true); /* totalSize */

                    /* Calculate number of chunks needed */
                    const maxChunkSize = 32 + 31 * 32; /* first entry has 32 bytes, each additional can hold 32 bytes */
                    const chunkCount = Math.ceil(blobData.length / maxChunkSize);
                    indexEntry[28] = chunkCount; /* chunkCount */
                    indexEntry[29] = 0; /* chunkStart */

                    /* Create chunk entries first */
                    let offset = 0;
                    for (let chunkIdx = 0; chunkIdx < chunkCount; chunkIdx++) {
                        const chunkSize = Math.min(maxChunkSize, blobData.length - offset);
                        const chunkData = blobData.slice(offset, offset + chunkSize);

                        const chunkEntry = new Uint8Array(32);
                        chunkEntry.fill(0x00);
                        chunkEntry[0] = 0; /* nsIndex will be set later */
                        chunkEntry[1] = 0x42; /* Blob type */
                        const chunkSpan = 1 + Math.ceil(chunkSize / 32);
                        chunkEntry[2] = chunkSpan;
                        chunkEntry[3] = chunkIdx; /* chunkIndex */
                        chunkEntry.set(keyBytes, 8);
                        chunkEntry[8 + keyBytes.length] = 0;
                        new DataView(chunkEntry.buffer).setUint16(24, chunkSize, true);
                        /* Reserved bytes (26-27) must stay 0xFF to match firmware */
                        chunkEntry[26] = 0xFF;
                        chunkEntry[27] = 0xFF;
                        const chunkCrc = NVSParser.crc32(chunkData);
                        new DataView(chunkEntry.buffer).setUint32(28, chunkCrc, true);

                        entries.push(chunkEntry);

                        const chunkDataEntry = new Uint8Array(32 * (chunkSpan - 1));
                        chunkDataEntry.fill(0xFF);
                        chunkDataEntry.set(chunkData, 0);
                        for (let i = 0; i < chunkSpan - 1; i++) {
                            entries.push(chunkDataEntry.slice(i * 32, (i + 1) * 32));
                        }

                        offset += chunkSize;
                    }

                    /* Append blob index after all chunks (firmware ordering) */
                    entries.push(indexEntry);
                }
                break;
            }
        }

        /* Calculate total span (sum of all entry spans, but entries array contains all 32-byte blocks) */
        const totalSpan = entries.length;

        const headerCrc = NVSParser.crc32Header(entries[0]);
        new DataView(entries[0].buffer).setUint32(4, headerCrc, true);

        return { span: totalSpan, entries };
    }

    /**
     * Convenience: update item by deleting and re-adding
     */
    async updateItem(namespace, key, type, value) {
        try { await this.deleteItem(namespace, key); } catch (e) { /* ignore if not exists */ }
        await this.addItem(namespace, key, type, value);
    }

    /**
     * Find item metadata by namespace/key
     */
    async findItem(namespace, key) {
        const NVS_SECTOR_SIZE = 4096;
        const MAX_ENTRY_COUNT = 126;
        let nsIndex = -1;
        for (let sectorOffset = 0; sectorOffset < this.size; sectorOffset += NVS_SECTOR_SIZE) {
            const blockOffset = this.startOffset + sectorOffset;
            if (blockOffset + 64 > this.sparseImage.size) break;
            const state = await this.view.getUint32(blockOffset, true);
            if (state === 0xFFFFFFFF || state === 0xFFFFFFF0) continue;
            const stateBitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) stateBitmap[i] = await this.view.getUint8(blockOffset + 32 + i);
            for (let entry = 0; entry < MAX_ENTRY_COUNT; entry++) {
                const itemState = this.getNVSItemState(stateBitmap, entry);
                if (itemState !== 2) continue;
                const entryOffset = blockOffset + 64 + entry * 32;
                if (entryOffset + 32 > this.sparseImage.size) break;
                const itemNsIndex = await this.view.getUint8(entryOffset);
                const datatype = await this.view.getUint8(entryOffset + 1);
                const span = await this.view.getUint8(entryOffset + 2);
                const itemKey = await this.readString(entryOffset + 8, 16);
                if (itemNsIndex === 0 && datatype !== 0xFF && datatype !== 0x00) {
                    const namespaceIndex = await this.view.getUint8(entryOffset + 24);
                    if (itemKey === namespace) nsIndex = namespaceIndex;
                    entry += span - 1;
                    continue;
                }
                if (nsIndex === itemNsIndex && itemKey === key) {
                    return { blockOffset, entryIndex: entry, entryOffset, span };
                }
                entry += span - 1;
            }
        }
        return null;
    }
}


/**
 * DataView-like wrapper for SparseImage
 */
class SparseImageDataView {
    constructor(sparseImage) {
        this.sparseImage = sparseImage;
        this.byteLength = sparseImage.size;
    }

    async _ensureData(offset, size) {
        await this.sparseImage._ensureData(offset, size);
    }

    async getUint8(offset) {
        await this._ensureData(offset, 1);
        return this.sparseImage._get(offset);
    }

    async getInt8(offset) {
        const val = await this.getUint8(offset);
        return val > 127 ? val - 256 : val;
    }

    async getUint16(offset, littleEndian = false) {
        await this._ensureData(offset, 2);
        const b0 = this.sparseImage._get(offset);
        const b1 = this.sparseImage._get(offset + 1);
        return littleEndian ? (b1 << 8) | b0 : (b0 << 8) | b1;
    }

    async getInt16(offset, littleEndian = false) {
        const val = await this.getUint16(offset, littleEndian);
        return val > 32767 ? val - 65536 : val;
    }

    async getUint32(offset, littleEndian = false) {
        await this._ensureData(offset, 4);
        const b0 = this.sparseImage._get(offset);
        const b1 = this.sparseImage._get(offset + 1);
        const b2 = this.sparseImage._get(offset + 2);
        const b3 = this.sparseImage._get(offset + 3);
        return (littleEndian
            ? (b3 << 24) | (b2 << 16) | (b1 << 8) | b0
            : (b0 << 24) | (b1 << 16) | (b2 << 8) | b3) >>> 0; /* Force unsigned 32-bit */
    }

    async getInt32(offset, littleEndian = false) {
        return await this.getUint32(offset, littleEndian) | 0;
    }

    async getBigUint64(offset, littleEndian = false) {
        await this._ensureData(offset, 8);
        if (littleEndian) {
            const low = await this.getUint32(offset, true);
            const high = await this.getUint32(offset + 4, true);
            return (BigInt(high) << 32n) | BigInt(low);
        } else {
            const high = await this.getUint32(offset, false);
            const low = await this.getUint32(offset + 4, false);
            return (BigInt(high) << 32n) | BigInt(low);
        }
    }

    async getBigInt64(offset, littleEndian = false) {
        return await this.getBigUint64(offset, littleEndian);
    }
}

class ESP32Parser {
    constructor(input, options = {}) {
        /* Options structure:
         * {
         *   readDataCallback: async function(addr, len) -> { address, data }
         *   writeDataCallback: async function(addr, data) -> void
         *   sizeHint: number (for lazy-loading without explicit size)
         *   preReadCommandCbr: function(addr, len) -> void
         *   postReadCommandCbr: function(addr, len) -> void
         *   preReadBlockCbr: function() -> void
         *   readBlockCbr: function(bytesRead, totalBytes) -> void
         *   postReadBlockCbr: function() -> void
         *   preWriteCommandCbr: function(addr, len) -> void
         *   postWriteCommandCbr: function(addr, len) -> void
         *   writeBlockCbr: function(offset, total, status) -> void
         *   preFlushPrepareCbr: function(sparseImage) -> void
         *   postFlushPrepareCbr: function(sparseImage) -> void
         * }
         */

        /* Store callback references for use in async handlers */
        this.callbacks = {
            preReadCommandCbr: options.preReadCommandCbr,
            postReadCommandCbr: options.postReadCommandCbr,
            preReadBlockCbr: options.preReadBlockCbr,
            readBlockCbr: options.readBlockCbr,
            postReadBlockCbr: options.postReadBlockCbr,
            preWriteCommandCbr: options.preWriteCommandCbr,
            postWriteCommandCbr: options.postWriteCommandCbr,
            writeBlockCbr: options.writeBlockCbr,
            preFlushPrepareCbr: options.preFlushPrepareCbr,
            postFlushPrepareCbr: options.postFlushPrepareCbr
        };

        this.logMessage = options.logMessage || ((msg) => { });
        this.logDebug = options.logDebug || ((msg) => { });
        this.logWarning = options.logWarning || ((msg) => { });
        this.logError = options.logError || ((msg) => { });

        // Cases:
        // 1) input is ESPFlasher - use it directly as this.flasher
        // 2) input is SparseImage
        // 3) input is Uint8Array/ArrayBuffer (eager data)
        // 4) input is number (size) with readDataCallback (and optional writeDataCallback)
        // 5) input is null/undefined but readDataCallback provided with sizeHint

        this.flasher = null;

        if (input instanceof ESPFlasher) {
            /* ESPFlasher device path */
            this.flasher = input;
            this.sparseImage = new SparseImage(
                options.sizeHint ?? 0,
                this._onSparseImageRead.bind(this),
                this._onSparseImageWrite.bind(this),
                this._onSparseImageFlushPrepare.bind(this)
            );
        } else if (input instanceof SparseImage) {
            /* SparseImage provided directly */
            this.sparseImage = input;
        } else if (input instanceof Uint8Array || input instanceof ArrayBuffer) {
            /* Eager buffer path, backward compatible */
            this.sparseImage = SparseImage.fromBuffer(input);
        } else if (typeof input === 'number') {
            /* Size provided directly */
            this.sparseImage = new SparseImage(input, options.readDataCallback, options.writeDataCallback);
        } else if ((input === null || input === undefined) && options.readDataCallback) {
            /* Lazy-only path needs a size hint */
            this.sparseImage = new SparseImage(options.sizeHint ?? 0, options.readDataCallback, options.writeDataCallback);
        } else {
            throw new Error('Invalid constructor arguments for ESP32Parser. Provide ESPFlasher, Uint8Array/ArrayBuffer, SparseImage, or size with readDataCallback.');
        }

        this.buffer = SparseImage._createProxy(this.sparseImage);
        this.view = this.sparseImage.createDataView();
        this.partitions = [];
        this.nvsData = [];
        this.logMessage = (msg) => { };
        this.logDebug = (msg) => { };
        this.logError = (msg) => { };
    }

    /**
     * SparseImage read callback for ESPFlasher device
     * Reads flash data from the device, respecting alignment and size constraints
     */
    async _onSparseImageRead(readAddr, readLen) {
        const addr = readAddr & ~0x0FFF;
        const maxChunk = 0x00800000;
        const desired = Math.min(readLen, maxChunk);
        let len = (desired + 0x1000) & ~0x0FFF;

        this.callbacks.preReadCommandCbr && this.callbacks.preReadCommandCbr(addr, len);

        const totalSize = this.sparseImage.size;
        /* Ensure we don't read beyond configured flash size */
        if (addr >= totalSize) {
            throw new Error(`Read address 0x${addr.toString(16)} exceeds flash size 0x${totalSize.toString(16)}`);
        }
        len = Math.min(len, totalSize - addr);
        if (len <= 0) {
            throw new Error(`Invalid read length at address 0x${addr.toString(16)}`);
        }

        try {
            this.callbacks.preReadBlockCbr && this.callbacks.preReadBlockCbr();
            const ret = await this.flasher.readFlashPlain(addr, len, (bytesRead, totalBytes) => {
                this.callbacks.readBlockCbr && this.callbacks.readBlockCbr(addr, len, bytesRead, totalBytes);
            });
            this.callbacks.postReadBlockCbr && this.callbacks.postReadBlockCbr();
            const chunk = { address: addr, data: ret };
            this.callbacks.postReadCommandCbr && this.callbacks.postReadCommandCbr(addr, len);
            return chunk;
        } catch (readError) {
            this.logError('Device read error:', readError);
            throw readError;
        }
    }

    /**
     * SparseImage write callback for ESPFlasher device
     * Writes flash data to the device with alignment validation
     */
    async _onSparseImageWrite(writeAddr, writeData) {
        this.callbacks.preWriteCommandCbr && this.callbacks.preWriteCommandCbr(writeAddr, writeData.length);

        /* Write callback for flushing changes to device */
        if (writeAddr % 0x1000 !== 0) {
            throw new Error(`Write address 0x${writeAddr.toString(16)} is not aligned to 0x1000 bytes`);
        }
        if (writeData.length % 0x1000 !== 0) {
            throw new Error(`Write data length ${writeData.length} is not aligned to 0x1000 bytes`);
        }
        try {
            await this.flasher.writeFlash(writeAddr, writeData, (offset, total, status) => {
                this.callbacks.writeBlockCbr && this.callbacks.writeBlockCbr(writeAddr, writeData, offset, total, status);
            });
        } catch (writeError) {
            this.logError('Device write error:', writeError);
            throw writeError;
        }
        this.callbacks.postWriteCommandCbr && this.callbacks.postWriteCommandCbr(writeAddr, writeData.length);
    }

    /**
     * SparseImage flush prepare callback for ESPFlasher device
     * Consolidates write buffer into 4KB-aligned blocks
     */
    async _onSparseImageFlushPrepare(sparseImage) {
        this.callbacks.preFlushPrepareCbr && this.callbacks.preFlushPrepareCbr();

        /* Flush prepare callback: combine cached and write data into 0x1000-byte blocks */
        this.logDebug('Flush prepare: consolidating write buffer into 4KB-aligned blocks');

        if (sparseImage.writeBuffer.length === 0) return;

        /* Get the range we need to cover */
        let minAddr = Infinity;
        let maxAddr = 0;

        for (const seg of sparseImage.writeBuffer) {
            minAddr = Math.min(minAddr, seg.address);
            maxAddr = Math.max(maxAddr, seg.address + seg.data.length);
        }

        if (minAddr === Infinity) return; /* Nothing to do */

        /* Align to 0x1000 byte boundaries */
        const blockStart = minAddr & ~0x0FFF;
        const blockEnd = (maxAddr + 0x0FFF) & ~0x0FFF;

        this.logDebug(`Prepare: processing range 0x${blockStart.toString(16)} - 0x${blockEnd.toString(16)}`);

        /* Build aligned blocks: prefer writeBuffer-only materialization; otherwise read via sparse image */
        const blockMap = new Map(); /* blockAddr -> blockData */

        for (let blockAddr = blockStart; blockAddr < blockEnd; blockAddr += 0x1000) {
            const blockEndAddr = blockAddr + 0x1000;

            const overlaps = [];
            for (const seg of sparseImage.writeBuffer) {
                const segStart = seg.address;
                const segEnd = seg.address + seg.data.length;
                const overlapStart = Math.max(blockAddr, segStart);
                const overlapEnd = Math.min(blockEndAddr, segEnd);
                if (overlapStart < overlapEnd) {
                    overlaps.push({ start: overlapStart, end: overlapEnd, seg });
                }
            }

            /* Skip blocks with no write data at all */
            if (overlaps.length === 0) {
                continue;
            }

            overlaps.sort((a, b) => a.start - b.start);

            let coveredCursor = blockAddr;
            for (const ov of overlaps) {
                if (ov.start > coveredCursor) {
                    break;
                }
                if (ov.end > coveredCursor) {
                    coveredCursor = ov.end;
                }
                if (coveredCursor >= blockEndAddr) {
                    break;
                }
            }

            const fullyCovered = coveredCursor >= blockEndAddr;
            let blockData;

            if (fullyCovered) {
                blockData = new Uint8Array(0x1000);
                blockData.fill(0xFF);
                for (const ov of overlaps) {
                    const srcOff = ov.start - ov.seg.address;
                    const dstOff = ov.start - blockAddr;
                    const len = ov.end - ov.start;
                    blockData.set(ov.seg.data.slice(srcOff, srcOff + len), dstOff);
                }
            } else {
                blockData = await sparseImage.slice_async(blockAddr, blockEndAddr);
            }

            blockMap.set(blockAddr, blockData);
        }

        /* Merge touching/consecutive blocks */
        const mergedBlocks = [];
        const blockAddrs = Array.from(blockMap.keys()).sort((a, b) => a - b);

        let currentStart = null;
        let currentData = null;

        for (const blockAddr of blockAddrs) {
            if (currentStart === null) {
                /* Start new merged block */
                currentStart = blockAddr;
                currentData = new Uint8Array(blockMap.get(blockAddr));
            } else if (currentStart + currentData.length === blockAddr) {
                /* Consecutive block: merge it */
                const mergedData = new Uint8Array(currentData.length + 0x1000);
                mergedData.set(currentData, 0);
                mergedData.set(blockMap.get(blockAddr), currentData.length);
                currentData = mergedData;
            } else {
                /* Gap detected: save current merged block and start new one */
                mergedBlocks.push({ address: currentStart, data: currentData });
                this.logDebug(`  Merged block at 0x${currentStart.toString(16)}, size: ${currentData.length} bytes`);
                currentStart = blockAddr;
                currentData = new Uint8Array(blockMap.get(blockAddr));
            }
        }

        /* Add final merged block */
        if (currentStart !== null) {
            mergedBlocks.push({ address: currentStart, data: currentData });
            this.logDebug(`  Merged block at 0x${currentStart.toString(16)}, size: ${currentData.length} bytes`);
        }

        /* Replace write buffer with merged blocks */
        sparseImage.writeBuffer = mergedBlocks;

        this.logDebug(`Flush prepare complete: ${mergedBlocks.length} blocks aligned and ready`);

        this.callbacks.postFlushPrepareCbr && this.callbacks.postFlushPrepareCbr();
    }

    static bytesToHex(bytes, separator = '') {
        return Array.from(bytes)
            .map(b => b.toString(16).padStart(2, '0').toUpperCase())
            .join(separator);
    }

    static crc32Byte(crc, d) {
        // Process exactly 8 bits of the byte, matching esp32.c behavior
        for (let i = 0; i < 8; i++) {
            const bit = d & 1;
            crc ^= bit;
            crc = (crc & 1) ? (crc >>> 1) ^ 0xEDB88320 : crc >>> 1;
            d >>>= 1;
        }
        return crc >>> 0;
    }

    static crc32(data, offset = 0, length = null) {
        let crc = 0;
        const len = length ?? data.length - offset;
        for (let i = 0; i < len; i++) {
            crc = ESP32Parser.crc32Byte(crc, data[offset + i]);
        }
        return (~crc) >>> 0;
    }

    static crc32Header(data, offset = 0) {
        const buf = new Uint8Array(0x20 - 4);
        buf.set(data.subarray(offset, offset + 4), 0);
        buf.set(data.subarray(offset + 8, offset + 8 + 0x18), 4);
        return ESP32Parser.crc32(buf, 0, 0x1C);
    }

    // Calculate SHA256 hash using Web Crypto API
    static async calculateSHA256(data) {
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        return new Uint8Array(hashBuffer);
    }

    // Calculate SHA1 hash using Web Crypto API
    static async calculateSHA1(data) {
        const hashBuffer = await crypto.subtle.digest('SHA-1', data);
        return new Uint8Array(hashBuffer);
    }

    /* Calculate correct bootloader/image checksum */
    async calculateImageChecksum(imageOffset, imageLength = null) {
        /* Read image header to find checksum location */
        const magic = await this.view.getUint8(imageOffset);
        if (magic !== 0xE9) {
            throw new Error('Invalid image magic');
        }

        const segmentCount = await this.view.getUint8(imageOffset + 1);

        /* Parse segments and calculate checksum ONLY over segment data payloads */
        /* Headers are NOT included in checksum (but are included in SHA256) */
        let currentOffset = imageOffset + 24;
        let checksum = 0xEF;

        const MAX_CHUNK_SIZE = 1024 * 1024; // 1 MB chunks to avoid allocation failures
        const maxOffset = imageLength !== null ? imageOffset + imageLength : this.sparseImage.size;

        for (let i = 0; i < segmentCount; i++) {
            // Check if we've hit erased flash (segment header would be 0xFFFFFFFF)
            const segLoadAddr = await this.view.getUint32(currentOffset, true);
            const segLength = await this.view.getUint32(currentOffset + 4, true);

            // Detect erased/invalid flash: length 0xFFFFFFFF or unreasonably large
            if (segLength === 0xFFFFFFFF || segLength > 0x1000000) {
                throw new Error(`Segment ${i} has invalid length (0x${segLength.toString(16)}) - image may be corrupted or truncated`);
            }

            currentOffset += 8; // Skip segment header (not included in checksum)

            // Validate segment is within partition/flash bounds
            if (currentOffset + segLength > maxOffset) {
                throw new Error(`Segment ${i} extends beyond image bounds (offset: 0x${currentOffset.toString(16)}, length: ${segLength}, max: 0x${maxOffset.toString(16)})`);
            }

            // Process segment in chunks to avoid memory allocation failures
            let segmentOffset = currentOffset;
            let remaining = segLength;

            while (remaining > 0) {
                const chunkSize = Math.min(remaining, MAX_CHUNK_SIZE);
                const segmentChunk = await this.sparseImage.slice_async(segmentOffset, segmentOffset + chunkSize);

                // XOR all bytes of this chunk
                for (let j = 0; j < segmentChunk.length; j++) {
                    checksum ^= segmentChunk[j];
                }

                segmentOffset += chunkSize;
                remaining -= chunkSize;
            }

            currentOffset += segLength;
        }

        /* Pad until checksum sits at offset % 16 == 15 */
        while ((currentOffset % 16) !== 15) {
            currentOffset++;
        }

        const checksumPosition = currentOffset;

        return {
            checksum: checksum & 0xFF,
            checksumOffset: checksumPosition,
            checksumOffsetAbsolute: checksumPosition
        };
    }

    /* Calculate and fix appended SHA256 hash for an image */
    async calculateAndFixImageSHA256(imageOffset) {
        const magic = await this.view.getUint8(imageOffset);
        if (magic !== 0xE9) {
            throw new Error('Invalid image magic');
        }

        const segmentCount = await this.view.getUint8(imageOffset + 1);
        const hasHash = (await this.view.getUint8(imageOffset + 23)) === 1;

        if (!hasHash) {
            return {
                hasHash: false,
                reason: 'Image does not have appended hash'
            };
        }

        /* Parse segments to find checksum offset */
        let currentOffset = imageOffset + 24;
        for (let i = 0; i < segmentCount; i++) {
            const segLength = await this.view.getUint32(currentOffset + 4, true);
            currentOffset += 8 + segLength;
        }

        /* Pad until checksum sits at offset % 16 == 15 */
        while ((currentOffset % 16) !== 15) {
            currentOffset++;
        }

        /* Hash region is from image start to checksum offset (inclusive) */
        const hashRegionEnd = currentOffset + 1;
        const hashRegionLength = hashRegionEnd - imageOffset;

        /* Process in chunks to avoid allocation failures on large images */
        const MAX_CHUNK = 1024 * 1024; // 1 MB
        let hashRegionData;

        if (hashRegionLength <= MAX_CHUNK) {
            hashRegionData = await this.sparseImage.slice_async(imageOffset, hashRegionEnd);
        } else {
            hashRegionData = new Uint8Array(hashRegionLength);
            let offset = 0;
            let remaining = hashRegionLength;

            while (remaining > 0) {
                const chunkSize = Math.min(remaining, MAX_CHUNK);
                const chunk = await this.sparseImage.slice_async(
                    imageOffset + offset,
                    imageOffset + offset + chunkSize
                );
                hashRegionData.set(chunk, offset);
                offset += chunkSize;
                remaining -= chunkSize;
            }
        }

        /* Calculate SHA256 of the region */
        const sha256Bytes = await ESP32Parser.calculateSHA256(hashRegionData);
        const newSha256Hex = ESP32Parser.bytesToHex(sha256Bytes);

        /* SHA256 is stored 32 bytes after the checksum */
        const sha256StorageOffset = currentOffset + 1;

        /* Read the stored SHA256 to compare */
        let storedSha256Hex = '';
        if (sha256StorageOffset + 32 <= this.sparseImage.size) {
            const storedSha256Bytes = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                storedSha256Bytes[i] = await this.view.getUint8(sha256StorageOffset + i);
            }
            storedSha256Hex = ESP32Parser.bytesToHex(storedSha256Bytes);
        }

        /* Check if SHA256 needs updating */
        if (storedSha256Hex.toLowerCase() !== newSha256Hex.toLowerCase()) {
            /* Write the new SHA256 */
            const sha256BytesToWrite = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                sha256BytesToWrite[i] = sha256Bytes[i];
            }
            this.sparseImage.write(sha256StorageOffset, sha256BytesToWrite);

            return {
                hasHash: true,
                fixed: true,
                oldSHA256: storedSha256Hex,
                newSHA256: newSha256Hex,
                offset: sha256StorageOffset
            };
        } else {
            return {
                hasHash: true,
                fixed: false,
                reason: 'SHA256 already valid',
                sha256: storedSha256Hex
            };
        }
    }

    /* Fix checksums for bootloader and OTA app images */
    /* fixType: 'bootloader', 'ota', or null for both */
    /* otaOffset, otaLength: optional partition info when fixing specific OTA app */
    async fixAllChecksums(fixType = null, otaOffset = null, otaLength = null) {
        const results = {
            bootloader: null,
            otaApp: null,
            errors: []
        };

        try {
            /* Fix bootloader if requested */
            if (!fixType || fixType === 'bootloader') {
                /* Try bootloader at 0x0 */
                try {
                    const bl0 = await this.parseImage(0x0, 0x10000);
                    if (bl0 && bl0.magic === 0xE9 && !bl0.error) {
                        const checksumInfo = await this.calculateImageChecksum(0x0, 0x10000);
                        let checksumFixed = false;
                        if (checksumInfo.checksum !== bl0.checksum) {
                            const checksumByte = new Uint8Array(1);
                            checksumByte[0] = checksumInfo.checksum;
                            this.sparseImage.write(checksumInfo.checksumOffsetAbsolute, checksumByte);
                            checksumFixed = true;
                        }

                        /* Also try to fix SHA256 if present */
                        let sha256Fixed = false;
                        let sha256OldValue = null;
                        let sha256NewValue = null;
                        try {
                            const sha256Info = await this.calculateAndFixImageSHA256(0x0);
                            if (sha256Info.hasHash && sha256Info.fixed) {
                                sha256Fixed = true;
                                sha256OldValue = sha256Info.oldSHA256;
                                sha256NewValue = sha256Info.newSHA256;
                            }
                        } catch (e) {
                            /* SHA256 fix not critical */
                        }

                        if (checksumFixed || sha256Fixed) {
                            results.bootloader = {
                                offset: 0x0,
                                checksumFixed: checksumFixed,
                                oldChecksum: checksumFixed ? bl0.checksum : null,
                                newChecksum: checksumFixed ? checksumInfo.checksum : null,
                                sha256Fixed: sha256Fixed,
                                oldSHA256: sha256OldValue,
                                newSHA256: sha256NewValue,
                                fixed: true
                            };
                        } else {
                            results.bootloader = {
                                offset: 0x0,
                                checksum: bl0.checksum,
                                fixed: false,
                                reason: 'Already valid'
                            };
                        }
                    }
                } catch (e) {
                    /* No bootloader at 0x0, try 0x1000 */
                }

                if (!results.bootloader) {
                    try {
                        const bl1 = await this.parseImage(0x1000, 0x10000);
                        if (bl1 && bl1.magic === 0xE9 && !bl1.error) {
                            const checksumInfo = await this.calculateImageChecksum(0x1000, 0x10000);
                            let checksumFixed = false;
                            if (checksumInfo.checksum !== bl1.checksum) {
                                const checksumByte = new Uint8Array(1);
                                checksumByte[0] = checksumInfo.checksum;
                                this.sparseImage.write(checksumInfo.checksumOffsetAbsolute, checksumByte);
                                checksumFixed = true;
                            }

                            /* Also try to fix SHA256 if present */
                            let sha256Fixed = false;
                            let sha256OldValue = null;
                            let sha256NewValue = null;
                            try {
                                const sha256Info = await this.calculateAndFixImageSHA256(0x1000);
                                if (sha256Info.hasHash && sha256Info.fixed) {
                                    sha256Fixed = true;
                                    sha256OldValue = sha256Info.oldSHA256;
                                    sha256NewValue = sha256Info.newSHA256;
                                }
                            } catch (e) {
                                /* SHA256 fix not critical */
                            }

                            if (checksumFixed || sha256Fixed) {
                                results.bootloader = {
                                    offset: 0x1000,
                                    checksumFixed: checksumFixed,
                                    oldChecksum: checksumFixed ? bl1.checksum : null,
                                    newChecksum: checksumFixed ? checksumInfo.checksum : null,
                                    sha256Fixed: sha256Fixed,
                                    oldSHA256: sha256OldValue,
                                    newSHA256: sha256NewValue,
                                    fixed: true
                                };
                            } else {
                                results.bootloader = {
                                    offset: 0x1000,
                                    checksum: bl1.checksum,
                                    fixed: false,
                                    reason: 'Already valid'
                                };
                            }
                        }
                    } catch (e) {
                        results.errors.push('No bootloader found at 0x0 or 0x1000');
                    }
                }
            }

            /* Fix OTA app if requested */
            if (!fixType || fixType === 'ota') {
                try {
                    let otaPartition = null;

                    /* If OTA offset/length provided, use them directly */
                    if (otaOffset !== null && otaLength !== null) {
                        otaPartition = {
                            offset: otaOffset,
                            length: otaLength,
                            label: 'OTA App'
                        };
                    } else {
                        /* Try to find OTA partition from partition table */
                        const validationResult = await this.isValidImage();
                        if (validationResult.bootOtaPartitionIndex !== null && this.partitions && this.partitions.length > 0) {
                            otaPartition = this.partitions[validationResult.bootOtaPartitionIndex];
                        }
                    }

                    if (otaPartition) {
                        const otaImage = await this.parseImage(otaPartition.offset, otaPartition.length);
                        if (otaImage && otaImage.magic === 0xE9 && !otaImage.error) {
                            const checksumInfo = await this.calculateImageChecksum(otaPartition.offset, otaPartition.length);
                            let checksumFixed = false;
                            let sha256Fixed = false;
                            let oldChecksum = otaImage.checksum;
                            let newChecksum = checksumInfo.checksum;
                            let oldSHA256 = null;
                            let newSHA256 = null;

                            if (checksumInfo.checksum !== otaImage.checksum) {
                                const checksumByte = new Uint8Array(1);
                                checksumByte[0] = checksumInfo.checksum;
                                this.sparseImage.write(checksumInfo.checksumOffsetAbsolute, checksumByte);
                                checksumFixed = true;
                            }

                            /* Fix SHA256 if appended */
                            try {
                                const sha256Info = await this.calculateAndFixImageSHA256(otaPartition.offset);
                                if (sha256Info.hasHash) {
                                    if (sha256Info.fixed) {
                                        sha256Fixed = true;
                                        oldSHA256 = sha256Info.oldSHA256;
                                        newSHA256 = sha256Info.newSHA256;
                                    }
                                }
                            } catch (sha256Error) {
                                /* Non-critical: continue even if SHA256 fixing fails */
                            }

                            if (checksumFixed || sha256Fixed) {
                                results.otaApp = {
                                    partition: otaPartition.label,
                                    offset: otaPartition.offset,
                                    checksumFixed: checksumFixed,
                                    oldChecksum: oldChecksum,
                                    newChecksum: newChecksum,
                                    sha256Fixed: sha256Fixed,
                                    oldSHA256: oldSHA256,
                                    newSHA256: newSHA256,
                                    fixed: true
                                };
                            } else {
                                results.otaApp = {
                                    partition: otaPartition.label,
                                    offset: otaPartition.offset,
                                    checksum: otaImage.checksum,
                                    fixed: false,
                                    reason: 'Already valid'
                                };
                            }
                        }
                    } else if (!otaOffset && !otaLength) {
                        results.errors.push('OTA partition not found in partition table');
                    }
                } catch (e) {
                    results.errors.push('Could not fix OTA app: ' + e.message);
                }
            }
        } catch (e) {
            results.errors.push('Error during checksum fix: ' + e.message);
        }

        return results;
    }

    // Quick check if partition has valid ESP32 image magic
    async hasValidImageMagic(partition) {
        if (partition.offset >= this.sparseImage.size) {
            return false;
        }

        const magic = await this.view.getUint8(partition.offset);
        return magic === 0xE9;
    }

    // Parse partition table
    async parsePartitions(offset = 0x9000) {
        const partitions = [];
        let currentOffset = offset;
        let num = 0;

        this.partitionTableOffset = offset;

        while (currentOffset + 32 <= this.sparseImage.size) {
            const magic = await this.view.getUint16(currentOffset, true);

            if (magic !== 0x50AA) {
                break;
            }

            const partition = {
                num: num,
                magic: magic,
                type: await this.view.getUint8(currentOffset + 2),
                subType: await this.view.getUint8(currentOffset + 3),
                offset: await this.view.getUint32(currentOffset + 4, true),
                length: await this.view.getUint32(currentOffset + 8, true),
                label: await this.readString(currentOffset + 12, 16),
                reserved: await this.view.getUint32(currentOffset + 28, true)
            };

            partition.typeName = this.getPartitionTypeName(partition.type, partition.subType);
            partitions.push(partition);

            currentOffset += 32;
            num++;
        }

        this.partitions = partitions;
        return partitions;
    }

    // Compute SHA-1 of a partition
    async computePartitionSHA1(partition) {
        const start = partition.offset;
        const end = Math.min(this.sparseImage.size, partition.offset + partition.length);
        if (start >= this.sparseImage.size || start >= end) {
            return null;
        }
        const view = await this.sparseImage.subarray_async(start, end);
        const hash = await ESP32Parser.calculateSHA1(view);
        return ESP32Parser.bytesToHex(hash);
    }

    // Detect partition table offset: start after bootloader end, skip 0xFF, pick next data at 4K boundary
    // Try to parse partition entries to validate, continue seeking until 0x00100000 if valid table found
    async detectPartitionTableOffset(bootImage) {
        const sector = 0x1000;
        const start = bootImage?.endOffset ?? 0;
        const searchLimit = Math.min(0x00010000, this.sparseImage.size);
        const len = this.sparseImage.size;
        let ptr = start;
        let bestCandidate = null;
        let bestPartitionCount = 0;

        //this.logDebug(`Detecting partition table offset starting from 0x${start.toString(16)}`);
        //this.logDebug(`Buffer length: 0x${len.toString(16)}, search limit: 0x${searchLimit.toString(16)}`);

        while (!bestCandidate && ptr < searchLimit) {
            // Skip 0xFF bytes and check for 4K boundary alignment
            if ((await this.view.getUint8(ptr)) !== 0xFF && (ptr % sector === 0)) {
                // Try to parse partition entries at this offset
                const validCount = await this.validatePartitionTable(ptr);

                if (validCount > 0) {
                    //this.logDebug(`Found valid partition table at 0x${ptr.toString(16)} with ${validCount} entries`);

                    // Keep track of best candidate (most partitions)
                    if (validCount > bestPartitionCount) {
                        bestCandidate = ptr;
                        bestPartitionCount = validCount;
                    }
                }
            }
            ptr++;
        }

        if (bestCandidate !== null) {
            this.partitionTableOffset = bestCandidate;
            //this.logDebug(`Selected partition table offset at 0x${bestCandidate.toString(16)} with ${bestPartitionCount} entries`);
            return bestCandidate;
        }

        //this.logDebug(`No partition table detected`);
        return null;
    }

    // Validate partition table at given offset by trying to parse entries
    async validatePartitionTable(offset) {
        let validCount = 0;
        let currentOffset = offset;
        const maxPartitions = 32; // Reasonable limit

        for (let i = 0; i < maxPartitions; i++) {
            if (currentOffset + 32 > this.sparseImage.size) {
                break;
            }

            const magic = await this.view.getUint16(currentOffset, true);

            // End of partition table
            if (magic !== 0x50AA) {
                break;
            }

            const type = await this.view.getUint8(currentOffset + 2);
            const subType = await this.view.getUint8(currentOffset + 3);
            const partOffset = await this.view.getUint32(currentOffset + 4, true);
            const partLength = await this.view.getUint32(currentOffset + 8, true);

            // Validate partition entry sanity
            // Type should be 0 (APP) or 1 (DATA) typically
            if (type > 0xFE) {
                break; // Invalid type
            }

            // Offset should be reasonable (within flash)
            if (partOffset > 0x10000000) {
                break; // Offset too large
            }

            // Length should be non-zero and reasonable
            if (partLength === 0 || partLength > 0x10000000) {
                break;
            }

            // Read label and check for valid characters
            let validLabel = true;
            for (let j = 0; j < 16; j++) {
                const labelByte = await this.view.getUint8(currentOffset + 12 + j);
                if (labelByte === 0) {
                    break; // Null terminator is fine
                }
                // Check if character is printable ASCII or high bit set
                if (labelByte < 0x20 || (labelByte > 0x7E && labelByte < 0x80)) {
                    validLabel = false;
                    break;
                }
            }

            if (!validLabel) {
                break;
            }

            validCount++;
            currentOffset += 32;
        }

        return validCount;
    }

    getPartitionTypeName(type, subType) {
        const types = {
            0: 'APP',
            1: 'DATA'
        };

        const appSubTypes = {
            0x00: 'factory',
            0x10: 'ota_0',
            0x11: 'ota_1',
            0x12: 'ota_2',
            0x13: 'ota_3',
            0x14: 'ota_4',
            0x15: 'ota_5',
            0x16: 'ota_6',
            0x17: 'ota_7',
            0x20: 'test'
        };

        const dataSubTypes = {
            0x00: 'ota',
            0x01: 'phy',
            0x02: 'nvs',
            0x03: 'coredump',
            0x04: 'nvs_keys',
            0x05: 'efuse',
            0x80: 'esphttpd',
            0x81: 'fat',
            0x82: 'spiffs'
        };

        let typeName = types[type] || 'UNKNOWN';
        let subTypeName = '';

        if (type === 0) {
            subTypeName = appSubTypes[subType] || `unknown_${subType.toString(16)}`;
        } else if (type === 1) {
            subTypeName = dataSubTypes[subType] || `unknown_${subType.toString(16)}`;
        }

        return `${typeName} (${subTypeName})`;
    }

    async readString(offset, maxLength) {
        let result = '';
        for (let i = 0; i < maxLength; i++) {
            const byte = await this.view.getUint8(offset + i);
            if (byte === 0) break;
            // Only include printable ASCII characters (32-126)
            if (byte >= 32 && byte <= 126) {
                result += String.fromCharCode(byte);
            } else if (byte !== 0) {
                // Non-printable character found - might be corrupt data
                return result; // Return what we have so far
            }
        }
        return result;
    }

    // NVS helpers are now encapsulated in NVSParser

    // Get chip name from chip ID
    getChipName(chipId) {
        const chipNames = {
            0x0000: 'ESP32',
            0x0002: 'ESP32-S2',
            0x0005: 'ESP32-C3',
            0x0009: 'ESP32-S3',
            0x000C: 'ESP32-C2',
            0x000D: 'ESP32-C6',
            0x0010: 'ESP32-H2',
            0x0012: 'ESP32-P4',
            0x0017: 'ESP32-C5',
            0x0014: 'ESP32-C61',
            0x0019: 'ESP32-H21',
            0x001C: 'ESP32-H4',
            0x0020: 'ESP32-S31',
            0xFFFF: 'Invalid'
        };
        return chipNames[chipId] || `Unknown (0x${chipId.toString(16).toUpperCase().padStart(4, '0')})`;
    }

    // Get SPI flash mode name
    getSpiModeName(mode) {
        const modes = {
            0: 'QIO',
            1: 'QOUT',
            2: 'DIO',
            3: 'DOUT'
        };
        return modes[mode] || `Unknown (${mode})`;
    }

    // Get SPI flash speed
    getSpiSpeedName(speed) {
        const speeds = {
            0: '40MHz',
            1: '26MHz',
            2: '20MHz',
            0xF: '80MHz'
        };
        return speeds[speed] || `${speed}`;
    }

    // Get SPI flash size
    getSpiSizeName(size) {
        const sizes = {
            0: '1MB',
            1: '2MB',
            2: '4MB',
            3: '8MB',
            4: '16MB',
            5: '32MB',
            6: '64MB',
            7: '128MB'
        };
        return sizes[size] || `Unknown (${size})`;
    }

    // Parse firmware image
    async parseImage(offset, length) {
        if (offset + 24 > this.sparseImage.size) {
            return { error: 'Offset out of bounds' };
        }

        const magic = await this.view.getUint8(offset);
        if (magic !== 0xE9) {
            return { error: 'Invalid magic number', magic: magic };
        }

        const segmentCount = await this.view.getUint8(offset + 1);
        const spiMode = await this.view.getUint8(offset + 2);
        const flashInfoByte = await this.view.getUint8(offset + 3);
        const spiSpeed = flashInfoByte & 0x0F;  // Lower 4 bits
        const spiSize = (flashInfoByte >> 4) & 0x0F;  // Upper 4 bits
        const entryAddr = await this.view.getUint32(offset + 4, true);

        // Extended header (24 bytes total)
        const wpPin = await this.view.getUint8(offset + 8);
        const spiPinDrv = [
            await this.view.getUint8(offset + 9),
            await this.view.getUint8(offset + 10),
            await this.view.getUint8(offset + 11)
        ];
        const chipId = await this.view.getUint16(offset + 12, true);
        const minChipRev = await this.view.getUint8(offset + 14);
        const minChipRevFull = await this.view.getUint16(offset + 15, true);
        const maxChipRevFull = await this.view.getUint16(offset + 17, true);
        const reserved = [
            await this.view.getUint8(offset + 19),
            await this.view.getUint8(offset + 20),
            await this.view.getUint8(offset + 21),
            await this.view.getUint8(offset + 22)
        ];
        const hashAppended = await this.view.getUint8(offset + 23);

        const image = {
            offset: offset,
            magic: magic,
            segmentCount: segmentCount,
            spiMode: spiMode,
            spiModeName: this.getSpiModeName(spiMode),
            spiSpeed: spiSpeed,
            spiSpeedName: this.getSpiSpeedName(spiSpeed),
            spiSize: spiSize,
            spiSizeName: this.getSpiSizeName(spiSize),
            entryAddr: entryAddr,
            wpPin: wpPin,
            wpPinDisabled: wpPin === 0xEE,
            spiPinDrv: spiPinDrv,
            chipId: chipId,
            chipName: this.getChipName(chipId),
            minChipRev: minChipRev,
            minChipRevFull: minChipRevFull,
            minChipRevMajor: Math.floor(minChipRevFull / 100),
            minChipRevMinor: minChipRevFull % 100,
            maxChipRevFull: maxChipRevFull,
            maxChipRevMajor: Math.floor(maxChipRevFull / 100),
            maxChipRevMinor: maxChipRevFull % 100,
            reserved: reserved,
            hashAppended: hashAppended,
            hasHash: hashAppended === 1,
            segmentList: []
        };

        let currentOffset = offset + 24;

        // Parse segments
        for (let i = 0; i < segmentCount; i++) {
            if (currentOffset + 8 > this.sparseImage.size) break;

            const loadAddress = await this.view.getUint32(currentOffset, true);
            const segLength = await this.view.getUint32(currentOffset + 4, true);

            // Detect erased/invalid flash: length 0xFFFFFFFF or unreasonably large
            if (segLength === 0xFFFFFFFF || segLength > 0x1000000) {
                image.error = `Segment ${i} has invalid length (0x${segLength.toString(16)})`;
                break;
            }

            // Check if segment extends beyond partition bounds
            const maxOffset = length !== null ? offset + length : this.sparseImage.size;
            if (currentOffset + 8 + segLength > maxOffset) {
                // Add the faulty segment to show where parsing failed
                image.segmentList.push({
                    loadAddress: loadAddress,
                    length: segLength,
                    offset: currentOffset + 8,
                    truncated: true,
                    error: 'Extends beyond image bounds'
                });
                image.error = `Segment ${i} extends beyond image bounds (offset: 0x${(currentOffset + 8).toString(16)}, length: ${segLength}, max: 0x${maxOffset.toString(16)})`;
                break;
            }

            image.segmentList.push({
                loadAddress: loadAddress,
                length: segLength,
                offset: currentOffset + 8
            });

            currentOffset += 8 + segLength;
        }

        // Pad until checksum sits at offset % 16 == 15 (esptool layout)
        while ((currentOffset % 16) !== 15) {
            currentOffset++;
        }

        const checksumOffset = currentOffset;
        if (currentOffset < this.sparseImage.size) {
            image.checksum = await this.view.getUint8(currentOffset);
            currentOffset++;

            // Always record hash region (header through checksum) for debugging/calculation
            image.sha256DataStart = offset;
            image.sha256DataEnd = checksumOffset + 1;

            if (image.hasHash && currentOffset + 32 <= this.sparseImage.size) {
                const hash = new Uint8Array(32);
                for (let i = 0; i < 32; i++) {
                    hash[i] = await this.view.getUint8(currentOffset + i);
                }
                image.sha256 = ESP32Parser.bytesToHex(hash);
                image.sha256Offset = currentOffset;
                currentOffset += 32;
            }
        }

        image.endOffset = currentOffset;

        // Try to find and parse app description
        image.appDesc = await this.parseAppDescription(image);

        return image;
    }

    // Parse application description (esp_app_desc_t)
    async parseAppDescription(image) {
        const ESP_APP_DESC_MAGIC_WORD = 0xABCD5432;

        if (image.segmentList.length === 0) {
            console.warn(`AppDesc: no segments present for image at 0x${(image.offset ?? 0).toString(16)}`);
            return null;
        }

        const parseAt = async (offset) => {
            const appDesc = {
                found: true,
                offset: offset,
                magicWord: ESP_APP_DESC_MAGIC_WORD,
                secureVersion: await this.view.getUint32(offset + 4, true),
                version: (await this.readString(offset + 16, 32)).trim(),
                projectName: (await this.readString(offset + 48, 32)).trim(),
                time: (await this.readString(offset + 80, 16)).trim(),
                date: (await this.readString(offset + 96, 16)).trim(),
                idfVer: (await this.readString(offset + 112, 32)).trim(),
                appElfSha256: null
            };

            if (offset + 144 + 32 <= this.sparseImage.size) {
                const sha256 = new Uint8Array(32);
                for (let i = 0; i < 32; i++) {
                    sha256[i] = await this.view.getUint8(offset + 144 + i);
                }
                appDesc.appElfSha256 = ESP32Parser.bytesToHex(sha256);
            }

            return appDesc;
        };

        /* Fixed offset: header (24) + first segment header (8) */
        const descOffset = (image.offset ?? 0) + 24 + 8;
        if (descOffset + 256 > this.sparseImage.size || descOffset < 0) {
            // Out of bounds - silently return null
            return null;
        }

        const magic = await this.view.getUint32(descOffset, true);
        if (magic !== ESP_APP_DESC_MAGIC_WORD) {
            // No app descriptor found - this is normal for bootloaders, erased partitions, etc.
            return null;
        }

        try {
            return await parseAt(descOffset);
        } catch (error) {
            console.warn('Error parsing app description at fixed offset:', error);
            return null;
        }
    }

    // Validate image SHA256 hash
    async validateImageSHA256(image) {
        if (image.sha256 === undefined || image.sha256 === null ||
            image.sha256DataStart === undefined || image.sha256DataEnd === undefined) {
            return { valid: false, reason: 'No hash data available' };
        }

        try {
            //this.logDebug(`Image SHA256 region: start=0x${image.sha256DataStart.toString(16)}, end=0x${image.sha256DataEnd.toString(16)}, length=${image.sha256DataEnd - image.sha256DataStart}`);
            const dataToHash = await this.sparseImage.slice_async(image.sha256DataStart, image.sha256DataEnd);
            const calculatedHash = await ESP32Parser.calculateSHA256(dataToHash);
            const calculatedHashHex = ESP32Parser.bytesToHex(calculatedHash);

            const valid = calculatedHashHex === image.sha256;

            return {
                valid: valid,
                calculated: calculatedHashHex,
                expected: image.sha256,
                reason: valid ? 'Hash matches' : 'Hash mismatch'
            };
        } catch (error) {
            return { valid: false, reason: 'Error calculating hash: ' + error.message };
        }
    }

    /**
     * Parse FAT partition
     */
    async parseFATFilesystem(partition) {
        if (!this.sparseImage) {
            throw new Error('ESP32Parser has no SparseImage');
        }
        const parser = new FATParser(this.sparseImage, partition.offset, partition.length);
        parser.logMessage = this.logMessage.bind(this);
        parser.logDebug = this.logDebug.bind(this);
        parser.logError = this.logError.bind(this);
        await parser.initialize();
        return parser;
    }

    /**
     * Parse SPIFFS partition
     */
    async parseSPIFFS(partition) {
        if (!this.sparseImage) {
            throw new Error('ESP32Parser has no SparseImage');
        }
        const parser = new SpiffsParser(this.sparseImage, partition.offset, partition.length);
        parser.logMessage = this.logMessage.bind(this);
        parser.logDebug = this.logDebug.bind(this);
        parser.logError = this.logError.bind(this);
        await parser.initialize();
        return parser;
    }

    // Parse NVS (Non-Volatile Storage)  returns NVSParser instance
    async parseNVS(partition) {
        if (!this.sparseImage) {
            throw new Error('ESP32Parser has no SparseImage');
        }
        const parser = new NVSParser(this.sparseImage, partition.offset, partition.length);
        parser.logMessage = this.logMessage.bind(this);
        parser.logDebug = this.logDebug.bind(this);
        parser.logError = this.logError.bind(this);
        await parser.initialize();
        return parser;
    }

    // Parse OTA data partition  delegated to OTADataParser class
    async parseOTAData(partition) {
        if (!this.sparseImage) {
            throw new Error('ESP32Parser has no SparseImage');
        }
        const parser = new OTADataParser(this.sparseImage, partition.offset, partition.length);
        parser.logMessage = this.logMessage.bind(this);
        parser.logDebug = this.logDebug.bind(this);
        parser.logError = this.logError.bind(this);
        await parser.initialize();
        return parser;
    }

    // Get partition by label
    getPartition(label) {
        return this.partitions.find(p => p.label === label);
    }

    // Export methods
    async exportPartitionData(partition) {
        const data = await this.buffer.slice_async(partition.offset, partition.offset + partition.length);
        return new Blob([data], { type: 'application/octet-stream' });
    }

    /**
     * High-level validation pipeline for an ESP32 image.
     * - Detect bootloader at 0x0 or 0x1000
     * - Find and parse partition table
     * - Parse OTA data; if valid, resolve boot OTA partition
     * - Validate referenced boot OTA partition image
     * - Parse NVS partition if present and valid
     * Returns a summary structure.
     */
    async isValidImage() {
        const result = {
            success: false,
            allValid: false,
            bootloader: false,
            bootloaderOffset: null,
            otadata: false,
            bootPartition: null,
            bootPartitionValid: false
        };

        /* Step 1: detect bootloader at 0x0, then fallback to 0x1000 */
        let bootloaderImage = null;
        try {
            bootloaderImage = await this.parseImage(0x0000, 0x10000);
            if (bootloaderImage && bootloaderImage.magic === 0xE9 && !bootloaderImage.error) {
                result.bootloader = true;
                result.bootloaderOffset = 0x0000;
            } else {
                bootloaderImage = await this.parseImage(0x1000, 0x10000);
                if (bootloaderImage && bootloaderImage.magic === 0xE9 && !bootloaderImage.error) {
                    result.bootloader = true;
                    result.bootloaderOffset = 0x1000;
                }
            }
        } catch (e) {
            /* Leave result.bootloader false */
        }

        /* Step 2: detect and parse partition table (reference viewer logic) */
        let ptOffset = null;
        try {
            ptOffset = await this.detectPartitionTableOffset(bootloaderImage);
            if (ptOffset !== null) {
                await this.parsePartitions(ptOffset);
            } else {
                this.partitions = [];
            }
        } catch (e) {
            /* keep partitions empty on error */
            this.partitions = this.partitions || [];
        }

        /* Step 3: parse OTA data and resolve boot partition if checksums valid */
        let bootOtaSubType = null;
        let activeOtaSeq = null;
        let allOtaCrcsValid = false;
        const otaDataPart = this.partitions.find(p => p.type === 1 && p.subType === 0x00);
        if (otaDataPart) {
            try {
                const otaInfo = (await this.parseOTAData(otaDataPart)).otaInfo;
                if (otaInfo && Array.isArray(otaInfo.entries) && otaInfo.entries.length === 2) {
                    /* Consider otadata valid if both CRCs are valid OR at least one valid entry exists */
                    const crcAll = otaInfo.entries.every(e => e.crcValid);
                    const anyValid = otaInfo.entries.some(e => e.isValid);
                    allOtaCrcsValid = crcAll;
                    result.otadata = anyValid;

                    if (anyValid) {
                        const activeIdx = otaInfo.activeEntry;
                        if (activeIdx !== null && otaInfo.entries[activeIdx]) {
                            activeOtaSeq = otaInfo.entries[activeIdx].sequence >>> 0;
                            /* Count APP OTA partitions */
                            const otaApps = this.partitions.filter(p => p.type === 0 && p.subType >= 0x10 && p.subType <= 0x1F);
                            const otaCount = otaApps.length;
                            if (otaCount > 0) {
                                const slot = ((activeOtaSeq - 1) % otaCount) >>> 0;
                                bootOtaSubType = 0x10 + slot;
                                result.bootPartition = `ota_${slot}`;
                            }
                        }
                    }
                }
            } catch (e) {
                /* otadata parse failed */
            }
        }

        /* Step 4: validate the referenced boot OTA partition image */
        if (bootOtaSubType !== null) {
            const bootPart = this.partitions.find(p => p.type === 0 && p.subType === bootOtaSubType);
            if (bootPart) {
                try {
                    const hasMagic = await this.hasValidImageMagic(bootPart);
                    if (hasMagic) {
                        /* Parse image and validate appended SHA256 when present */
                        const img = await this.parseImage(bootPart.offset, bootPart.length);
                        if (img && img.hasHash) {
                            const shaRes = await this.validateImageSHA256(img);
                            result.bootPartitionValid = !!(shaRes && shaRes.valid);
                        } else {
                            /* No appended hash; treat valid magic as acceptable */
                            result.bootPartitionValid = true;
                        }

                        /* Extract app description if available */
                        if (img && img.appDesc && img.appDesc.found) {
                            result.appProjectName = img.appDesc.projectName || null;
                            result.appVersion = img.appDesc.version || null;
                        }
                    }
                } catch (e) {
                    /* Leave bootPartitionValid as false on failure */
                }
            }
        }

        /* Step 5: parse NVS if present (validity requires actual valid entries) */
        const nvsPart = this.partitions.find(p => p.type === 1 && p.subType === 0x02);
        let nvsValid = false;
        if (nvsPart) {
            try {
                const pages = await this.parseNVS(nvsPart);
                if (Array.isArray(pages) && pages.length > 0) {
                    /* Count valid items (not just pages) */
                    let itemCount = 0;
                    for (const page of pages) {
                        if (page.items && Array.isArray(page.items)) {
                            itemCount += page.items.length;
                        }
                    }
                    nvsValid = itemCount > 0;
                }
            } catch (e) {
                nvsValid = false;
            }
        }

        /* Step 6: aggregate success */
        const partitionsFound = Array.isArray(this.partitions) && this.partitions.length > 0;
        result.success = !!(result.bootloader && partitionsFound);

        /* All valid if: bootloader parsed, partition table found, otadata OK with all CRCs valid, and boot partition valid */
        result.allValid = !!(result.bootloader && partitionsFound && result.otadata && allOtaCrcsValid && result.bootPartitionValid);

        /* Attach optional details for callers that need them */
        result.partitionTableOffset = ptOffset ?? null;
        result.nvs = nvsValid;

        return result;
    }
}

// Export for use in HTML
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ESP32Parser;
    module.exports.SparseImage = SparseImage;
}

    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            color: #d4d4d4;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1f35 0%, #1c1424 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #2a2a2a;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            padding: 30px;
        }

        h1 {
            color: #e0e0e0;
            margin-bottom: 10px;
            font-size: 2em;
            background: linear-gradient(135deg, #7a8bdc 0%, #9a7bcd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #999;
            margin-bottom: 20px;
            font-size: 0.95em;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            color: #a0a0a0;
            font-weight: 600;
            font-size: 0.9em;
        }

        input[type="text"],
        input[type="number"],
        input[type="datetime-local"],
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #404040;
            border-radius: 5px;
            font-size: 0.9em;
            background: #333333;
            color: #d4d4d4;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="datetime-local"]:focus,
        select:focus {
            outline: none;
            border-color: #5a6bb8;
            box-shadow: 0 0 0 2px rgba(90, 107, 184, 0.2);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #5a6bb8 0%, #6a5294 100%);
            color: #e8e8e8;
            border: none;
            padding: 11px 20px;
            border-radius: 5px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 8px;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(90, 107, 184, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #404040 !important;
            color: #a0a0a0 !important;
        }

        .btn-secondary:hover {
            background: #4a4a4a !important;
            box-shadow: 0 5px 15px rgba(74, 74, 74, 0.3) !important;
        }

        .output-section {
            display: none;
        }

        .output-section.visible {
            display: block;
            margin-top: 20px;
        }

        .step-card {
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            background: #2a2a2a;
        }

        .step-card h2 {
            color: #7a8bdc;
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .step-card.step-complete {
            border-color: #2ca24c;
            background: #283a2a;
            box-shadow: 0 0 0 2px rgba(44, 162, 76, 0.12);
        }

        .step-card.step-disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .step-locked-message {
            display: none;
            margin-top: 6px;
            color: #777;
            font-size: 0.85em;
        }

        .step-card.step-disabled .step-locked-message {
            display: block;
        }

        .output-box {
            background: #333333;
            border: 1px solid #404040;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }

        .output-box h3 {
            color: #7a8bdc;
            margin-bottom: 12px;
            font-size: 1em;
        }

        .collapsible-header {
            color: #a0a0a0;
            margin-bottom: 0;
            font-size: 0.95em;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            font-weight: 600;
        }

        .collapsible-header:hover {
            color: #7a8bdc;
        }

        .collapsible-content {
            margin-top: 12px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.collapsed {
            display: none;
        }

        .cert-display {
            background: #1e1e1e;
            color: #7a8bdc;
            padding: 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 250px;
            overflow-y: auto;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 140px 1fr;
            gap: 8px;
            font-size: 0.9em;
        }

        .info-label {
            font-weight: 600;
            color: #7a8bdc;
        }

        .info-value {
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }

        .status {
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
            font-size: 0.95em;
        }

        .status.visible {
            display: block;
        }

        .status.success {
            background: #2d5a3d;
            color: #6ec589;
            border: 1px solid #3d6a4d;
        }

        .status.error {
            background: #5a3d3d;
            color: #ff6b6b;
            border: 1px solid #6a4d4d;
        }

        .status.loading {
            background: #3d4d5a;
            color: #6ba3d4;
            border: 1px solid #4d5d6a;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status.info {
            background: #3d4d5a;
            color: #6ba3d4;
            border: 1px solid #4d5d6a;
        }

        .status.loading::before {
            content: '';
            font-size: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            flex-shrink: 0;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .drop-zone {
            border: 3px dashed #5a6bb8;
            border-radius: 8px;
            padding: 30px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #333333;
            margin: 15px 0;
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            background: #3a3f5a;
            border-color: #7a8bdc;
        }

        .drop-zone.success {
            background: #2d3a3a;
            border-color: #2ca24c;
            box-shadow: 0 0 0 2px rgba(44, 162, 76, 0.15);
        }

        .drop-zone-text {
            color: #7a8bdc;
            font-size: 1em;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .drop-zone-hint {
            color: #777;
            font-size: 0.85em;
        }

        .drop-zone-details {
            margin-top: 10px;
            font-size: 0.85em;
            color: #6ec589;
            line-height: 1.3;
            text-align: left;
        }

        .drop-zone-title {
            font-weight: 700;
            margin-bottom: 3px;
        }

        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #404040;
        }

        .tab-btn {
            padding: 12px 20px;
            background: none;
            border: none;
            color: #777;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab-btn:hover {
            color: #7a8bdc;
        }

        .tab-btn.active {
            color: #7a8bdc;
            border-bottom-color: #7a8bdc;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 20px;
            }

            .info-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.5em;
            }
        }
    </style>
    <!-- Built: 2026-01-03T18:11:12.503Z -->
</head>

<body>
    <div class="container">
        <h1> CA Certificate Generator & Decoder</h1>
        <p class="subtitle">Generate or decode X.509 certificates using node-forge</p>

        <div id="status" class="status"></div>

        <!-- Tab buttons -->
        <div class="tab-buttons">
            <button class="tab-btn active" onclick="switchTab('generate')">Generate Certificate</button>
            <button class="tab-btn" onclick="switchTab('decode')">Decode Certificate</button>
        </div>

        <!-- Generate Tab -->
        <div id="generateTab" class="tab-content active">
            <div class="step-card" id="caStepCard">
                <h2>Step 1: Prepare CA</h2>
                <p class="subtitle" style="margin-bottom: 15px;">Generate a new CA or import an existing CA certificate
                    and private key.</p>

                <div style="margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <button type="button" class="btn btn-secondary" id="btnShowImportCA"
                        onclick="showCAMode('import')">Import CA Cert/Key</button>
                    <button type="button" class="btn" id="btnShowGenerateCA" onclick="showCAMode('generate')">Generate
                        CA Certificate</button>
                </div>

                <div id="caGenerateMode">
                    <div class="form-row">
                        <div class="form-group" style="display: none;">
                            <label for="fileName">CA Certificate File Name</label>
                            <input type="text" id="fileName" value="CA.DER">
                        </div>
                        <div class="form-group" style="display: none;">
                            <label for="serialNumber">CA Serial Number (hex)</label>
                            <input type="text" id="serialNumber" value="" placeholder="Leave blank for auto-generated">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="commonName">CA Common Name (CN) *</label>
                            <input type="text" id="commonName" value="TeddyCloud" required>
                        </div>
                        <div class="form-group">
                            <label for="organization">CA Organization (O)</label>
                            <input type="text" id="organization" value="N/A">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="country">Country (C)</label>
                            <input type="text" id="country" value="DE" maxlength="2" placeholder="2-letter code">
                        </div>
                        <div class="form-group">
                            <label for="state">State/Province (ST)</label>
                            <input type="text" id="state" value="">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="locality">Locality/City (L)</label>
                            <input type="text" id="locality" value="">
                        </div>
                        <div class="form-group">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group" style="display: none;">
                            <label for="validFrom">Valid From</label>
                            <input type="datetime-local" id="validFrom" value="2026-01-01T00:00">
                        </div>
                        <div class="form-group" style="display: none;">
                            <label for="validUntil">Valid Until</label>
                            <input type="datetime-local" id="validUntil" value="2040-01-01T01:00">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="keySize">Key Size (bits)</label>
                            <select id="keySize">
                                <option value="2048">2048 (Required)</option>
                                <option value="3072">3072</option>
                                <option value="4096" selected>4096</option>
                            </select>
                        </div>
                        <div class="form-group" style="display: none;">
                            <label for="signatureAlgorithm">Signature Algorithm</label>
                            <select id="signatureAlgorithm">
                                <option value="sha256" selected>SHA-256 with RSA</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row" style="display: none;">
                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 10px;">
                                <input type="checkbox" id="isCA" checked>
                                <span>Is CA</span>
                            </label>
                        </div>
                        <div class="form-group"></div>
                    </div>

                    <div style="margin-top: 20px;">
                        <button type="button" class="btn" id="btnGenerateCA">Generate CA Certificate</button>
                    </div>
                </div>

                <div id="caImportMode" style="display: none;">
                    <div class="form-row">
                        <div class="form-group">
                            <div class="drop-zone" id="caCertDropZone">
                                <div class="drop-zone-text"> Drop CA certificate</div>
                                <div class="drop-zone-hint">CA.DER or CA.PEM</div>
                                <div class="drop-zone-details" id="caCertDropDetails"></div>
                                <input type="file" id="caCertInput" accept=".der,.crt,.pem,.cer" style="display: none;">
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="drop-zone" id="caKeyDropZone">
                                <div class="drop-zone-text"> Drop CA private key</div>
                                <div class="drop-zone-hint">CA-KEY.DER or CA-KEY.PEM</div>
                                <div class="drop-zone-details" id="caKeyDropDetails"></div>
                                <input type="file" id="caKeyInput" accept=".der,.pem" style="display: none;">
                            </div>
                        </div>
                    </div>
                </div>

                <div id="caOutputSection" class="output-section">
                    <div class="output-box">
                        <h3 class="collapsible-header" onclick="toggleCollapse('caCertInfo')">
                            <span id="caCertInfoToggle"></span> CA Certificate Information
                        </h3>
                        <div id="caCertInfo" class="info-grid collapsible-content collapsed"></div>
                    </div>

                    <div style="margin-top: 10px; display: none; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" id="downloadCaDerBtn" onclick="downloadGeneratedDer()"
                            style="display: none;">
                            Download DER (CA.DER)
                        </button>
                        <button class="btn btn-secondary" id="downloadCaKeyBtn" onclick="downloadPrivateKeyPem()"
                            style="display: none;">
                            Download Private Key (PRIVATE.KEY)
                        </button>
                    </div>
                </div>

                <div id="caStatus" class="status" style="margin-top: 10px;"></div>
            </div>

            <div class="step-card" id="clientStepCard">
                <h2>Step 2: Generate Client Certificate</h2>
                <div class="step-locked-message" id="clientStepLockedMessage">Requires a loaded CA certificate and
                    private key.</div>
                <p class="subtitle" style="margin-bottom: 15px;">Uses the CA from Step 1 to sign the client certificate.
                </p>
                <div class="form-row">
                    <div class="form-group" style="display: none;">
                        <label for="clientFileName">Client File Name</label>
                        <input type="text" id="clientFileName" value="CLIENT.DER">
                    </div>
                    <div class="form-group" style="display: none;">
                        <label for="clientSerial">Client Serial (hex)</label>
                        <input type="text" id="clientSerial" placeholder="Leave blank for auto-generated">
                    </div>
                    <div class="form-group" style="align-self: end;">
                        <button type="button" class="btn" id="btnFetchMac">Fetch MAC from ESP32</button>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="clientCN">Client Common Name (CN) *</label>
                        <input type="text" id="clientCN" value="TeddyClient" required>
                    </div>
                    <div class="form-group">
                        <label for="clientO">Client Organization (O)</label>
                        <input type="text" id="clientO" value="N/A">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="clientC">Country (C)</label>
                        <input type="text" id="clientC" value="DE" maxlength="2" placeholder="2-letter code">
                    </div>
                    <div class="form-group">
                        <label for="clientST">State/Province (ST)</label>
                        <input type="text" id="clientST" value="">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="clientL">Locality/City (L)</label>
                        <input type="text" id="clientL" value="">
                    </div>
                    <div class="form-group" style="display: none;">
                        <label for="clientValidFrom">Valid From</label>
                        <input type="datetime-local" id="clientValidFrom" value="2026-01-01T00:00">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group" style="display: none;">
                        <label for="clientValidUntil">Valid Until</label>
                        <input type="datetime-local" id="clientValidUntil" value="2031-01-01T00:00">
                    </div>
                    <div class="form-group">
                        <label for="clientKeySize">Key Size (bits)</label>
                        <select id="clientKeySize">
                            <option value="2048" selected>2048 (Required)</option>
                            <option value="3072">3072</option>
                            <option value="4096">4096</option>
                        </select>
                    </div>
                </div>

                <div id="clientOutputSection" class="output-section">
                    <div class="output-box">
                        <h3 class="collapsible-header" onclick="toggleCollapse('clientCertInfo')">
                            <span id="clientCertInfoToggle"></span> Client Certificate Information
                        </h3>
                        <div id="clientCertInfo" class="info-grid collapsible-content collapsed"></div>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <button type="button" class="btn" id="btnGenerateClient">Generate Client Certificate</button>
                </div>
                <div id="clientStatus" class="status" style="margin-top: 10px;"></div>
            </div>

            <div class="step-card" id="downloadStepCard">
                <h2>Step 3: Download Client Artifacts</h2>
                <div class="step-locked-message" id="downloadStepLockedMessage">Generate a client certificate first.
                </div>
                <p class="subtitle" style="margin-bottom: 10px;">Download the generated client certificate and private
                    key.</p>
                <div id="downloadStatus" class="status" style="margin-top: 10px;"></div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">

                    <div style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn" id="btnFlashToESP32" onclick="flashCertsToESP32()" style="display: none;">
                            Flash to ESP32</button>
                        <button class="btn btn-secondary" id="btnDownloadCaDer" onclick="downloadCaDer()"
                            style="display: none;">Download CA.DER</button>
                        <button class="btn btn-secondary" id="btnDownloadClientDer" onclick="downloadClientDer()"
                            style="display: none;">Download CLIENT.DER</button>
                        <button class="btn btn-secondary" id="btnDownloadClientKeyDer" onclick="downloadClientKeyDer()"
                            style="display: none;">Download PRIVATE.DER</button>
                    </div>

                </div>
            </div>
        </div>

        <!-- Decode Tab -->
        <div id="decodeTab" class="tab-content">
            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-text"> Drop certificate file here</div>
                <div class="drop-zone-hint">Supports .DER, .CRT, .PEM, and .CER files</div>
                <input type="file" id="fileInput" accept=".der,.crt,.pem,.cer" style="display: none;">
            </div>
            <div style="text-align: center; margin-top: 10px;">
                <button class="btn btn-secondary" onclick="document.getElementById('fileInput').click()">Or click to
                    select
                    file</button>
            </div>

            <div id="outputSection" class="output-section">
                <div class="output-box">
                    <h3 class="collapsible-header" onclick="toggleCollapse('certInfo')">
                        <span id="certInfoToggle"></span> Certificate Information
                    </h3>
                    <div id="certInfo" class="info-grid collapsible-content collapsed"></div>
                </div>

                <div style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn btn-secondary" id="downloadDerBtn" onclick="downloadGeneratedDer()"
                        style="display: none;">
                        Download DER (CA.DER)
                    </button>
                    <button class="btn btn-secondary" id="downloadKeyBtn" onclick="downloadPrivateKeyPem()"
                        style="display: none;">
                        Download Private Key (PRIVATE.KEY)
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const outputSection = document.getElementById('outputSection');
        const caOutputSection = document.getElementById('caOutputSection');
        const statusDiv = document.getElementById('status');
        const caStatusDiv = document.getElementById('caStatus');
        const clientStatusDiv = document.getElementById('clientStatus');
        const downloadStatusDiv = document.getElementById('downloadStatus');
        const clientOutputSection = document.getElementById('clientOutputSection');
        const defaultConfig = {
            fileName: 'CA.DER',
            serialNumber: '',
            subjectCN: 'TeddyCloud',
            subjectO: 'N/A',
            issuerCN: 'TeddyCloud',
            issuerO: 'N/A',
            validFrom: '2015-11-03T00:00',
            validUntil: '2040-01-01T00:00',
            signatureAlgorithm: 'sha256',
            isCA: true
        };
        let lastGeneratedCert = null;
        let lastCertPem = '';
        let lastKeyPem = '';
        let lastPublicKeyPem = '';
        let lastFileName = defaultConfig.fileName;
        let caState = { cert: null, key: null, certPem: '', keyPem: '', publicKeyPem: '', fileName: 'CA.DER', displaySerial: '' };
        let clientState = { cert: null, key: null, certPem: '', keyPem: '', publicKeyPem: '', fileName: 'CLIENT.DER', displaySerial: '' };
        let macFetchInProgress = false;

        // Check if forge library loaded on page load
        window.addEventListener('load', () => {
            if (!window.forge) {
                showStatus(' Error: Crypto library failed to load. Please check your internet connection and reload the page.', 'error');
            }
            const validFromField = document.getElementById('validFrom');
            const validUntilField = document.getElementById('validUntil');
            const isCAField = document.getElementById('isCA');
            const sigAlgField = document.getElementById('signatureAlgorithm');
            if (validFromField && !validFromField.value) validFromField.value = defaultConfig.validFrom;
            if (validUntilField && !validUntilField.value) validUntilField.value = defaultConfig.validUntil;
            if (isCAField) isCAField.checked = defaultConfig.isCA;
            if (sigAlgField) sigAlgField.value = defaultConfig.signatureAlgorithm;

            attachStepHandlers();
            showCAMode('import');
            updateClientStepAvailability();
            updateClientCompletion();
            updateDownloadStepAvailability();
        });

        function showStatusLocal(el, message, type) {
            if (!el) return;
            el.innerHTML = message;
            el.className = 'status visible ' + type;
        }

        function clearDropZoneFeedback(zoneId) {
            const zone = document.getElementById(zoneId);
            if (!zone) return;
            zone.classList.remove('success');
            const details = zone.querySelector('.drop-zone-details');
            if (details) details.innerHTML = '';
        }

        function setDropZoneFeedback(zoneId, title, lines) {
            const zone = document.getElementById(zoneId);
            if (!zone) return;
            zone.classList.add('success');
            let details = zone.querySelector('.drop-zone-details');
            if (!details) {
                details = document.createElement('div');
                details.className = 'drop-zone-details';
                zone.appendChild(details);
            }
            const safeLines = Array.isArray(lines) ? lines : [];
            details.innerHTML = '<div class="drop-zone-title">' + title + '</div>' + safeLines.map(line => '<div>' + line + '</div>').join('');
        }

        function updateCaCompletion() {
            const card = document.getElementById('caStepCard');
            if (!card) return;
            if (caState.cert && caState.key) {
                card.classList.add('step-complete');
            } else {
                card.classList.remove('step-complete');
            }
            updateClientStepAvailability();
        }

        function updateClientStepAvailability() {
            const card = document.getElementById('clientStepCard');
            const btnMac = document.getElementById('btnFetchMac');
            const btnGenerate = document.getElementById('btnGenerateClient');
            const lockMsg = document.getElementById('clientStepLockedMessage');
            const ready = !!(caState.cert && caState.key);
            if (card) {
                if (ready) {
                    card.classList.remove('step-disabled');
                } else {
                    card.classList.add('step-disabled');
                    card.classList.remove('step-complete');
                }
            }
            if (btnMac) btnMac.disabled = !ready;
            if (btnGenerate) btnGenerate.disabled = !ready;
            if (lockMsg) lockMsg.style.display = ready ? 'none' : 'block';
        }

        function updateClientCompletion() {
            const card = document.getElementById('clientStepCard');
            if (!card) return;
            if (clientState.cert && clientState.key) {
                card.classList.add('step-complete');
            } else {
                card.classList.remove('step-complete');
            }
        }

        function updateDownloadStepAvailability() {
            const card = document.getElementById('downloadStepCard');
            const lockMsg = document.getElementById('downloadStepLockedMessage');
            const buttons = card ? card.querySelectorAll('.btn') : [];
            const ready = !!(clientState.cert && clientState.key);
            if (card) {
                if (ready) {
                    card.classList.remove('step-disabled');
                    card.classList.add('step-complete');
                } else {
                    card.classList.add('step-disabled');
                    card.classList.remove('step-complete');
                }
            }
            buttons.forEach(btn => {
                btn.disabled = !ready;
                btn.style.display = ready ? 'inline-block' : 'none';
            });
            if (lockMsg) lockMsg.style.display = ready ? 'none' : 'block';
        }

        async function flashCertsToESP32() {
            if (!caState.cert || !caState.key || !clientState.cert || !clientState.key) {
                showStatusLocal(downloadStatusDiv, ' Missing CA or client certificates.', 'error');
                return;
            }
            const btn = document.getElementById('btnFlashToESP32');
            const originalLabel = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Flashing...';
            showStatusLocal(downloadStatusDiv, 'Connecting to ESP32...', 'loading');

            let deviceFlasher = null;
            try {
                if (typeof ESPFlasher === 'undefined' || typeof ESP32Parser === 'undefined' || typeof FATParser === 'undefined') {
                    throw new Error('ESPFlasher, ESP32Parser, or FATParser not available.');
                }
                if (!navigator.serial) {
                    throw new Error('Web Serial is not available.');
                }
                const logReads = false;
                const totalSize = 0x800000;

                deviceFlasher = new ESPFlasher({
                    logMessage: (msg) => console.log('[Flasher]', msg),
                    logWarning: (msg) => console.warn('[Flasher WARNING]', msg),
                    logError: (msg) => console.error('[Flasher ERROR]', msg),
                    logDebug: (msg) => console.log('[Flasher DEBUG]', msg),
                    logPackets: false,
                });

                /* Set up callback for unexpected device disconnection */
                deviceFlasher.disconnected = () => {
                    console.log('Device disconnected');
                };

                deviceFlasher.deviceStateCallback = (state, data) => {
                    if (state === 'secure' || state === 'secure_boot') {
                        throw new Error('Secure bootloader detected. Flash access is disabled.');
                    } else if (state === 'secure_download') {
                        throw new Error('Secure download mode detected. Flash readout is disabled.');
                    }
                    console.log(`Device state: ${state}`, data);
                };

                await deviceFlasher.openPort();


                /* Try hard reset + sync across baud rates: default, 250000, 115200 */
                let synced = false;
                const baudCandidates = [deviceFlasher.initialBaudRate, 250000, 115200];
                for (const baud of baudCandidates) {
                    try {
                        if (baud && baud !== deviceFlasher.initialBaudRate) {
                            await deviceFlasher.reopenPort(baud);
                        }
                        showStatusLocal(downloadStatusDiv, 'Resetting ESP32...', 'loading');
                        await deviceFlasher.hardReset(true);

                        showStatusLocal(downloadStatusDiv, 'Syncing...', 'loading');
                        await deviceFlasher.sync();
                        synced = true;
                        break;
                    } catch (err) {
                        showStatusLocal(downloadStatusDiv, 'Sync failed' + (baud ? ` at ${baud} baud` : '') + ': ' + err.message, 'error');
                    }
                }
                if (!synced) {
                    deviceFlasher.disconnect();
                    throw new Error('Failed to sync after trying default, 250000, 115200 baud.');
                }

                const isStub = await deviceFlasher.isStubLoader();

                if (!isStub) {
                    showStatusLocal(downloadStatusDiv, 'Loading stub...', 'loading');
                    const stubLoaded = await deviceFlasher.downloadStub();
                }

                const parser = new ESP32Parser(deviceFlasher, { 
                    sizeHint: totalSize,
                    preReadCommandCbr: (addr, len) => console.log(`[Read] 0x${addr.toString(16)} + ${len}`),
                    postReadCommandCbr: (addr, len) => console.log(`[Read done] 0x${addr.toString(16)} + ${len}`),
                    preWriteCommandCbr: (addr, len) => console.log(`[Write] 0x${addr.toString(16)} + ${len}`),
                    postWriteCommandCbr: (addr, len) => console.log(`[Write done] 0x${addr.toString(16)} + ${len}`)
                });

                showStatusLocal(downloadStatusDiv, 'Synced, checking flash contents...', 'loading');

                const validity = await parser.isValidImage();
                console.log('ESP32 image check:', validity);
                if (!validity || !validity.success || !validity.allValid) {
                    let errorMsg = 'ESP32 image validation failed<br><br>';
                    if (validity) {
                        errorMsg += `${validity.bootloader ? "" : ""} Bootloader: ${validity.bootloader ? "valid" : "invalid"} (offset: 0x${validity.bootloaderOffset?.toString(16) || '?'})<br>`;
                        errorMsg += `${validity.nvs ? "" : ""} NVS: ${validity.nvs ? "pass" : "fail"}<br>`;
                        errorMsg += `${validity.otadata ? "" : ""} OTA Data: ${validity.otadata ? "pass" : "fail"}<br>`;
                        errorMsg += `${validity.bootPartitionValid ? "" : ""} Boot Partition: ${validity.bootPartition || 'not found'} (${validity.bootPartitionValid ? "valid" : "invalid"})<br>`;
                        errorMsg += `${validity.partitionTableOffset ? "" : ""} Partition Table Offset: 0x${validity.partitionTableOffset?.toString(16) || '?'}<br>`;
                        if (validity.error) {
                            errorMsg += `   Error: ${validity.error}<br>`;
                        }
                    } else {
                        errorMsg += 'No validity information returned';
                    }
                    throw new Error(errorMsg);
                }

                const assetsPart = parser.getPartition('assets');
                if (!assetsPart) {
                    throw new Error('Assets partition not found in partition table.');
                }
                console.log('Assets partition:', assetsPart);
                showStatusLocal(downloadStatusDiv, 'Found assets partition. Reading...', 'loading');

                /* Parse FAT filesystem from assets partition */
                const fatParser = await parser.parseFATFilesystem(assetsPart);
                console.log('FAT parser:', fatParser);

                if (!fatParser || fatParser.fatInfo.error) {
                    throw new Error('FAT parse failed: ' + (fatParser.fatInfo?.error || 'Unknown error'));
                }
                showStatusLocal(downloadStatusDiv, 'Deleting old certificates...', 'loading');

                /* Delete old certificates (if they exist) */
                const filesToDelete = ['CERT/CA.DER', 'CERT/CLIENT.DER', 'CERT/PRIVATE.DER'];
                for (const filePath of filesToDelete) {

                    const fileEntry = fatParser.findFileByPath(filePath);

                    if (fileEntry) {
                        const delResult = await fatParser.deleteFile(fileEntry);
                        if (!delResult || !delResult.success) {
                            console.warn(`Failed to delete ${filePath}:`, delResult);
                        } else {
                            console.log(`Deleted ${filePath}, cleared ${delResult.clustersCleared} clusters`);
                        }
                    } else {
                        console.log(`${filePath} not found, skipping deletion`);
                    }
                }
                showStatusLocal(downloadStatusDiv, 'Adding new certificates...', 'loading');

                /* Convert certificates to DER format */
                const caDer = certificateToDer(caState.cert);
                const clientDer = certificateToDer(clientState.cert);
                const privateKeyDer = privateKeyToDer(clientState.key);

                /* Add new certificate files with error checking */
                const addResults = [];
                const addOps = [
                    { path: 'CERT/CA.DER', data: caDer },
                    { path: 'CERT/CLIENT.DER', data: clientDer },
                    { path: 'CERT/PRIVATE.DER', data: privateKeyDer }
                ];

                for (const op of addOps) {
                    const addResult = await fatParser.addFile(op.path, op.data);
                    if (!addResult || !addResult.success) {
                        throw new Error(`Failed to add ${op.path}: ${addResult?.error || 'Unknown error'}`);
                    }
                    addResults.push(addResult);
                    console.log(`Added ${op.path}: ${addResult.clustersAllocated || '?'} clusters`);
                }

                showStatusLocal(downloadStatusDiv, 'Writing partition back to flash...', 'loading');
                const flushResult = await parser.sparseImage.flush();
                if (flushResult && flushResult.error) {
                    throw new Error('Flush failed: ' + flushResult.error);
                }

                showStatusLocal(downloadStatusDiv, ' Certificates flashed successfully!', 'success');

            } catch (err) {
                console.error('Flash failed:', err);
                showStatusLocal(downloadStatusDiv, ' ' + err.message, 'error');
            } finally {
                try {
                    if (deviceFlasher && typeof deviceFlasher.disconnect === 'function') {
                        await deviceFlasher.disconnect();
                    }
                } catch (discErr) {
                    console.warn('Disconnect error:', discErr);
                }
                btn.disabled = false;
                btn.textContent = originalLabel;
            }
        }

        async function fetchMacToClientCN() {
            if (macFetchInProgress) return;
            const btn = document.getElementById('btnFetchMac');
            const cnInput = document.getElementById('clientCN');
            if (!btn || !cnInput) return;
            macFetchInProgress = true;
            const originalLabel = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Fetching...';
            showStatusLocal(clientStatusDiv, 'Connecting to ESP32...', 'loading');

            let flasher = null;
            try {
                if (typeof ESPFlasher === 'undefined') {
                    throw new Error('ESPFlasher not available. Ensure flasher.js is loaded.');
                }
                if (!navigator.serial) {
                    throw new Error('Web Serial is not available in this browser.');
                }
                flasher = new ESPFlasher({
                    logMessage: (msg) => console.log('[Flasher]', msg),
                    logWarning: (msg) => console.warn('[Flasher WARNING]', msg),
                    logError: (msg) => console.error('[Flasher ERROR]', msg),
                    logDebug: (msg) => console.log('[Flasher DEBUG]', msg),
                });
                flasher.disconnected = () => {
                    console.log('Device disconnected');
                };
                await flasher.openPort();
                await flasher.sync();
                const mac = await flasher.readMac();
                if (!mac) {
                    throw new Error('Failed to read MAC address.');
                }
                const formatted = "b'" + mac.replace(/:/g, '').toUpperCase() + "'";
                cnInput.value = formatted;
                showStatusLocal(clientStatusDiv, ' MAC fetched: ' + formatted, 'success');
            } catch (err) {
                console.error('Fetch MAC failed:', err);
                showStatusLocal(clientStatusDiv, ' ' + err.message, 'error');
            } finally {
                try {
                    if (flasher && typeof flasher.disconnect === 'function') {
                        await flasher.disconnect();
                    }
                } catch (discErr) {
                    console.warn('Error during flasher disconnect:', discErr);
                }
                macFetchInProgress = false;
                btn.disabled = false;
                btn.textContent = originalLabel;
            }
        }

        function registerDropZone(zoneId, inputId, handler) {
            const zone = document.getElementById(zoneId);
            const input = document.getElementById(inputId);
            if (!zone || !input) return;

            zone.addEventListener('click', () => input.click());

            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                zone.classList.add('drag-over');
            });

            zone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                zone.classList.remove('drag-over');
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                zone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) handler(files[0]);
            });

            input.addEventListener('change', (e) => {
                if (e.target.files.length > 0) handler(e.target.files[0]);
            });
        }

        function showCAMode(mode) {
            const generateMode = document.getElementById('caGenerateMode');
            const importMode = document.getElementById('caImportMode');
            const btnGenerate = document.getElementById('btnShowGenerateCA');
            const btnImport = document.getElementById('btnShowImportCA');

            if (mode === 'generate') {
                if (generateMode) generateMode.style.display = 'block';
                if (importMode) importMode.style.display = 'none';
                if (btnGenerate) btnGenerate.classList.remove('btn-secondary');
                if (btnImport) btnImport.classList.add('btn-secondary');
            } else {
                if (generateMode) generateMode.style.display = 'none';
                if (importMode) importMode.style.display = 'block';
                if (btnGenerate) btnGenerate.classList.add('btn-secondary');
                if (btnImport) btnImport.classList.remove('btn-secondary');
            }
        }

        function attachStepHandlers() {
            const caBtn = document.getElementById('btnGenerateCA');
            if (caBtn) {
                caBtn.addEventListener('click', async () => {
                    if (!window.forge) {
                        showStatus(' Error: Crypto library not loaded. Please reload the page.', 'error');
                        return;
                    }
                    showStatusLocal(caStatusDiv, 'Generating CA certificate...', 'loading');
                    await new Promise(r => setTimeout(r, 50));
                    try {
                        generateCACertificate();
                        showStatusLocal(caStatusDiv, ' CA generated', 'success');
                    } catch (err) {
                        console.error(err);
                        showStatusLocal(caStatusDiv, ' ' + err.message, 'error');
                    }
                });
            }

            registerDropZone('caCertDropZone', 'caCertInput', handleCaCertFile);
            registerDropZone('caKeyDropZone', 'caKeyInput', handleCaKeyFile);

            const clientBtn = document.getElementById('btnGenerateClient');
            if (clientBtn) {
                clientBtn.addEventListener('click', async () => {
                    if (!window.forge) {
                        showStatus(' Error: Crypto library not loaded. Please reload the page.', 'error');
                        return;
                    }
                    showStatusLocal(clientStatusDiv, 'Generating client certificate...', 'loading');
                    await new Promise(r => setTimeout(r, 50));
                    try {
                        generateClientCertificate();
                        showStatusLocal(clientStatusDiv, ' Client certificate generated', 'success');
                    } catch (err) {
                        console.error(err);
                        showStatusLocal(clientStatusDiv, ' ' + err.message, 'error');
                    }
                });
            }

            const fetchMacBtn = document.getElementById('btnFetchMac');
            if (fetchMacBtn) {
                fetchMacBtn.addEventListener('click', fetchMacToClientCN);
            }
        }



        function generateSerialHex(byteLength = 8) {
            const buf = new Uint8Array(byteLength);
            if (window.crypto && typeof window.crypto.getRandomValues === 'function') {
                window.crypto.getRandomValues(buf);
            } else {
                for (let i = 0; i < byteLength; i++) {
                    buf[i] = Math.floor(Math.random() * 256);
                }
            }
            let hex = '';
            for (let i = 0; i < buf.length; i++) {
                hex += buf[i].toString(16).padStart(2, '0');
            }
            return hex;
        }

        function mapSignatureAlgorithm(oid) {
            if (!oid) return 'Unknown';
            const oidMap = {
                '1.2.840.113549.1.1.5': 'SHA-1 with RSA',
                '1.2.840.113549.1.1.11': 'SHA-256 with RSA',
                '1.2.840.113549.1.1.12': 'SHA-384 with RSA',
                '1.2.840.113549.1.1.13': 'SHA-512 with RSA',
                '1.2.840.10045.4.3.2': 'ECDSA with SHA-256',
                '1.2.840.10045.4.3.3': 'ECDSA with SHA-384'
            };
            return oidMap[oid] || oid;
        }

        function summarizeCertificate(cert) {
            const subject = cert.subject.attributes.reduce((acc, attr) => {
                acc[attr.shortName || attr.name] = attr.value;
                return acc;
            }, {});

            const issuer = cert.issuer.attributes.reduce((acc, attr) => {
                acc[attr.shortName || attr.name] = attr.value;
                return acc;
            }, {});

            let isCA = false;
            const keyUsage = [];
            let keySize = null;

            if (cert.extensions) {
                cert.extensions.forEach(ext => {
                    if (ext.name === 'basicConstraints' && ext.cA) {
                        isCA = true;
                    }
                    if (ext.name === 'keyUsage') {
                        if (ext.digitalSignature) keyUsage.push('Digital Signature');
                        if (ext.dataEncipherment) keyUsage.push('Data Encipherment');
                        if (ext.keyEncipherment) keyUsage.push('Key Encipherment');
                        if (ext.keyCertSign) keyUsage.push('Certificate Signing');
                        if (ext.cRLSign) keyUsage.push('CRL Signing');
                    }
                });
            }

            if (cert.publicKey && cert.publicKey.n && typeof cert.publicKey.n.bitLength === 'function') {
                keySize = cert.publicKey.n.bitLength();
            }

            return {
                subject,
                issuer,
                isCA,
                keyUsage,
                keySize,
                sigAlg: mapSignatureAlgorithm(cert.signatureOid)
            };
        }

        function generateCACertificate() {
            const forge = window.forge;

            if (!forge || !forge.pki) {
                throw new Error('Crypto library not available. Please reload the page.');
            }

            // Get form values
            const commonName = document.getElementById('commonName').value || defaultConfig.subjectCN;
            const organization = document.getElementById('organization').value || defaultConfig.subjectO;
            const country = document.getElementById('country').value;
            const state = document.getElementById('state').value;
            const locality = document.getElementById('locality').value;
            const keySize = parseInt(document.getElementById('keySize').value, 10);
            const serialNumberInput = (document.getElementById('serialNumber').value || '').trim();
            const serialPrepared = prepareSerial(serialNumberInput);
            const validFromInput = document.getElementById('validFrom').value;
            const validUntilInput = document.getElementById('validUntil').value;
            const fileName = (document.getElementById('fileName').value || defaultConfig.fileName).trim() || defaultConfig.fileName;
            const signatureAlgorithm = document.getElementById('signatureAlgorithm').value || defaultConfig.signatureAlgorithm;
            const isCA = document.getElementById('isCA').checked;

            const notBefore = validFromInput ? new Date(validFromInput) : new Date(defaultConfig.validFrom);
            const notAfter = validUntilInput ? new Date(validUntilInput) : new Date(defaultConfig.validUntil);

            // Generate key pair
            console.log('Generating RSA key pair...');
            const keys = forge.pki.rsa.generateKeyPair(keySize);

            // Create certificate
            const cert = forge.pki.createCertificate();
            cert.publicKey = keys.publicKey;
            cert.serialNumber = serialPrepared.derHex;

            // Set validity period
            cert.validity.notBefore = notBefore;
            cert.validity.notAfter = notAfter;

            // Set subject (who the certificate is issued to)
            const attrs = [];
            if (country) attrs.push({ name: 'countryName', value: country.toUpperCase() });
            if (state) attrs.push({ name: 'stateOrProvinceName', value: state });
            if (locality) attrs.push({ name: 'localityName', value: locality });
            if (organization) attrs.push({ name: 'organizationName', value: organization });
            attrs.push({ name: 'commonName', value: commonName });

            cert.setSubject(attrs);

            // Set issuer (for CA cert, issuer = subject because it's self-signed)
            cert.setIssuer(attrs);

            // Set extensions for CA certificate
            cert.setExtensions([
                {
                    name: 'subjectKeyIdentifier'
                },
                {
                    name: 'authorityKeyIdentifier',
                    keyIdentifier: true
                },
                {
                    name: 'basicConstraints',
                    cA: isCA
                },
            ]);

            // Self-sign certificate
            const md = signatureAlgorithm === 'sha256' ? forge.md.sha256.create() : forge.md.sha256.create();
            cert.sign(keys.privateKey, md);

            // Convert to PEM format
            const certPem = forge.pki.certificateToPem(cert);
            const privateKeyPem = forge.pki.privateKeyToPem(keys.privateKey);
            const publicKeyPem = forge.pki.publicKeyToPem(keys.publicKey);

            caState = {
                cert,
                key: keys.privateKey,
                certPem,
                keyPem: privateKeyPem,
                publicKeyPem,
                fileName,
                displaySerial: serialPrepared.displayHex
            };

            // Display results
            displayResults(cert, certPem, privateKeyPem, publicKeyPem, fileName);
            updateCaCompletion();
        }

        function generateClientCertificate() {
            const forge = window.forge;
            if (!forge || !forge.pki) throw new Error('Crypto library not available. Please reload the page.');
            if (!caState.cert || !caState.key) throw new Error('Load or generate a CA certificate and key first.');

            const cn = document.getElementById('clientCN').value || 'Client';
            const org = document.getElementById('clientO').value || 'N/A';
            const c = document.getElementById('clientC').value;
            const st = document.getElementById('clientST').value;
            const l = document.getElementById('clientL').value;
            const keySize = parseInt(document.getElementById('clientKeySize').value, 10);
            const serialInput = (document.getElementById('clientSerial').value || '').trim();
            const serialPrepared = prepareSerial(serialInput);
            const validFromInput = document.getElementById('clientValidFrom').value;
            const validUntilInput = document.getElementById('clientValidUntil').value;
            const fileName = (document.getElementById('clientFileName').value || 'CLIENT.DER').trim() || 'CLIENT.DER';

            const notBefore = validFromInput ? new Date(validFromInput) : new Date();
            const notAfter = validUntilInput ? new Date(validUntilInput) : new Date(Date.now() + 365 * 24 * 3600 * 1000);

            const keys = forge.pki.rsa.generateKeyPair(keySize);
            const cert = forge.pki.createCertificate();
            cert.publicKey = keys.publicKey;
            cert.serialNumber = serialPrepared.derHex;
            cert.validity.notBefore = notBefore;
            cert.validity.notAfter = notAfter;

            const subjectAttrs = [];
            if (c) subjectAttrs.push({ name: 'countryName', value: c.toUpperCase() });
            if (st) subjectAttrs.push({ name: 'stateOrProvinceName', value: st });
            if (l) subjectAttrs.push({ name: 'localityName', value: l });
            if (org) subjectAttrs.push({ name: 'organizationName', value: org });
            subjectAttrs.push({ name: 'commonName', value: cn });
            cert.setSubject(subjectAttrs);

            cert.setIssuer(caState.cert.subject.attributes);

            cert.setExtensions([
                { name: 'basicConstraints', cA: false },
                { name: 'subjectKeyIdentifier' },
                { name: 'authorityKeyIdentifier', keyIdentifier: true }
            ]);

            cert.sign(caState.key, forge.md.sha256.create());

            const certPem = forge.pki.certificateToPem(cert);
            const privateKeyPem = forge.pki.privateKeyToPem(keys.privateKey);
            const publicKeyPem = forge.pki.publicKeyToPem(keys.publicKey);

            clientState = {
                cert,
                key: keys.privateKey,
                certPem,
                keyPem: privateKeyPem,
                publicKeyPem,
                fileName,
                displaySerial: serialPrepared.displayHex
            };

            displayClientResults(cert, certPem, privateKeyPem, publicKeyPem, fileName);
            updateClientCompletion();
            updateDownloadStepAvailability();
        }

        function displayResults(cert, certPem, privateKeyPem, publicKeyPem, fileName) {
            const details = summarizeCertificate(cert);
            const certInfo = document.getElementById('caCertInfo');

            certInfo.innerHTML = `
                <div class="info-label">File Name:</div>
                <div class="info-value">${fileName}</div>
                
                <div class="info-label">Serial Number:</div>
                <div class="info-value">${formatSerialForDisplay(cert.serialNumber)}</div>
                
                <div class="info-label">Subject CN:</div>
                <div class="info-value">${details.subject.CN || 'N/A'}</div>
                
                <div class="info-label">Subject O:</div>
                <div class="info-value">${details.subject.O || 'N/A'}</div>

                <div class="info-label">Subject C:</div>
                <div class="info-value">${details.subject.C || 'N/A'}</div>

                <div class="info-label">Subject ST:</div>
                <div class="info-value">${details.subject.ST || 'N/A'}</div>

                <div class="info-label">Subject L:</div>
                <div class="info-value">${details.subject.L || 'N/A'}</div>

                <div class="info-label">Issuer CN:</div>
                <div class="info-value">${details.issuer.CN || 'N/A'}</div>
                
                <div class="info-label">Issuer O:</div>
                <div class="info-value">${details.issuer.O || 'N/A'}</div>

                <div class="info-label">Issuer C:</div>
                <div class="info-value">${details.issuer.C || 'N/A'}</div>

                <div class="info-label">Issuer ST:</div>
                <div class="info-value">${details.issuer.ST || 'N/A'}</div>

                <div class="info-label">Issuer L:</div>
                <div class="info-value">${details.issuer.L || 'N/A'}</div>
                
                <div class="info-label">Valid From:</div>
                <div class="info-value">${cert.validity.notBefore.toLocaleString()}</div>
                
                <div class="info-label">Valid Until:</div>
                <div class="info-value">${cert.validity.notAfter.toLocaleString()}</div>
                
                <div class="info-label">Signature Algorithm:</div>
                <div class="info-value">${details.sigAlg}</div>
                
                <div class="info-label">Is CA:</div>
                <div class="info-value" style="color: ${details.isCA ? '#28a745' : '#dc3545'};">${details.isCA ? 'Yes' : 'No'}</div>
                
                <div class="info-label">Key Usage:</div>
                <div class="info-value">${details.keyUsage.length > 0 ? details.keyUsage.join(', ') : 'N/A'}</div>

                <div class="info-label">RSA Key Size:</div>
                <div class="info-value">${details.keySize ? details.keySize + ' bits' : 'N/A'}</div>
            `;

            lastGeneratedCert = cert;
            lastCertPem = certPem;
            lastKeyPem = privateKeyPem;
            lastPublicKeyPem = publicKeyPem;
            lastFileName = fileName;
            refreshDownloadLabels(fileName);

            // Show download buttons
            const downloadDerBtn = document.getElementById('downloadCaDerBtn');
            const downloadPemBtn = document.getElementById('downloadCaPemBtn');
            const downloadKeyBtn = document.getElementById('downloadCaKeyBtn');
            const downloadPublicKeyBtn = document.getElementById('downloadCaPublicKeyBtn');

            if (downloadDerBtn) downloadDerBtn.style.display = 'inline-block';
            if (downloadPemBtn) downloadPemBtn.style.display = 'inline-block';
            if (privateKeyPem && downloadKeyBtn) downloadKeyBtn.style.display = 'inline-block';
            if (publicKeyPem && downloadPublicKeyBtn) downloadPublicKeyBtn.style.display = 'inline-block';

            caOutputSection.classList.add('visible');
            caOutputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function toggleCollapse(elementId) {
            const element = document.getElementById(elementId);
            const toggleIcon = document.getElementById(elementId + 'Toggle');

            if (element.classList.contains('collapsed')) {
                element.classList.remove('collapsed');
                if (toggleIcon) toggleIcon.textContent = '';
            } else {
                element.classList.add('collapsed');
                if (toggleIcon) toggleIcon.textContent = '';
            }
        }

        function displayClientResults(cert, certPem, privateKeyPem, publicKeyPem, fileName) {
            const details = summarizeCertificate(cert);
            const info = document.getElementById('clientCertInfo');
            if (info) {
                info.innerHTML = `
                    <div class="info-label">File Name:</div>
                    <div class="info-value">${fileName}</div>
                    
                    <div class="info-label">Serial Number:</div>
                    <div class="info-value">${formatSerialForDisplay(cert.serialNumber)}</div>
                    
                    <div class="info-label">Subject CN:</div>
                    <div class="info-value">${details.subject.CN || 'N/A'}</div>
                    
                    <div class="info-label">Subject O:</div>
                    <div class="info-value">${details.subject.O || 'N/A'}</div>

                    <div class="info-label">Subject C:</div>
                    <div class="info-value">${details.subject.C || 'N/A'}</div>

                    <div class="info-label">Subject ST:</div>
                    <div class="info-value">${details.subject.ST || 'N/A'}</div>

                    <div class="info-label">Subject L:</div>
                    <div class="info-value">${details.subject.L || 'N/A'}</div>

                    <div class="info-label">Issuer CN:</div>
                    <div class="info-value">${details.issuer.CN || 'N/A'}</div>
                    
                    <div class="info-label">Issuer O:</div>
                    <div class="info-value">${details.issuer.O || 'N/A'}</div>

                    <div class="info-label">Issuer C:</div>
                    <div class="info-value">${details.issuer.C || 'N/A'}</div>

                    <div class="info-label">Issuer ST:</div>
                    <div class="info-value">${details.issuer.ST || 'N/A'}</div>

                    <div class="info-label">Issuer L:</div>
                    <div class="info-value">${details.issuer.L || 'N/A'}</div>
                    
                    <div class="info-label">Valid From:</div>
                    <div class="info-value">${cert.validity.notBefore.toLocaleString()}</div>
                    
                    <div class="info-label">Valid Until:</div>
                    <div class="info-value">${cert.validity.notAfter.toLocaleString()}</div>
                    
                    <div class="info-label">Signature Algorithm:</div>
                    <div class="info-value">${details.sigAlg}</div>
                    
                    <div class="info-label">Is CA:</div>
                    <div class="info-value" style="color: ${details.isCA ? '#28a745' : '#dc3545'};">${details.isCA ? 'Yes' : 'No'}</div>
                    
                    <div class="info-label">Key Usage:</div>
                    <div class="info-value">${details.keyUsage.length > 0 ? details.keyUsage.join(', ') : 'N/A'}</div>

                    <div class="info-label">RSA Key Size:</div>
                    <div class="info-value">${details.keySize ? details.keySize + ' bits' : 'N/A'}</div>
                `;
            }

            // Show download buttons
            const downloadClientDerBtn = document.getElementById('btnDownloadClientDer');
            const downloadClientPemBtn = document.getElementById('btnDownloadClientPem');
            const downloadClientKeyDerBtn = document.getElementById('btnDownloadClientKeyDer');
            const downloadClientKeyPemBtn = document.getElementById('btnDownloadClientKeyPem');

            if (downloadClientDerBtn) downloadClientDerBtn.style.display = 'inline-block';
            if (downloadClientPemBtn) downloadClientPemBtn.style.display = 'inline-block';
            if (downloadClientKeyDerBtn) downloadClientKeyDerBtn.style.display = 'inline-block';
            if (downloadClientKeyPemBtn) downloadClientKeyPemBtn.style.display = 'inline-block';

            clientOutputSection.classList.add('visible');
            clientOutputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function downloadBinaryFile(filename, byteArray, mime = 'application/pkix-cert') {
            const blob = new Blob([byteArray], { type: mime });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function certificateToDer(cert) {
            const forge = window.forge;
            const asn1Cert = forge.pki.certificateToAsn1(cert);
            const derBytes = forge.asn1.toDer(asn1Cert).getBytes();
            const derArray = new Uint8Array(derBytes.length);
            for (let i = 0; i < derBytes.length; i++) {
                derArray[i] = derBytes.charCodeAt(i);
            }
            return derArray;
        }

        function privateKeyToDer(key) {
            const forge = window.forge;
            const asn1Key = forge.pki.privateKeyToAsn1(key);
            const derBytes = forge.asn1.toDer(asn1Key).getBytes();
            const derArray = new Uint8Array(derBytes.length);
            for (let i = 0; i < derBytes.length; i++) {
                derArray[i] = derBytes.charCodeAt(i);
            }
            return derArray;
        }

        function ensureExtension(name, desiredExt) {
            const cleanExt = desiredExt.startsWith('.') ? desiredExt.slice(1) : desiredExt;
            const trimmed = name.trim();
            if (!trimmed) return 'CA.' + cleanExt;
            return trimmed.replace(/\.[^.]+$/, '') + '.' + cleanExt;
        }

        function baseName(name) {
            if (!name) return 'CA';
            return name.replace(/\.[^.]+$/, '') || 'CA';
        }

        function getFileNameOrDefault() {
            const field = document.getElementById('fileName');
            const name = field ? field.value.trim() : '';
            return name || defaultConfig.fileName;
        }

        function getClientFileNameOrDefault() {
            const field = document.getElementById('clientFileName');
            const name = field ? field.value.trim() : '';
            return name || 'CLIENT.DER';
        }

        function downloadGeneratedDer() {
            if (!lastGeneratedCert) {
                showStatus(' Generate or decode a certificate first.', 'error');
                return;
            }
            const derArray = certificateToDer(lastGeneratedCert);
            downloadBinaryFile(ensureExtension(getFileNameOrDefault(), 'der'), derArray);
        }

        function downloadGeneratedPem() {
            if (!lastCertPem) {
                showStatus(' Generate or decode a certificate first.', 'error');
                return;
            }
            downloadFile(ensureExtension(getFileNameOrDefault(), 'pem'), lastCertPem);
        }

        function downloadPrivateKeyPem() {
            if (!lastKeyPem) {
                showStatus(' No private key available for this certificate.', 'error');
                return;
            }
            downloadFile('PRIVATE.KEY', lastKeyPem);
        }

        function downloadPublicKeyPem() {
            if (!lastPublicKeyPem) {
                showStatus(' No public key available for this certificate.', 'error');
                return;
            }
            const base = baseName(getFileNameOrDefault());
            downloadFile(base + '-public-key.pem', lastPublicKeyPem);
        }

        function downloadCaDer() {
            if (!caState.cert) {
                showStatusLocal(caStatusDiv, ' Generate or import a CA certificate first.', 'error');
                return;
            }
            downloadBinaryFile("CA.DER", certificateToDer(caState.cert), 'application/pkix-cert');
        }

        function downloadClientDer() {
            if (!clientState.cert) {
                showStatusLocal(clientStatusDiv, ' Generate a client certificate first.', 'error');
                return;
            }
            downloadBinaryFile("CLIENT.DER", certificateToDer(clientState.cert));
        }

        function downloadClientPem() {
            if (!clientState.certPem) {
                showStatusLocal(clientStatusDiv, ' Generate a client certificate first.', 'error');
                return;
            }
            downloadFile("CLIENT.PEM", clientState.certPem);
        }

        function downloadClientKeyDer() {
            if (!clientState.key) {
                showStatusLocal(clientStatusDiv, ' Generate a client certificate first.', 'error');
                return;
            }
            downloadBinaryFile('PRIVATE.DER', privateKeyToDer(clientState.key), 'application/pkcs8');
        }

        function downloadClientKeyPem() {
            if (!clientState.keyPem) {
                showStatusLocal(clientStatusDiv, ' Generate a client certificate first.', 'error');
                return;
            }
            downloadFile('PRIVATE.PEM', clientState.keyPem);
        }

        function refreshDownloadLabels(fileName) {
            const derBtn = document.getElementById('downloadCaDerBtn');
            const pemBtn = document.getElementById('downloadCaPemBtn');
            if (derBtn) derBtn.textContent = 'Download DER (' + ensureExtension(fileName, 'der') + ')';
            if (pemBtn) pemBtn.textContent = 'Download PEM (' + ensureExtension(fileName, 'pem') + ')';

            const decodeDerBtn = document.getElementById('downloadDerBtn');
            const decodePemBtn = document.getElementById('downloadPemBtn');
            if (decodeDerBtn) decodeDerBtn.textContent = 'Download DER (' + ensureExtension(fileName, 'der') + ')';
            if (decodePemBtn) decodePemBtn.textContent = 'Download PEM (' + ensureExtension(fileName, 'pem') + ')';
        }

        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status visible ' + type;
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.getElementById('generateTab').classList.remove('active');
            document.getElementById('decodeTab').classList.remove('active');

            if (tabName === 'generate') {
                document.getElementById('generateTab').classList.add('active');
            } else {
                document.getElementById('decodeTab').classList.add('active');
            }

            // Hide output when switching tabs
            outputSection.classList.remove('visible');
        }

        // File drop handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleCertificateFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleCertificateFile(e.target.files[0]);
            }
        });

        async function handleCertificateFile(file) {
            if (!window.forge) {
                showStatus(' Error: Crypto library not loaded. Please reload the page.', 'error');
                return;
            }

            const forge = window.forge;
            const fileName = file.name.toLowerCase();

            showStatus('Reading certificate file...', 'info');

            try {
                const arrayBuffer = await file.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                let cert;

                // Check if it's DER format (binary) or PEM format (text)
                if (fileName.endsWith('.der')) {
                    // DER format - binary ASN.1
                    const asn1 = forge.asn1.fromDer(forge.util.createBuffer(bytes));
                    cert = forge.pki.certificateFromAsn1(asn1);
                } else {
                    // Try PEM format - text based
                    const pemText = new TextDecoder().decode(bytes);

                    // Check if it contains a certificate
                    if (pemText.includes('BEGIN CERTIFICATE')) {
                        cert = forge.pki.certificateFromPem(pemText);
                    } else if (pemText.includes('BEGIN RSA PRIVATE KEY') || pemText.includes('BEGIN PRIVATE KEY')) {
                        showStatus(' This appears to be a private key, not a certificate.', 'error');
                        return;
                    } else {
                        // Try parsing as DER anyway
                        const asn1 = forge.asn1.fromDer(forge.util.createBuffer(bytes));
                        cert = forge.pki.certificateFromAsn1(asn1);
                    }
                }

                // Convert to PEM for display
                const certPem = forge.pki.certificateToPem(cert);

                // Try to extract public key
                let publicKeyPem = '';
                try {
                    publicKeyPem = forge.pki.publicKeyToPem(cert.publicKey);
                } catch (e) {
                    console.warn('Could not extract public key:', e);
                }

                // Display the decoded certificate
                displayDecodedCertificate(cert, certPem, publicKeyPem, file.name);
                showStatus(' Certificate decoded successfully!', 'success');

            } catch (error) {
                console.error('Error decoding certificate:', error);
                showStatus(' Error decoding certificate: ' + error.message, 'error');
                alert('Failed to decode certificate. Please ensure it is a valid X.509 certificate in DER, PEM, or CRT format.');
            }
        }

        function normalizeSerialHex(input) {
            if (!input) return '';
            let hex = input.trim();
            hex = hex.replace(/^0x/i, '');
            hex = hex.replace(/[^0-9a-fA-F]/g, '');
            if (!hex) return '';
            if (hex.length % 2 !== 0) hex = '0' + hex;
            return hex.toLowerCase();
        }

        function prepareSerial(hexInput) {
            let clean = normalizeSerialHex(hexInput);
            if (!clean) clean = normalizeSerialHex(defaultConfig.serialNumber);
            if (!clean) clean = normalizeSerialHex(generateSerialHex(8));

            const firstByte = parseInt(clean.slice(0, 2), 16);
            const derHex = (firstByte >= 0x80 ? '00' : '') + clean;

            const displayHex = (clean.startsWith('00') ? clean.slice(2) : clean)
                .match(/.{1,2}/g)
                .map(pair => pair.toUpperCase())
                .join(':');

            return {
                derHex,
                displayHex: displayHex || 'N/A'
            };
        }

        function formatSerialForDisplay(serialHex) {
            const clean = normalizeSerialHex(serialHex);
            if (!clean) return 'N/A';
            const trimmed = clean.startsWith('00') ? clean.slice(2) : clean;
            return trimmed.match(/.{1,2}/g).map(pair => pair.toUpperCase()).join(':');
        }

        async function handleCaCertFile(file) {
            if (!window.forge) {
                showStatusLocal(caStatusDiv, ' Crypto library not loaded.', 'error');
                return;
            }
            const forge = window.forge;
            try {
                clearDropZoneFeedback('caCertDropZone');
                const arrayBuffer = await file.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                const lower = file.name.toLowerCase();
                let cert;
                if (lower.endsWith('.der')) {
                    const asn1 = forge.asn1.fromDer(forge.util.createBuffer(bytes));
                    cert = forge.pki.certificateFromAsn1(asn1);
                } else {
                    const pemText = new TextDecoder().decode(bytes);
                    if (pemText.includes('BEGIN CERTIFICATE')) {
                        cert = forge.pki.certificateFromPem(pemText);
                    } else {
                        const asn1 = forge.asn1.fromDer(forge.util.createBuffer(bytes));
                        cert = forge.pki.certificateFromAsn1(asn1);
                    }
                }

                const certPem = forge.pki.certificateToPem(cert);
                const publicKeyPem = forge.pki.publicKeyToPem(cert.publicKey);
                caState.cert = cert;
                caState.certPem = certPem;
                caState.publicKeyPem = publicKeyPem;
                caState.fileName = file.name;
                caState.displaySerial = formatSerialForDisplay(cert.serialNumber);

                displayResults(cert, certPem, caState.keyPem || '', publicKeyPem, file.name);
                const details = summarizeCertificate(cert);
                setDropZoneFeedback('caCertDropZone', 'CA certificate loaded', [
                    'File: ' + file.name,
                    'CN: ' + (details.subject.CN || 'N/A'),
                    'Serial: ' + formatSerialForDisplay(cert.serialNumber),
                    'Valid: ' + cert.validity.notBefore.toLocaleDateString() + ' to ' + cert.validity.notAfter.toLocaleDateString(),
                    'Key: ' + (details.keySize ? details.keySize + ' bit RSA' : 'Unknown')
                ]);
                // showStatusLocal(caStatusDiv, ' CA certificate loaded', 'success');
                updateCaCompletion();
            } catch (err) {
                console.error('CA cert import failed:', err);
                showStatusLocal(caStatusDiv, ' Failed to import CA certificate: ' + err.message, 'error');
                clearDropZoneFeedback('caCertDropZone');
            }
        }

        async function handleCaKeyFile(file) {
            if (!window.forge) {
                showStatusLocal(caStatusDiv, ' Crypto library not loaded.', 'error');
                return;
            }
            const forge = window.forge;
            try {
                clearDropZoneFeedback('caKeyDropZone');
                const arrayBuffer = await file.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                const text = new TextDecoder().decode(bytes);
                let key;
                if (text.includes('BEGIN RSA PRIVATE KEY') || text.includes('BEGIN PRIVATE KEY')) {
                    key = forge.pki.privateKeyFromPem(text);
                } else {
                    const asn1 = forge.asn1.fromDer(forge.util.createBuffer(bytes));
                    key = forge.pki.privateKeyFromAsn1(asn1);
                }

                const keyPem = forge.pki.privateKeyToPem(key);
                caState.key = key;
                caState.keyPem = keyPem;

                if (caState.cert) {
                    displayResults(caState.cert, caState.certPem, keyPem, caState.publicKeyPem || '', caState.fileName || 'CA.DER');
                }
                const keyBits = key && key.n && typeof key.n.bitLength === 'function' ? key.n.bitLength() : null;
                const isPem = text.includes('BEGIN RSA PRIVATE KEY') || text.includes('BEGIN PRIVATE KEY');
                setDropZoneFeedback('caKeyDropZone', 'CA key loaded', [
                    'File: ' + file.name,
                    'Format: ' + (isPem ? 'PEM' : 'DER'),
                    'Type: RSA' + (keyBits ? ' (' + keyBits + ' bit)' : '')
                ]);
                // showStatusLocal(caStatusDiv, ' CA private key loaded', 'success');
                updateCaCompletion();
                updateDownloadStepAvailability();
            } catch (err) {
                console.error('CA key import failed:', err);
                showStatusLocal(caStatusDiv, ' Failed to import CA key: ' + err.message, 'error');
                clearDropZoneFeedback('caKeyDropZone');
            }
        }

        function displayDecodedCertificate(cert, certPem, publicKeyPem, fileName) {
            const details = summarizeCertificate(cert);

            // Build the output HTML
            const certInfo = document.getElementById('certInfo');
            certInfo.innerHTML = `
                <div class="info-label">File Name:</div>
                <div class="info-value">${fileName}</div>
                
                <div class="info-label">Serial Number:</div>
                <div class="info-value">${formatSerialForDisplay(cert.serialNumber)}</div>
                
                <div class="info-label">Subject CN:</div>
                <div class="info-value">${details.subject.CN || 'N/A'}</div>
                
                <div class="info-label">Subject O:</div>
                <div class="info-value">${details.subject.O || 'N/A'}</div>

                <div class="info-label">Subject C:</div>
                <div class="info-value">${details.subject.C || 'N/A'}</div>

                <div class="info-label">Subject ST:</div>
                <div class="info-value">${details.subject.ST || 'N/A'}</div>

                <div class="info-label">Subject L:</div>
                <div class="info-value">${details.subject.L || 'N/A'}</div>
                
                <div class="info-label">Issuer CN:</div>
                <div class="info-value">${details.issuer.CN || 'N/A'}</div>
                
                <div class="info-label">Issuer O:</div>
                <div class="info-value">${details.issuer.O || 'N/A'}</div>

                <div class="info-label">Issuer C:</div>
                <div class="info-value">${details.issuer.C || 'N/A'}</div>

                <div class="info-label">Issuer ST:</div>
                <div class="info-value">${details.issuer.ST || 'N/A'}</div>

                <div class="info-label">Issuer L:</div>
                <div class="info-value">${details.issuer.L || 'N/A'}</div>
                
                <div class="info-label">Valid From:</div>
                <div class="info-value">${cert.validity.notBefore.toLocaleString()}</div>
                
                <div class="info-label">Valid Until:</div>
                <div class="info-value">${cert.validity.notAfter.toLocaleString()}</div>
                
                <div class="info-label">Signature Algorithm:</div>
                <div class="info-value">${details.sigAlg}</div>
                
                <div class="info-label">Is CA:</div>
                <div class="info-value" style="color: ${details.isCA ? '#28a745' : '#dc3545'};">${details.isCA ? 'Yes' : 'No'}</div>
                
                <div class="info-label">Key Usage:</div>
                <div class="info-value">${details.keyUsage.length > 0 ? details.keyUsage.join(', ') : 'N/A'}</div>

                <div class="info-label">RSA Key Size:</div>
                <div class="info-value">${details.keySize ? details.keySize + ' bits' : 'N/A'}</div>
            `;

            lastGeneratedCert = cert;
            lastCertPem = certPem;
            lastPublicKeyPem = publicKeyPem;
            lastKeyPem = '';
            lastFileName = fileName;
            refreshDownloadLabels(fileName);

            // Show download buttons
            const downloadDerBtn = document.getElementById('downloadDerBtn');
            const downloadPemBtn = document.getElementById('downloadPemBtn');
            const downloadKeyBtn = document.getElementById('downloadKeyBtn');
            const downloadPublicKeyBtn = document.getElementById('downloadPublicKeyBtn');

            if (downloadDerBtn) downloadDerBtn.style.display = 'inline-block';
            if (downloadPemBtn) downloadPemBtn.style.display = 'inline-block';
            if (downloadKeyBtn) downloadKeyBtn.style.display = 'none'; // No private key for decoded certs
            if (publicKeyPem && downloadPublicKeyBtn) downloadPublicKeyBtn.style.display = 'inline-block';

            // Show output section
            outputSection.classList.add('visible');
            outputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    </script>
</body>

</html>